---
title: Scrivere applicazioni che usano le code del bus di servizio di Azure | Documentazione Microsoft
description: Come scrivere una semplice applicazione basata sulle code che usa il bus di servizio di Azure.
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 754d91b3-1426-405e-84b4-fd36d65b114a
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 08/07/2017
ms.author: sethm
ms.openlocfilehash: 419caff7e8ceeb419c89a2ef9a6614c1accf3e52
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/18/2017
---
# <a name="create-applications-that-use-service-bus-queues"></a><span data-ttu-id="ebb61-103">Creare applicazioni che utilizzano le code del Bus di servizio</span><span class="sxs-lookup"><span data-stu-id="ebb61-103">Create applications that use Service Bus queues</span></span>
<span data-ttu-id="ebb61-104">Questo argomento descrive le code del bus di servizio e illustra come scrivere una semplice applicazione basata sulle code che usa il bus di servizio.</span><span class="sxs-lookup"><span data-stu-id="ebb61-104">This topic describes Service Bus queues and shows how to write a simple queue-based application that uses Service Bus.</span></span>

<span data-ttu-id="ebb61-105">Si consideri uno scenario dal mondo della vendita al dettaglio in cui i dati di vendita da singoli terminali di punto di vendita (POS) devono essere indirizzati a un sistema di gestione dell’inventario che utilizza i dati per determinare quando è necessario un nuovo approvvigionamento.</span><span class="sxs-lookup"><span data-stu-id="ebb61-105">Consider a scenario from the world of retail in which sales data from individual Point-of-Sale (POS) terminals must be routed to an inventory management system that uses the data to determine when stock has to be replenished.</span></span> <span data-ttu-id="ebb61-106">Questa soluzione utilizza il Bus di servizio di messaggistica per la comunicazione tra i terminali e il sistema di gestione dell’inventario, come illustrato nella figura riportata di seguito:</span><span class="sxs-lookup"><span data-stu-id="ebb61-106">This solution uses Service Bus messaging for the communication between the terminals and the inventory management system, as illustrated in the following figure:</span></span>

![Figura 1 Code del bus di servizio](./media/service-bus-create-queues/IC657161.gif)

<span data-ttu-id="ebb61-108">Ogni terminale POS segnala i dati di vendita tramite l'invio di messaggi alla coda **DataCollectionQueue**.</span><span class="sxs-lookup"><span data-stu-id="ebb61-108">Each POS terminal reports its sales data by sending messages to the **DataCollectionQueue**.</span></span> <span data-ttu-id="ebb61-109">I messaggi rimangono nella coda finché vengono recuperati dal sistema di gestione dell’inventario.</span><span class="sxs-lookup"><span data-stu-id="ebb61-109">These messages remain in this queue until they are retrieved by the inventory management system.</span></span> <span data-ttu-id="ebb61-110">Questo schema viene spesso definito *messaggistica asincrona*, perché il terminale non deve attendere una risposta dal sistema di gestione inventario per continuare l'elaborazione.</span><span class="sxs-lookup"><span data-stu-id="ebb61-110">This pattern is often termed *asynchronous messaging*, because the POS terminal does not have to wait for a reply from the inventory management system to continue processing.</span></span>

## <a name="why-queuing"></a><span data-ttu-id="ebb61-111">Quali sono i vantaggi offerti dalle code?</span><span class="sxs-lookup"><span data-stu-id="ebb61-111">Why queuing?</span></span>
<span data-ttu-id="ebb61-112">Prima di esaminare il codice necessario per configurare questa applicazione, considerare i vantaggi dell'utilizzo di una coda in questo scenario anziché i terminali POS per parlare direttamente (in modo sincrono) con il sistema di gestione del magazzino.</span><span class="sxs-lookup"><span data-stu-id="ebb61-112">Before we look at the code that is required to set up this application, consider the advantages of using a queue in this scenario instead of having the POS terminals talk directly (synchronously) to the inventory management system.</span></span>

### <a name="temporal-decoupling"></a><span data-ttu-id="ebb61-113">Disaccoppiamento temporaneo.</span><span class="sxs-lookup"><span data-stu-id="ebb61-113">Temporal decoupling</span></span>
<span data-ttu-id="ebb61-114">Grazie al modello di messaggistica asincrono, non è necessario che produttori e gli utenti siano online nello stesso momento.</span><span class="sxs-lookup"><span data-stu-id="ebb61-114">With the asynchronous messaging pattern, producers and consumers do not have to be online at the same time.</span></span> <span data-ttu-id="ebb61-115">L'infrastruttura di messaggistica archivia in modo affidabile i messaggi fino a quando l’utente è pronto a riceverli.</span><span class="sxs-lookup"><span data-stu-id="ebb61-115">The messaging infrastructure reliably stores messages until the consuming party is ready to receive them.</span></span> <span data-ttu-id="ebb61-116">Questo consente la disconnessione volontaria (ad esempio, per attività di manutenzione) o involontaria (a seguito di un guasto) dei componenti dell'applicazione distribuita senza ripercussioni sull'intero sistema.</span><span class="sxs-lookup"><span data-stu-id="ebb61-116">This means the components of the distributed application can be disconnected, either voluntarily; for example, for maintenance, or due to a component crash, without affecting the whole system.</span></span> <span data-ttu-id="ebb61-117">È inoltre possibile che l'applicazione dell’utente possa dover essere online solo in determinati orari.</span><span class="sxs-lookup"><span data-stu-id="ebb61-117">Furthermore, the consuming application may only have to be online during certain times of the day.</span></span> <span data-ttu-id="ebb61-118">Ad esempio, in questo scenario di vendita al dettaglio, il sistema di gestione dell’inventario potrebbe essere online solo dopo la fine della giornata lavorativa.</span><span class="sxs-lookup"><span data-stu-id="ebb61-118">For example, in this retail scenario, the inventory management system may only have to come online after the end of the business day.</span></span>

### <a name="load-leveling"></a><span data-ttu-id="ebb61-119">Livellamento del carico</span><span class="sxs-lookup"><span data-stu-id="ebb61-119">Load leveling</span></span>
<span data-ttu-id="ebb61-120">In molte applicazioni il carico del sistema varia in base al momento, mentre il tempo di elaborazione richiesto per ciascuna unità di lavoro è in genere costante.</span><span class="sxs-lookup"><span data-stu-id="ebb61-120">In many applications system load varies over time, whereas the processing time required for each unit of work is typically constant.</span></span> <span data-ttu-id="ebb61-121">L'interposizione di una coda tra produttori e utenti di messaggi implica che è necessario solo eseguire il provisioning dell'applicazione utente (il ruolo di lavoro) per servire a quest'ultima un carico medio anziché il carico massimo.</span><span class="sxs-lookup"><span data-stu-id="ebb61-121">Intermediating message producers and consumers with a queue means that the consuming application (the worker) only has to be provisioned to service an average load rather than a peak load.</span></span> <span data-ttu-id="ebb61-122">In base alla variazione del carico in ingresso, si verificherà un incremento o una riduzione della profondità della coda,</span><span class="sxs-lookup"><span data-stu-id="ebb61-122">The depth of the queue will grow and contract as the incoming load varies.</span></span> <span data-ttu-id="ebb61-123">con un risparmio diretto in termini economici rispetto alle risorse infrastrutturali richieste per gestire il carico dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="ebb61-123">This directly saves money with regard to the amount of infrastructure required to service the application load.</span></span>

![Figura 2 Code del bus di servizio](./media/service-bus-create-queues/IC657162.gif)

### <a name="load-balancing"></a><span data-ttu-id="ebb61-125">Bilanciamento del carico.</span><span class="sxs-lookup"><span data-stu-id="ebb61-125">Load balancing</span></span>
<span data-ttu-id="ebb61-126">Con l'aumento del carico, è possibile aggiungere altri processi di lavoro per la lettura della coda di lavoro.</span><span class="sxs-lookup"><span data-stu-id="ebb61-126">As the load increases, more worker processes can be added to read from the worker queue.</span></span> <span data-ttu-id="ebb61-127">Ciascun messaggio viene elaborato da un solo processo di lavoro.</span><span class="sxs-lookup"><span data-stu-id="ebb61-127">Each message is processed by only one of the worker processes.</span></span> <span data-ttu-id="ebb61-128">Inoltre, il bilanciamento del carico di tipo pull permette un uso ottimale dei computer di lavoro anche quando questi presentano una potenza di elaborazione diversa.Ogni computer effettuerà infatti il pull dei messaggi in base alla propria velocità massima.</span><span class="sxs-lookup"><span data-stu-id="ebb61-128">Furthermore, this pull-based load balancing allows for optimum usage of the worker computers even if the worker computers differ with regard to processing power, as they will pull messages at their own maximum rate.</span></span> <span data-ttu-id="ebb61-129">Questo modello viene spesso definito modello del consumer concorrente.</span><span class="sxs-lookup"><span data-stu-id="ebb61-129">This pattern is often termed the competing consumer pattern.</span></span>

![Figura 3 Code del bus di servizio](./media/service-bus-create-queues/IC657163.gif)

### <a name="loose-coupling"></a><span data-ttu-id="ebb61-131">Accoppiamento di tipo loose</span><span class="sxs-lookup"><span data-stu-id="ebb61-131">Loose coupling</span></span>
<span data-ttu-id="ebb61-132">L’utilizzo di un messaggio di cosa da interporre tra producer e consumer fornisce un accoppiamento intrinseco di tipo loose tra i componenti.</span><span class="sxs-lookup"><span data-stu-id="ebb61-132">Using message queuing to intermediate between message producers and consumers provides an intrinsic loose coupling between the components.</span></span> <span data-ttu-id="ebb61-133">Poiché producer e consumer sono indipendenti gli uni dagli altri, è possibile aggiornare un consumer senza causare alcun effetto sul producer.</span><span class="sxs-lookup"><span data-stu-id="ebb61-133">Because producers and consumers are not aware of each other, a consumer can be upgraded without having any effect on the producer.</span></span> <span data-ttu-id="ebb61-134">Inoltre, la topologia di messaggistica può evolversi senza influire sugli endpoint esistenti.</span><span class="sxs-lookup"><span data-stu-id="ebb61-134">Furthermore, the messaging topology can evolve without affecting the existing endpoints.</span></span> <span data-ttu-id="ebb61-135">Tratteremo questo in modo più approfondito quando si parlerà di pubblicazione/sottoscrizione.</span><span class="sxs-lookup"><span data-stu-id="ebb61-135">We’ll discuss this more when we talk about publish/subscribe.</span></span>

## <a name="show-me-the-code"></a><span data-ttu-id="ebb61-136">Mostra il codice</span><span class="sxs-lookup"><span data-stu-id="ebb61-136">Show me the code</span></span>
<span data-ttu-id="ebb61-137">Nella sezione seguente viene illustrato come utilizzare il Bus di servizio per costruire l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="ebb61-137">The following section shows how to use Service Bus to build this application.</span></span>

### <a name="sign-up-for-an-azure-account"></a><span data-ttu-id="ebb61-138">Iscriversi a un account Azure</span><span class="sxs-lookup"><span data-stu-id="ebb61-138">Sign up for an Azure account</span></span>
<span data-ttu-id="ebb61-139">È necessario un account Azure per iniziare a lavorare con il Bus di servizio.</span><span class="sxs-lookup"><span data-stu-id="ebb61-139">You’ll need an Azure account in order to start working with Service Bus.</span></span> <span data-ttu-id="ebb61-140">Se non si ha già una sottoscrizione, è possibile registrarsi per un account gratuito [qui](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF).</span><span class="sxs-lookup"><span data-stu-id="ebb61-140">If you do not already have one, you can sign up for a free account [here](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF).</span></span>

### <a name="create-a-namespace"></a><span data-ttu-id="ebb61-141">Creare uno spazio dei nomi</span><span class="sxs-lookup"><span data-stu-id="ebb61-141">Create a namespace</span></span>
<span data-ttu-id="ebb61-142">Dopo avere creato una sottoscrizione è possibile [creare uno spazio dei nomi del servizio](service-bus-create-namespace-portal.md).</span><span class="sxs-lookup"><span data-stu-id="ebb61-142">Once you have a subscription, you can [create a service namespace](service-bus-create-namespace-portal.md).</span></span> <span data-ttu-id="ebb61-143">Ogni spazio dei nomi funge da contenitore di ambito per un set di entità del Bus di servizio.</span><span class="sxs-lookup"><span data-stu-id="ebb61-143">Each namespace acts as a scoping container for a set of Service Bus entities.</span></span> <span data-ttu-id="ebb61-144">Assegnare al nuovo spazio dei nomi un nome univoco tra tutti gli account del Bus di servizio.</span><span class="sxs-lookup"><span data-stu-id="ebb61-144">Give your new namespace a unique name across all Service Bus accounts.</span></span> 

### <a name="install-the-nuget-package"></a><span data-ttu-id="ebb61-145">Installare il pacchetto NuGet</span><span class="sxs-lookup"><span data-stu-id="ebb61-145">Install the NuGet package</span></span>
<span data-ttu-id="ebb61-146">Per utilizzare lo spazio dei nomi del Bus di servizio, un'applicazione deve fare riferimento all'assembly del Bus di servizio, in particolare a Microsoft.ServiceBus.dll.</span><span class="sxs-lookup"><span data-stu-id="ebb61-146">To use the Service Bus namespace, an application must reference the Service Bus assembly, specifically Microsoft.ServiceBus.dll.</span></span> <span data-ttu-id="ebb61-147">È possibile trovare questa assembly come parte di Microsoft Azure SDK, e il download è disponibile nella [pagina di download di Azure SDK](https://azure.microsoft.com/downloads/).</span><span class="sxs-lookup"><span data-stu-id="ebb61-147">You can find this assembly as part of the Microsoft Azure SDK, and the download is available at the [Azure SDK download page](https://azure.microsoft.com/downloads/).</span></span> <span data-ttu-id="ebb61-148">Il [pacchetto NuGet del bus di servizio](https://www.nuget.org/packages/WindowsAzure.ServiceBus) è tuttavia il modo più semplice per recuperare l'interfaccia API del bus di servizio e configurare l'applicazione con tutte le dipendenze di tale servizio.</span><span class="sxs-lookup"><span data-stu-id="ebb61-148">However, the [Service Bus NuGet package](https://www.nuget.org/packages/WindowsAzure.ServiceBus) is the easiest way to get the Service Bus API and to configure your application with all of the Service Bus dependencies.</span></span>

### <a name="create-the-queue"></a><span data-ttu-id="ebb61-149">Creare la coda</span><span class="sxs-lookup"><span data-stu-id="ebb61-149">Create the queue</span></span>
<span data-ttu-id="ebb61-150">Le operazioni di gestione per entità di messaggistica (code e argomenti di pubblicazione/sottoscrizione) del bus di servizio vengono eseguite tramite la classe [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager).</span><span class="sxs-lookup"><span data-stu-id="ebb61-150">Management operations for Service Bus messaging entities (queues and publish/subscribe topics) are performed via the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class.</span></span> <span data-ttu-id="ebb61-151">Il bus di servizio usa un modello di sicurezza basato su [SAS (Shared Access Signature, Firma di accesso condiviso)](service-bus-sas.md).</span><span class="sxs-lookup"><span data-stu-id="ebb61-151">Service Bus uses a [Shared Access Signature (SAS)](service-bus-sas.md) based security model.</span></span> <span data-ttu-id="ebb61-152">La classe [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) rappresenta un provider di token di sicurezza con metodi factory incorporati che restituiscono alcuni provider di token noti.</span><span class="sxs-lookup"><span data-stu-id="ebb61-152">The [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) class represents a security token provider with built-in factory methods returning some well-known token providers.</span></span> <span data-ttu-id="ebb61-153">Per memorizzare le credenziali SAS, verrà usato un metodo [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_).</span><span class="sxs-lookup"><span data-stu-id="ebb61-153">We’ll use a [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) method to hold the SAS credentials.</span></span> <span data-ttu-id="ebb61-154">L'istanza [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) viene costruita con l'indirizzo di base dello spazio dei nomi del bus di servizio e con il provider di token.</span><span class="sxs-lookup"><span data-stu-id="ebb61-154">The [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is then constructed with the base address of the Service Bus namespace and the token provider.</span></span>

<span data-ttu-id="ebb61-155">La classe [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) offre i metodi per creare, enumerare ed eliminare entità di messaggistica.</span><span class="sxs-lookup"><span data-stu-id="ebb61-155">The [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class provides methods to create, enumerate and delete messaging entities.</span></span> <span data-ttu-id="ebb61-156">Il codice riportato di seguito illustra come l'istanza [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) viene creata e usata per creare la coda **DataCollectionQueue**.</span><span class="sxs-lookup"><span data-stu-id="ebb61-156">The code that is shown here shows how the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is created and used to create the **DataCollectionQueue** queue.</span></span>

```csharp
Uri uri = ServiceBusEnvironment.CreateServiceUri("sb", 
                "test-blog", string.Empty);
string name = "RootManageSharedAccessKey";
string key = "abcdefghijklmopqrstuvwxyz";

TokenProvider tokenProvider = 
    TokenProvider.CreateSharedAccessSignatureTokenProvider(name, key);
NamespaceManager namespaceManager = 
    new NamespaceManager(uri, tokenProvider);
namespaceManager.CreateQueue("DataCollectionQueue");
```

<span data-ttu-id="ebb61-157">Si noti che esistono overload del metodo [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) che abilitano le proprietà della coda da ottimizzare.</span><span class="sxs-lookup"><span data-stu-id="ebb61-157">Note that there are overloads of the [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) method that enable properties of the queue to be tuned.</span></span> <span data-ttu-id="ebb61-158">Ad esempio, è possibile impostare il valore di durata (TTL) predefinito per i messaggi inviati alla coda.</span><span class="sxs-lookup"><span data-stu-id="ebb61-158">For example, you can set the default time-to-live (TTL) value for messages sent to the queue.</span></span>

### <a name="send-messages-to-the-queue"></a><span data-ttu-id="ebb61-159">Inviare messaggi alla coda</span><span class="sxs-lookup"><span data-stu-id="ebb61-159">Send messages to the queue</span></span>
<span data-ttu-id="ebb61-160">Per le operazioni di runtime su entità del bus di servizio, ad esempio l'invio e la ricezione di messaggi, un'applicazione deve prima creare un oggetto [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory).</span><span class="sxs-lookup"><span data-stu-id="ebb61-160">For run-time operations on Service Bus entities; for example, sending and receiving messages, an application must first create a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) object.</span></span> <span data-ttu-id="ebb61-161">Simile alla classe [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager), l'istanza [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) viene creata a partire dall'indirizzo di base dello spazio dei nomi del servizio e dal provider di token.</span><span class="sxs-lookup"><span data-stu-id="ebb61-161">Similar to the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class, the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance is created from the base address of the service namespace and the token provider.</span></span>

```csharp
 BrokeredMessage bm = new BrokeredMessage(salesData);
 bm.Label = "SalesReport";
 bm.Properties["StoreName"] = "Redmond";
 bm.Properties["MachineID"] = "POS_1";
```

<span data-ttu-id="ebb61-162">I messaggi inviati e ricevuti dalla coda del bus di servizio sono istanze della classe [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) .</span><span class="sxs-lookup"><span data-stu-id="ebb61-162">Messages sent to, and received from Service Bus queues are instances of the [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) class.</span></span> <span data-ttu-id="ebb61-163">Questa classe consiste di un insieme di proprietà standard, (ad esempio, [Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) e [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), di un dizionario usato per mantenere le proprietà dell'applicazione e di un corpo di dati arbitrari dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="ebb61-163">This class consists of a set of standard properties (such as [Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) and [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), a dictionary that is used to hold application properties, and a body of arbitrary application data.</span></span> <span data-ttu-id="ebb61-164">Un'applicazione può impostare il corpo passando qualsiasi oggetto serializzabile (nell'esempio seguente passa un oggetto **SalesData** che rappresenta i dati di vendita dal terminale POS), che userà [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) per serializzare l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="ebb61-164">An application can set the body by passing in any serializable object (the following example passes in a **SalesData** object that represents the sales data from the POS terminal), which will use the [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) to serialize the object.</span></span> <span data-ttu-id="ebb61-165">In alternativa, può essere specificato un oggetto [Flusso](https://msdn.microsoft.com/library/system.io.stream.aspx).</span><span class="sxs-lookup"><span data-stu-id="ebb61-165">Alternatively, a [Stream](https://msdn.microsoft.com/library/system.io.stream.aspx) object can be provided.</span></span>

<span data-ttu-id="ebb61-166">Il modo più semplice per inviare messaggi a una determinata coda, in questo caso la coda **DataCollectionQueue**, consiste nell'usare [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) per creare un oggetto [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) direttamente dall'istanza [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory).</span><span class="sxs-lookup"><span data-stu-id="ebb61-166">The easiest way to send messages to a given queue, in our case the **DataCollectionQueue**, is to use [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) to create a [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) object directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance.</span></span>

```csharp
MessageSender sender = factory.CreateMessageSender("DataCollectionQueue");
sender.Send(bm);
```

### <a name="receiving-messages-from-the-queue"></a><span data-ttu-id="ebb61-167">Ricezione di messaggi dalla coda</span><span class="sxs-lookup"><span data-stu-id="ebb61-167">Receiving messages from the queue</span></span>
<span data-ttu-id="ebb61-168">Per ricevere messaggi dalla coda è possibile usare un oggetto [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) che può essere creato direttamente da [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) tramite [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span><span class="sxs-lookup"><span data-stu-id="ebb61-168">To receive messages from the queue, you can use a [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) object which you create directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) using [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span></span> <span data-ttu-id="ebb61-169">I ricevitori dei messaggi possono lavorare in due modalità diverse: **ReceiveAndDelete** e **PeekLock**.</span><span class="sxs-lookup"><span data-stu-id="ebb61-169">Message receivers can work in two different modes: **ReceiveAndDelete** and **PeekLock**.</span></span> <span data-ttu-id="ebb61-170">La modalità [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) viene impostata quando si crea il ricevitore del messaggio, come parametro per la chiamata [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_).</span><span class="sxs-lookup"><span data-stu-id="ebb61-170">The [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) is set when the message receiver is created, as a parameter to the [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_) call.</span></span>

<span data-ttu-id="ebb61-171">Quando si usa la modalità **ReceiveAndDelete**, l'operazione di ricezione viene eseguita in un'unica fase, ovvero quando il bus di servizio riceve la richiesta, contrassegna il messaggio come letto e lo restituisce all'applicazione.</span><span class="sxs-lookup"><span data-stu-id="ebb61-171">When using the **ReceiveAndDelete** mode, the receive is a single-shot operation; that is, when Service Bus receives the request, it marks the message as being consumed and returns it to the application.</span></span> <span data-ttu-id="ebb61-172">La modalità **ReceiveAndDelete** rappresenta il modello più semplice ed è adatta a scenari in cui un'applicazione può tollerare la mancata elaborazione di un messaggio in caso di errore.</span><span class="sxs-lookup"><span data-stu-id="ebb61-172">**ReceiveAndDelete** mode is the simplest model and works best for scenarios in which the application can tolerate not processing a message if a failure were to occur.</span></span> <span data-ttu-id="ebb61-173">Per comprendere meglio questo meccanismo, si consideri uno scenario in cui il consumer invia la richiesta di ricezione e viene arrestato in modo anomalo prima dell'elaborazione.</span><span class="sxs-lookup"><span data-stu-id="ebb61-173">To understand this, consider a scenario in which the consumer issues the receive request and then crashes before processing it.</span></span> <span data-ttu-id="ebb61-174">Poiché il bus di servizio contrassegna il messaggio come consumato, quando l'applicazione viene riavviata e inizia a consumare nuovamente i messaggi, il messaggio consumato prima dell'arresto anomalo risulterà perso.</span><span class="sxs-lookup"><span data-stu-id="ebb61-174">Since Service Bus marked the message as being consumed, when the application restarts and starts consuming messages again, it will have missed the message that was consumed before the crash.</span></span>

<span data-ttu-id="ebb61-175">Nella modalità **PeekLock** l'operazione di ricezione viene suddivisa in due fasi, in modo da consentire il supporto di applicazioni che non possono tollerare messaggi mancanti.</span><span class="sxs-lookup"><span data-stu-id="ebb61-175">In **PeekLock** mode, the receive becomes a two-stage operation, which makes it possible to support applications that cannot tolerate missing messages.</span></span> <span data-ttu-id="ebb61-176">Quando il bus di servizio riceve la richiesta, individua il messaggio successivo da usare, lo blocca per impedirne la ricezione da parte di altri consumer e quindi lo restituisce all'applicazione.</span><span class="sxs-lookup"><span data-stu-id="ebb61-176">When Service Bus receives the request, it finds the next message to be consumed, locks it to prevent other consumers receiving it, and then returns it to the application.</span></span> <span data-ttu-id="ebb61-177">Dopo aver elaborato il messaggio o averlo archiviato in modo affidabile per successive elaborazioni, l'applicazione esegue la seconda fase del processo di ricezione chiamando [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) sul messaggio ricevuto.</span><span class="sxs-lookup"><span data-stu-id="ebb61-177">After the application finishes processing the message (or stores it reliably for future processing), it completes the second stage of the receive process by calling [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) on the received message.</span></span> <span data-ttu-id="ebb61-178">Quando il bus di servizio vede la chiamata [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete), contrassegna il messaggio come letto.</span><span class="sxs-lookup"><span data-stu-id="ebb61-178">When Service Bus sees the [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) call, it marks the message as being consumed.</span></span>

<span data-ttu-id="ebb61-179">Sono possibili altri due risultati.</span><span class="sxs-lookup"><span data-stu-id="ebb61-179">Two other outcomes are possible.</span></span> <span data-ttu-id="ebb61-180">In primo luogo, se per qualche motivo l'applicazione non riesce a elaborare il messaggio, può chiamare il metodo [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) sul messaggio ricevuto, (invece del metodo [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span><span class="sxs-lookup"><span data-stu-id="ebb61-180">First, if the application is unable to process the message for some reason, it can call [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) on the received message (instead of [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span></span> <span data-ttu-id="ebb61-181">In questo modo, il bus di servizio sbloccherà il messaggio che sarà disponibile per essere nuovamente ricevuto dallo stesso consumer o da un altro consumer concorrente.</span><span class="sxs-lookup"><span data-stu-id="ebb61-181">This causes Service Bus to unlock the message and make it available to be received again, either by the same consumer or by another completing consumer.</span></span> <span data-ttu-id="ebb61-182">In secondo luogo, al blocco è associato un timeout e se l'applicazione non riesce a elaborare il messaggio prima della scadenza del timeout (ad esempio a causa di un arresto anomalo), il bus di servizio sbloccherà il messaggio rendendolo nuovamente disponibile per la ricezione (eseguendo essenzialmente un'operazione [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) per impostazione predefinita).</span><span class="sxs-lookup"><span data-stu-id="ebb61-182">Second, there is a time-out associated with the lock and if the application cannot process the message before the lock time-out expires (for example, if the application crashes), then Service Bus will unlock the message and make it available to be received again (essentially performing an [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) operation by default).</span></span>

<span data-ttu-id="ebb61-183">Si noti che in caso di arresto anomalo dell'applicazione dopo l'elaborazione del messaggio, ma prima dell'invio della richiesta [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete), il messaggio verrà recapitato di nuovo all'applicazione al prossimo riavvio dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="ebb61-183">Note that if the application crashes after it processes the message but before the [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) request was issued, the message will be redelivered to the application when it restarts.</span></span> <span data-ttu-id="ebb61-184">Questo è spesso definito * almeno una volta * l'elaborazione.</span><span class="sxs-lookup"><span data-stu-id="ebb61-184">This is often termed *At Least Once * processing.</span></span> <span data-ttu-id="ebb61-185">Indica che ogni messaggio verrà elaborato almeno una volta, ma che in determinate situazioni potrà essere recapitato una seconda volta.</span><span class="sxs-lookup"><span data-stu-id="ebb61-185">This means that each message will be processed at least once but in certain situations the same message may be redelivered.</span></span> <span data-ttu-id="ebb61-186">Se lo scenario non tollera la doppia elaborazione, allora è necessaria una logica aggiuntiva nell'applicazione per rilevare i duplicati.</span><span class="sxs-lookup"><span data-stu-id="ebb61-186">If the scenario cannot tolerate duplicate processing, then additional logic is required in the application to detect duplicates.</span></span> <span data-ttu-id="ebb61-187">Ciò può essere realizzato con la proprietà [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) del messaggio.</span><span class="sxs-lookup"><span data-stu-id="ebb61-187">This can be achieved based on the [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) property of the message.</span></span> <span data-ttu-id="ebb61-188">Il valore di questa proprietà rimane costante in tutti i tentativi di recapito.</span><span class="sxs-lookup"><span data-stu-id="ebb61-188">The value of this property remains constant across delivery attempts.</span></span> <span data-ttu-id="ebb61-189">In questo caso si parla di elaborazione *Una sola volta*.</span><span class="sxs-lookup"><span data-stu-id="ebb61-189">This is termed *Exactly Once* processing.</span></span>

<span data-ttu-id="ebb61-190">Il codice riportato di seguito riceve ed elabora un messaggio usando la modalità **PeekLock**, ovvero l'impostazione predefinita se non viene esplicitamente definito un valore per [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode).</span><span class="sxs-lookup"><span data-stu-id="ebb61-190">The code that is shown here receives and processes a message using the **PeekLock** mode, which is the default if no [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) value is explicitly provided.</span></span>

```csharp
MessageReceiver receiver = factory.CreateMessageReceiver("DataCollectionQueue");
BrokeredMessage receivedMessage = receiver.Receive();
try
{
    ProcessMessage(receivedMessage);
    receivedMessage.Complete();
}
catch (Exception e)
{
    receivedMessage.Abandon();
}
```

### <a name="use-the-queue-client"></a><span data-ttu-id="ebb61-191">Utilizzare il client di coda</span><span class="sxs-lookup"><span data-stu-id="ebb61-191">Use the queue client</span></span>
<span data-ttu-id="ebb61-192">Negli esempi precedenti in questa sezione sono stati creati gli oggetti [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) e [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) direttamente dal [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) per inviare e ricevere rispettivamente messaggi dalla coda.</span><span class="sxs-lookup"><span data-stu-id="ebb61-192">The examples earlier in this section created [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) and [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) objects directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) to send and receive messages from the queue, respectively.</span></span> <span data-ttu-id="ebb61-193">Un approccio alternativo consiste nell'usare l'oggetto [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) che supporta operazioni di invio e ricezione, oltre a funzionalità più avanzate, ad esempio le sessioni.</span><span class="sxs-lookup"><span data-stu-id="ebb61-193">An alternative approach is to use a [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) object, which supports both send and receive operations in addition to more advanced features, such as sessions.</span></span>

```csharp
QueueClient queueClient = factory.CreateQueueClient("DataCollectionQueue");
queueClient.Send(bm);

BrokeredMessage message = queueClient.Receive();

try
{
    ProcessMessage(message);
    message.Complete();
}
catch (Exception e)
{
    message.Abandon();
} 
```

## <a name="next-steps"></a><span data-ttu-id="ebb61-194">Passaggi successivi</span><span class="sxs-lookup"><span data-stu-id="ebb61-194">Next steps</span></span>
<span data-ttu-id="ebb61-195">Dopo avere appreso le nozioni di base sulle code, vedere [Creare applicazioni che usano argomenti e sottoscrizioni del bus di servizio](service-bus-create-topics-subscriptions.md) per continuare questa discussione sulle funzionalità di pubblicazione/sottoscrizione degli argomenti e delle sottoscrizioni del bus di servizio.</span><span class="sxs-lookup"><span data-stu-id="ebb61-195">Now that you've learned the basics of queues, see [Create applications that use Service Bus topics and subscriptions](service-bus-create-topics-subscriptions.md) to continue this discussion using the publish/subscribe capabilities of Service Bus topics and subscriptions.</span></span>

