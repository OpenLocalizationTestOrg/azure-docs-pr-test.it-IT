---
title: "Elenco di controllo di prestazioni e scalabilità per Archiviazione di Azure | Microsoft Docs"
description: Un elenco di controllo delle procedure consolidate per l'utilizzo dell'archiviazione di Azure nello sviluppo di applicazioni ad elevate prestazioni.
services: storage
documentationcenter: 
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 959d831b-a4fd-4634-a646-0d2c0c462ef8
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 12/08/2016
ms.author: robinsh
ms.openlocfilehash: d2683bf9a2833485467bf2b4edff527876102f7d
ms.sourcegitcommit: 18ad9bc049589c8e44ed277f8f43dcaa483f3339
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/29/2017
---
# <a name="microsoft-azure-storage-performance-and-scalability-checklist"></a><span data-ttu-id="944fe-103">Elenco di controllo di prestazioni e scalabilità per Archiviazione di Microsoft Azure</span><span class="sxs-lookup"><span data-stu-id="944fe-103">Microsoft Azure Storage Performance and Scalability Checklist</span></span>
## <a name="overview"></a><span data-ttu-id="944fe-104">Panoramica</span><span class="sxs-lookup"><span data-stu-id="944fe-104">Overview</span></span>
<span data-ttu-id="944fe-105">Dal rilascio dei servizi di archiviazione di Microsoft Azure, Microsoft ha sviluppato diverse procedure comprovate per usare questi servizi in modo ottimale. In questo articolo vengono riepilogate le procedure più importanti, presentate sotto forma di elenco di controllo.</span><span class="sxs-lookup"><span data-stu-id="944fe-105">Since the release of the Microsoft Azure Storage services, Microsoft has developed a number of proven practices for using these services in a performant manner, and this article serves to consolidate the most important of them into a checklist-style list.</span></span> <span data-ttu-id="944fe-106">L'intento dell'articolo è di consentire agli sviluppatori di applicazioni di assicurarsi di stare usando le procedure comprovate con l'archiviazione di Azure e di aiutarli a individuare altre eventuali procedure da adottare.</span><span class="sxs-lookup"><span data-stu-id="944fe-106">The intention of this article is to help application developers verify they are using proven practices with Azure Storage and to help them identify other proven practices they should consider adopting.</span></span> <span data-ttu-id="944fe-107">Questo articolo non intende coprire tutti i possibili casi di ottimizzazione delle prestazioni e della scalabilità, pertanto esclude quelli che hanno effetti trascurabili o che non sono applicabili a un significativo numero di scenari.</span><span class="sxs-lookup"><span data-stu-id="944fe-107">This article does not attempt to cover every possible performance and scalability optimization — it excludes those that are small in their impact or not broadly applicable.</span></span> <span data-ttu-id="944fe-108">Nella misura in cui è possibile prevedere il comportamento dell'applicazione durante la progettazione, è opportuno effettuare una valutazione preliminare di questi aspetti per evitare progettazioni che potrebbero causare problemi in termini di prestazioni.</span><span class="sxs-lookup"><span data-stu-id="944fe-108">To the extent that the application's behavior can be predicted during design, it's useful to keep these in mind early on to avoid designs that will run into performance problems.</span></span>  

<span data-ttu-id="944fe-109">Ogni sviluppatore di applicazioni che usa l'archiviazione di Azure dovrebbe leggere attentamente questo articolo e verificare che l'applicazione su cui sta lavorando segua tutte le procedure comprovate elencate di seguito.</span><span class="sxs-lookup"><span data-stu-id="944fe-109">Every application developer using Azure Storage should take the time to read this article, and check that his or her application follows each of the proven practices listed below.</span></span>  

## <a name="checklist"></a><span data-ttu-id="944fe-110">Elenco di controllo</span><span class="sxs-lookup"><span data-stu-id="944fe-110">Checklist</span></span>
<span data-ttu-id="944fe-111">Questo articolo organizza le procedure comprovate nei seguenti gruppi.</span><span class="sxs-lookup"><span data-stu-id="944fe-111">This article organizes the proven practices into the following groups.</span></span> <span data-ttu-id="944fe-112">Procedure comprovate applicabili a:</span><span class="sxs-lookup"><span data-stu-id="944fe-112">Proven practices applicable to:</span></span>  

* <span data-ttu-id="944fe-113">Tutti i servizi di archiviazione di Azure (BLOB, tabelle, code e file)</span><span class="sxs-lookup"><span data-stu-id="944fe-113">All Azure Storage services (blobs, tables, queues, and files)</span></span>
* <span data-ttu-id="944fe-114">Blobs</span><span class="sxs-lookup"><span data-stu-id="944fe-114">Blobs</span></span>
* <span data-ttu-id="944fe-115">Tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-115">Tables</span></span>
* <span data-ttu-id="944fe-116">Queues</span><span class="sxs-lookup"><span data-stu-id="944fe-116">Queues</span></span>  

| <span data-ttu-id="944fe-117">Operazione completata</span><span class="sxs-lookup"><span data-stu-id="944fe-117">Done</span></span> | <span data-ttu-id="944fe-118">Area</span><span class="sxs-lookup"><span data-stu-id="944fe-118">Area</span></span> | <span data-ttu-id="944fe-119">Categoria</span><span class="sxs-lookup"><span data-stu-id="944fe-119">Category</span></span> | <span data-ttu-id="944fe-120">Domanda</span><span class="sxs-lookup"><span data-stu-id="944fe-120">Question</span></span> |
| --- | --- | --- | --- |
| &nbsp; | <span data-ttu-id="944fe-121">Tutti i servizi</span><span class="sxs-lookup"><span data-stu-id="944fe-121">All Services</span></span> |<span data-ttu-id="944fe-122">Obiettivi di scalabilità</span><span class="sxs-lookup"><span data-stu-id="944fe-122">Scalability Targets</span></span> |[<span data-ttu-id="944fe-123">L'applicazione è progettata per evitare di raggiungere gli obiettivi di scalabilità?</span><span class="sxs-lookup"><span data-stu-id="944fe-123">Is your application designed to avoid approaching the scalability targets?</span></span>](#subheading1) |
| &nbsp; | <span data-ttu-id="944fe-124">Tutti i servizi</span><span class="sxs-lookup"><span data-stu-id="944fe-124">All Services</span></span> |<span data-ttu-id="944fe-125">Obiettivi di scalabilità</span><span class="sxs-lookup"><span data-stu-id="944fe-125">Scalability Targets</span></span> |[<span data-ttu-id="944fe-126">La convenzione di denominazione è stata progettata per consentire un miglior bilanciamento del carico?</span><span class="sxs-lookup"><span data-stu-id="944fe-126">Is your naming convention designed to enable better load-balancing?</span></span>](#subheading47) |
| &nbsp; | <span data-ttu-id="944fe-127">Tutti i servizi</span><span class="sxs-lookup"><span data-stu-id="944fe-127">All Services</span></span> |<span data-ttu-id="944fe-128">Rete</span><span class="sxs-lookup"><span data-stu-id="944fe-128">Networking</span></span> |[<span data-ttu-id="944fe-129">I dispositivi sul lato client hanno una larghezza di banda sufficientemente alta e una latenza sufficientemente bassa per raggiungere le prestazioni richieste?</span><span class="sxs-lookup"><span data-stu-id="944fe-129">Do client side devices have sufficiently high bandwidth and low latency to achieve the performance needed?</span></span>](#subheading2) |
| &nbsp; | <span data-ttu-id="944fe-130">Tutti i servizi</span><span class="sxs-lookup"><span data-stu-id="944fe-130">All Services</span></span> |<span data-ttu-id="944fe-131">Rete</span><span class="sxs-lookup"><span data-stu-id="944fe-131">Networking</span></span> |[<span data-ttu-id="944fe-132">I dispositivi sul lato client hanno un collegamento di qualità adeguata?</span><span class="sxs-lookup"><span data-stu-id="944fe-132">Do client side devices have a high enough quality link?</span></span>](#subheading3) |
| &nbsp; | <span data-ttu-id="944fe-133">Tutti i servizi</span><span class="sxs-lookup"><span data-stu-id="944fe-133">All Services</span></span> |<span data-ttu-id="944fe-134">Rete</span><span class="sxs-lookup"><span data-stu-id="944fe-134">Networking</span></span> |[<span data-ttu-id="944fe-135">L'applicazione client è "accanto" all'account di archiviazione?</span><span class="sxs-lookup"><span data-stu-id="944fe-135">Is the client application located "near" the storage account?</span></span>](#subheading4) |
| &nbsp; | <span data-ttu-id="944fe-136">Tutti i servizi</span><span class="sxs-lookup"><span data-stu-id="944fe-136">All Services</span></span> |<span data-ttu-id="944fe-137">Distribuzione del contenuto</span><span class="sxs-lookup"><span data-stu-id="944fe-137">Content Distribution</span></span> |[<span data-ttu-id="944fe-138">Viene usata una rete CDN per la distribuzione del contenuto?</span><span class="sxs-lookup"><span data-stu-id="944fe-138">Are you using a CDN for content distribution?</span></span>](#subheading5) |
| &nbsp; | <span data-ttu-id="944fe-139">Tutti i servizi</span><span class="sxs-lookup"><span data-stu-id="944fe-139">All Services</span></span> |<span data-ttu-id="944fe-140">Accesso client diretto</span><span class="sxs-lookup"><span data-stu-id="944fe-140">Direct Client Access</span></span> |[<span data-ttu-id="944fe-141">Si stanno usando le firme di accesso condiviso (SAS) e la condivisione risorse tra le origini (CORS) al posto del proxy per consentire l'accesso diretto all'archiviazione?</span><span class="sxs-lookup"><span data-stu-id="944fe-141">Are you using SAS and CORS to allow direct access to storage instead of proxy?</span></span>](#subheading6) |
| &nbsp; | <span data-ttu-id="944fe-142">Tutti i servizi</span><span class="sxs-lookup"><span data-stu-id="944fe-142">All Services</span></span> |<span data-ttu-id="944fe-143">Memorizzazione nella cache</span><span class="sxs-lookup"><span data-stu-id="944fe-143">Caching</span></span> |[<span data-ttu-id="944fe-144">L'applicazione sta memorizzando nella cache i dati usati di frequente e modificati raramente?</span><span class="sxs-lookup"><span data-stu-id="944fe-144">Is your application caching data that is repeatedly used and changes rarely?</span></span>](#subheading7) |
| &nbsp; | <span data-ttu-id="944fe-145">Tutti i servizi</span><span class="sxs-lookup"><span data-stu-id="944fe-145">All Services</span></span> |<span data-ttu-id="944fe-146">Memorizzazione nella cache</span><span class="sxs-lookup"><span data-stu-id="944fe-146">Caching</span></span> |[<span data-ttu-id="944fe-147">L'applicazione sta creando batch di aggiornamenti (memorizzandoli nella cache sul lato client e caricandoli in set più grandi)?</span><span class="sxs-lookup"><span data-stu-id="944fe-147">Is your application batching updates (caching them client side and then uploading in larger sets)?</span></span>](#subheading8) |
| &nbsp; | <span data-ttu-id="944fe-148">Tutti i servizi</span><span class="sxs-lookup"><span data-stu-id="944fe-148">All Services</span></span> |<span data-ttu-id="944fe-149">Configurazione .NET</span><span class="sxs-lookup"><span data-stu-id="944fe-149">.NET Configuration</span></span> |[<span data-ttu-id="944fe-150">Il client è stato configurato per usare un numero sufficiente di connessioni simultanee?</span><span class="sxs-lookup"><span data-stu-id="944fe-150">Have you configured your client to use a sufficient number of concurrent connections?</span></span>](#subheading9) |
| &nbsp; | <span data-ttu-id="944fe-151">Tutti i servizi</span><span class="sxs-lookup"><span data-stu-id="944fe-151">All Services</span></span> |<span data-ttu-id="944fe-152">Configurazione .NET</span><span class="sxs-lookup"><span data-stu-id="944fe-152">.NET Configuration</span></span> |[<span data-ttu-id="944fe-153">.NET è stato configurato per usare un numero sufficiente di thread?</span><span class="sxs-lookup"><span data-stu-id="944fe-153">Have you configured .NET to use a sufficient number of threads?</span></span>](#subheading10) |
| &nbsp; | <span data-ttu-id="944fe-154">Tutti i servizi</span><span class="sxs-lookup"><span data-stu-id="944fe-154">All Services</span></span> |<span data-ttu-id="944fe-155">Configurazione .NET</span><span class="sxs-lookup"><span data-stu-id="944fe-155">.NET Configuration</span></span> |[<span data-ttu-id="944fe-156">Si sta usando .NET 4.5 o versione successiva, che dispone di una funzionalità migliorata di Garbage Collection?</span><span class="sxs-lookup"><span data-stu-id="944fe-156">Are you using .NET 4.5 or later, which has improved garbage collection?</span></span>](#subheading11) |
| &nbsp; | <span data-ttu-id="944fe-157">Tutti i servizi</span><span class="sxs-lookup"><span data-stu-id="944fe-157">All Services</span></span> |<span data-ttu-id="944fe-158">Parallelismo</span><span class="sxs-lookup"><span data-stu-id="944fe-158">Parallelism</span></span> |[<span data-ttu-id="944fe-159">È stata verificata la corretta associazione del parallelismo in modo da non sovraccaricare le capacità del client o gli obiettivi di scalabilità?</span><span class="sxs-lookup"><span data-stu-id="944fe-159">Have you ensured that parallelism is bounded appropriately so that you don't overload either your client capabilities or the scalability targets?</span></span>](#subheading12) |
| &nbsp; | <span data-ttu-id="944fe-160">Tutti i servizi</span><span class="sxs-lookup"><span data-stu-id="944fe-160">All Services</span></span> |<span data-ttu-id="944fe-161">Strumenti</span><span class="sxs-lookup"><span data-stu-id="944fe-161">Tools</span></span> |[<span data-ttu-id="944fe-162">Si sta usando l'ultima versione delle librerie e degli strumenti client forniti da Microsoft?</span><span class="sxs-lookup"><span data-stu-id="944fe-162">Are you using the latest version of Microsoft provided client libraries and tools?</span></span>](#subheading13) |
| &nbsp; | <span data-ttu-id="944fe-163">Tutti i servizi</span><span class="sxs-lookup"><span data-stu-id="944fe-163">All Services</span></span> |<span data-ttu-id="944fe-164">Tentativi</span><span class="sxs-lookup"><span data-stu-id="944fe-164">Retries</span></span> |[<span data-ttu-id="944fe-165">Si sta usando un criterio per l'esecuzione di nuovi tentativi per il backoff esponenziale per gli errori di limitazione e i timeout?</span><span class="sxs-lookup"><span data-stu-id="944fe-165">Are you using an exponential backoff retry policy for throttling errors and timeouts?</span></span>](#subheading14) |
| &nbsp; | <span data-ttu-id="944fe-166">Tutti i servizi</span><span class="sxs-lookup"><span data-stu-id="944fe-166">All Services</span></span> |<span data-ttu-id="944fe-167">Tentativi</span><span class="sxs-lookup"><span data-stu-id="944fe-167">Retries</span></span> |[<span data-ttu-id="944fe-168">L'applicazione sta evitando nuovi tentativi in caso di errori irreversibili?</span><span class="sxs-lookup"><span data-stu-id="944fe-168">Is your application avoiding retries for non-retryable errors?</span></span>](#subheading15) |
| &nbsp; | <span data-ttu-id="944fe-169">Blobs</span><span class="sxs-lookup"><span data-stu-id="944fe-169">Blobs</span></span> |<span data-ttu-id="944fe-170">Obiettivi di scalabilità</span><span class="sxs-lookup"><span data-stu-id="944fe-170">Scalability Targets</span></span> |[<span data-ttu-id="944fe-171">È presente un numero elevato di client che accedono contemporaneamente a un singolo oggetto?</span><span class="sxs-lookup"><span data-stu-id="944fe-171">Do you have a large number of clients accessing a single object concurrently?</span></span>](#subheading46) |
| &nbsp; | <span data-ttu-id="944fe-172">Blobs</span><span class="sxs-lookup"><span data-stu-id="944fe-172">Blobs</span></span> |<span data-ttu-id="944fe-173">Obiettivi di scalabilità</span><span class="sxs-lookup"><span data-stu-id="944fe-173">Scalability Targets</span></span> |[<span data-ttu-id="944fe-174">L'applicazione sta restando all'interno della larghezza di banda o dell'obiettivo di scalabilità delle operazioni per un singolo BLOB?</span><span class="sxs-lookup"><span data-stu-id="944fe-174">Is your application staying within the bandwidth or operations scalability target for a single blob?</span></span>](#subheading16) |
| &nbsp; | <span data-ttu-id="944fe-175">Blobs</span><span class="sxs-lookup"><span data-stu-id="944fe-175">Blobs</span></span> |<span data-ttu-id="944fe-176">Copia dei BLOB</span><span class="sxs-lookup"><span data-stu-id="944fe-176">Copying Blobs</span></span> |[<span data-ttu-id="944fe-177">La copia dei BLOB sta avvenendo in modo efficace?</span><span class="sxs-lookup"><span data-stu-id="944fe-177">Are you copying blobs in an efficient manner?</span></span>](#subheading17) |
| &nbsp; | <span data-ttu-id="944fe-178">Blobs</span><span class="sxs-lookup"><span data-stu-id="944fe-178">Blobs</span></span> |<span data-ttu-id="944fe-179">Copia dei BLOB</span><span class="sxs-lookup"><span data-stu-id="944fe-179">Copying Blobs</span></span> |[<span data-ttu-id="944fe-180">Si sta usando AzCopy per le copie bulk dei BLOB?</span><span class="sxs-lookup"><span data-stu-id="944fe-180">Are you using AzCopy for bulk copies of blobs?</span></span>](#subheading18) |
| &nbsp; | <span data-ttu-id="944fe-181">Blobs</span><span class="sxs-lookup"><span data-stu-id="944fe-181">Blobs</span></span> |<span data-ttu-id="944fe-182">Copia dei BLOB</span><span class="sxs-lookup"><span data-stu-id="944fe-182">Copying Blobs</span></span> |[<span data-ttu-id="944fe-183">Si sta usando Importazione/Esportazione di Azure per trasferire volumi di dati molto grandi?</span><span class="sxs-lookup"><span data-stu-id="944fe-183">Are you using Azure Import/Export to transfer very large volumes of data?</span></span>](#subheading19) |
| &nbsp; | <span data-ttu-id="944fe-184">Blobs</span><span class="sxs-lookup"><span data-stu-id="944fe-184">Blobs</span></span> |<span data-ttu-id="944fe-185">Usare i metadati</span><span class="sxs-lookup"><span data-stu-id="944fe-185">Use Metadata</span></span> |[<span data-ttu-id="944fe-186">Si stanno archiviando i metadati usati di frequente relativi ai BLOB nei rispettivi metadati?</span><span class="sxs-lookup"><span data-stu-id="944fe-186">Are you storing frequently used metadata about blobs in their metadata?</span></span>](#subheading20) |
| &nbsp; | <span data-ttu-id="944fe-187">Blobs</span><span class="sxs-lookup"><span data-stu-id="944fe-187">Blobs</span></span> |<span data-ttu-id="944fe-188">Caricamento rapido</span><span class="sxs-lookup"><span data-stu-id="944fe-188">Uploading Fast</span></span> |[<span data-ttu-id="944fe-189">Quando si tenta di caricare rapidamente un BLOB, i blocchi vengono caricati in parallelo?</span><span class="sxs-lookup"><span data-stu-id="944fe-189">When trying to upload one blob quickly, are you uploading blocks in parallel?</span></span>](#subheading21) |
| &nbsp; | <span data-ttu-id="944fe-190">Blobs</span><span class="sxs-lookup"><span data-stu-id="944fe-190">Blobs</span></span> |<span data-ttu-id="944fe-191">Caricamento rapido</span><span class="sxs-lookup"><span data-stu-id="944fe-191">Uploading Fast</span></span> |[<span data-ttu-id="944fe-192">Quando si tenta di caricare rapidamente più BLOB, i BLOB vengono caricati in parallelo?</span><span class="sxs-lookup"><span data-stu-id="944fe-192">When trying to upload many blobs quickly, are you uploading blobs in parallel?</span></span>](#subheading22) |
| &nbsp; | <span data-ttu-id="944fe-193">Blobs</span><span class="sxs-lookup"><span data-stu-id="944fe-193">Blobs</span></span> |<span data-ttu-id="944fe-194">Tipo di BLOB corretto</span><span class="sxs-lookup"><span data-stu-id="944fe-194">Correct Blob Type</span></span> |[<span data-ttu-id="944fe-195">Si stanno usando BLOB di pagine o in blocchi quando appropriato?</span><span class="sxs-lookup"><span data-stu-id="944fe-195">Are you using page blobs or block blobs when appropriate?</span></span>](#subheading23) |
| &nbsp; | <span data-ttu-id="944fe-196">Tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-196">Tables</span></span> |<span data-ttu-id="944fe-197">Obiettivi di scalabilità</span><span class="sxs-lookup"><span data-stu-id="944fe-197">Scalability Targets</span></span> |[<span data-ttu-id="944fe-198">Si stanno raggiungendo gli obiettivi di scalabilità per le entità al secondo?</span><span class="sxs-lookup"><span data-stu-id="944fe-198">Are you approaching the scalability targets for entities per second?</span></span>](#subheading24) |
| &nbsp; | <span data-ttu-id="944fe-199">Tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-199">Tables</span></span> |<span data-ttu-id="944fe-200">Configurazione</span><span class="sxs-lookup"><span data-stu-id="944fe-200">Configuration</span></span> |[<span data-ttu-id="944fe-201">Si sta usando JSON per le richieste della tabella?</span><span class="sxs-lookup"><span data-stu-id="944fe-201">Are you using JSON for your table requests?</span></span>](#subheading25) |
| &nbsp; | <span data-ttu-id="944fe-202">Tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-202">Tables</span></span> |<span data-ttu-id="944fe-203">Configurazione</span><span class="sxs-lookup"><span data-stu-id="944fe-203">Configuration</span></span> |[<span data-ttu-id="944fe-204">Nagle è stato disattivato per migliorare le prestazioni per le piccole richieste?</span><span class="sxs-lookup"><span data-stu-id="944fe-204">Have you turned Nagle off to improve the performance of small requests?</span></span>](#subheading26) |
| &nbsp; | <span data-ttu-id="944fe-205">Tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-205">Tables</span></span> |<span data-ttu-id="944fe-206">Tabelle e partizioni</span><span class="sxs-lookup"><span data-stu-id="944fe-206">Tables and Partitions</span></span> |[<span data-ttu-id="944fe-207">I dati sono stati partizionati correttamente?</span><span class="sxs-lookup"><span data-stu-id="944fe-207">Have you properly partitioned your data?</span></span>](#subheading27) |
| &nbsp; | <span data-ttu-id="944fe-208">Tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-208">Tables</span></span> |<span data-ttu-id="944fe-209">Partizioni critiche</span><span class="sxs-lookup"><span data-stu-id="944fe-209">Hot Partitions</span></span> |[<span data-ttu-id="944fe-210">Si stanno evitando i modelli Solo accodamenti e Solo anteposizioni?</span><span class="sxs-lookup"><span data-stu-id="944fe-210">Are you avoiding append-only and prepend-only patterns?</span></span>](#subheading28) |
| &nbsp; | <span data-ttu-id="944fe-211">Tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-211">Tables</span></span> |<span data-ttu-id="944fe-212">Partizioni critiche</span><span class="sxs-lookup"><span data-stu-id="944fe-212">Hot Partitions</span></span> |[<span data-ttu-id="944fe-213">Gli inserimenti/aggiornamenti sono distribuiti in più partizioni?</span><span class="sxs-lookup"><span data-stu-id="944fe-213">Are your inserts/updates spread across many partitions?</span></span>](#subheading29) |
| &nbsp; | <span data-ttu-id="944fe-214">Tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-214">Tables</span></span> |<span data-ttu-id="944fe-215">Ambito delle query</span><span class="sxs-lookup"><span data-stu-id="944fe-215">Query Scope</span></span> |[<span data-ttu-id="944fe-216">Lo schema è stato progettato per consentire l'uso delle query di tipo punto nella maggior parte dei casi e delle query sulle tabelle solo in casi limitati?</span><span class="sxs-lookup"><span data-stu-id="944fe-216">Have you designed your schema to allow for point queries to be used in most cases, and table queries to be used sparingly?</span></span>](#subheading30) |
| &nbsp; | <span data-ttu-id="944fe-217">Tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-217">Tables</span></span> |<span data-ttu-id="944fe-218">Densità delle query</span><span class="sxs-lookup"><span data-stu-id="944fe-218">Query Density</span></span> |[<span data-ttu-id="944fe-219">Le query in genere analizzano e restituiscono solo le righe usate dall'applicazione?</span><span class="sxs-lookup"><span data-stu-id="944fe-219">Do your queries typically only scan and return rows that your application will use?</span></span>](#subheading31) |
| &nbsp; | <span data-ttu-id="944fe-220">Tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-220">Tables</span></span> |<span data-ttu-id="944fe-221">Limitazione dei dati restituiti</span><span class="sxs-lookup"><span data-stu-id="944fe-221">Limiting Returned Data</span></span> |[<span data-ttu-id="944fe-222">Vengono usati dei filtri per evitare che vengano restituite entità non necessarie?</span><span class="sxs-lookup"><span data-stu-id="944fe-222">Are you using filtering to avoid returning entities that are not needed?</span></span>](#subheading32) |
| &nbsp; | <span data-ttu-id="944fe-223">Tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-223">Tables</span></span> |<span data-ttu-id="944fe-224">Limitazione dei dati restituiti</span><span class="sxs-lookup"><span data-stu-id="944fe-224">Limiting Returned Data</span></span> |[<span data-ttu-id="944fe-225">Viene usata la proiezione per evitare che vengano restituite proprietà non necessarie?</span><span class="sxs-lookup"><span data-stu-id="944fe-225">Are you using projection to avoid returning properties that are not needed?</span></span>](#subheading33) |
| &nbsp; | <span data-ttu-id="944fe-226">Tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-226">Tables</span></span> |<span data-ttu-id="944fe-227">Denormalizzazione</span><span class="sxs-lookup"><span data-stu-id="944fe-227">Denormalization</span></span> |[<span data-ttu-id="944fe-228">I dati sono stati denormalizzati in modo da evitare query non efficaci o più richieste di lettura quando si tenta di ottenere i dati?</span><span class="sxs-lookup"><span data-stu-id="944fe-228">Have you denormalized your data such that you avoid inefficient queries or multiple read requests when trying to get data?</span></span>](#subheading34) |
| &nbsp; | <span data-ttu-id="944fe-229">Tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-229">Tables</span></span> |<span data-ttu-id="944fe-230">Inserimento/aggiornamento/eliminazione</span><span class="sxs-lookup"><span data-stu-id="944fe-230">Insert/Update/Delete</span></span> |[<span data-ttu-id="944fe-231">Si stanno creando dei batch per le richieste che devono essere transazionali o che possono essere eseguite simultaneamente per ridurre i round-trip?</span><span class="sxs-lookup"><span data-stu-id="944fe-231">Are you batching requests that need to be transactional or can be done at the same time to reduce round-trips?</span></span>](#subheading35) |
| &nbsp; | <span data-ttu-id="944fe-232">Tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-232">Tables</span></span> |<span data-ttu-id="944fe-233">Inserimento/aggiornamento/eliminazione</span><span class="sxs-lookup"><span data-stu-id="944fe-233">Insert/Update/Delete</span></span> |[<span data-ttu-id="944fe-234">Si sta evitando di recuperare un'entità solo per determinare se chiamare un inserimento o un aggiornamento?</span><span class="sxs-lookup"><span data-stu-id="944fe-234">Are you avoiding retrieving an entity just to determine whether to call insert or update?</span></span>](#subheading36) |
| &nbsp; | <span data-ttu-id="944fe-235">Tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-235">Tables</span></span> |<span data-ttu-id="944fe-236">Inserimento/aggiornamento/eliminazione</span><span class="sxs-lookup"><span data-stu-id="944fe-236">Insert/Update/Delete</span></span> |[<span data-ttu-id="944fe-237">È stata considerata l'archiviazione di serie di dati che vengono spesso recuperate insieme in una singola entità sotto forma di proprietà invece che in più entità?</span><span class="sxs-lookup"><span data-stu-id="944fe-237">Have you considered storing series of data that will frequently be retrieved together in a single entity as properties instead of multiple entities?</span></span>](#subheading37) |
| &nbsp; | <span data-ttu-id="944fe-238">Tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-238">Tables</span></span> |<span data-ttu-id="944fe-239">Inserimento/aggiornamento/eliminazione</span><span class="sxs-lookup"><span data-stu-id="944fe-239">Insert/Update/Delete</span></span> |[<span data-ttu-id="944fe-240">Per le entità recuperate sempre insieme e che possono essere scritte in batch (ad esempio, dati di serie temporali) è stato valutato l'uso di BLOB invece che di tabelle?</span><span class="sxs-lookup"><span data-stu-id="944fe-240">For entities that will always be retrieved together and can be written in batches (e.g. time series data), have you considered using blobs instead of tables?</span></span>](#subheading38) |
| &nbsp; | <span data-ttu-id="944fe-241">Queues</span><span class="sxs-lookup"><span data-stu-id="944fe-241">Queues</span></span> |<span data-ttu-id="944fe-242">Obiettivi di scalabilità</span><span class="sxs-lookup"><span data-stu-id="944fe-242">Scalability Targets</span></span> |[<span data-ttu-id="944fe-243">Si stanno raggiungendo gli obiettivi di scalabilità per i messaggi al secondo?</span><span class="sxs-lookup"><span data-stu-id="944fe-243">Are you approaching the scalability targets for messages per second?</span></span>](#subheading39) |
| &nbsp; | <span data-ttu-id="944fe-244">Queues</span><span class="sxs-lookup"><span data-stu-id="944fe-244">Queues</span></span> |<span data-ttu-id="944fe-245">Configurazione</span><span class="sxs-lookup"><span data-stu-id="944fe-245">Configuration</span></span> |[<span data-ttu-id="944fe-246">Nagle è stato disattivato per migliorare le prestazioni per le piccole richieste?</span><span class="sxs-lookup"><span data-stu-id="944fe-246">Have you turned Nagle off to improve the performance of small requests?</span></span>](#subheading40) |
| &nbsp; | <span data-ttu-id="944fe-247">Queues</span><span class="sxs-lookup"><span data-stu-id="944fe-247">Queues</span></span> |<span data-ttu-id="944fe-248">Dimensioni del messaggio</span><span class="sxs-lookup"><span data-stu-id="944fe-248">Message Size</span></span> |[<span data-ttu-id="944fe-249">I messaggi vengono compattati per migliorare le prestazioni della coda?</span><span class="sxs-lookup"><span data-stu-id="944fe-249">Are your messages compact to improve the performance of the queue?</span></span>](#subheading41) |
| &nbsp; | <span data-ttu-id="944fe-250">Queues</span><span class="sxs-lookup"><span data-stu-id="944fe-250">Queues</span></span> |<span data-ttu-id="944fe-251">Recupero bulk</span><span class="sxs-lookup"><span data-stu-id="944fe-251">Bulk Retrieve</span></span> |[<span data-ttu-id="944fe-252">Si stanno recuperando più messaggi con un'unica operazione "Get"?</span><span class="sxs-lookup"><span data-stu-id="944fe-252">Are you retrieving multiple messages in a single "Get" operation?</span></span>](#subheading42) |
| &nbsp; | <span data-ttu-id="944fe-253">Queues</span><span class="sxs-lookup"><span data-stu-id="944fe-253">Queues</span></span> |<span data-ttu-id="944fe-254">Frequenza di polling</span><span class="sxs-lookup"><span data-stu-id="944fe-254">Polling Frequency</span></span> |[<span data-ttu-id="944fe-255">Il polling viene eseguito abbastanza di frequente per ridurre la latenza percepita dell'applicazione?</span><span class="sxs-lookup"><span data-stu-id="944fe-255">Are you polling frequently enough to reduce the perceived latency of your application?</span></span>](#subheading43) |
| &nbsp; | <span data-ttu-id="944fe-256">Queues</span><span class="sxs-lookup"><span data-stu-id="944fe-256">Queues</span></span> |<span data-ttu-id="944fe-257">Aggiornamento del messaggio</span><span class="sxs-lookup"><span data-stu-id="944fe-257">Update Message</span></span> |[<span data-ttu-id="944fe-258">Si sta usando UpdateMessage per archiviare lo stato di elaborazione dei messaggi senza dover rielaborare l'intero messaggio in caso di errori?</span><span class="sxs-lookup"><span data-stu-id="944fe-258">Are you using UpdateMessage to store progress in processing messages, avoiding having to reprocess the entire message if an error occurs?</span></span>](#subheading44) |
| &nbsp; | <span data-ttu-id="944fe-259">Queues</span><span class="sxs-lookup"><span data-stu-id="944fe-259">Queues</span></span> |<span data-ttu-id="944fe-260">Architettura</span><span class="sxs-lookup"><span data-stu-id="944fe-260">Architecture</span></span> |[<span data-ttu-id="944fe-261">Si stanno usando delle code per rendere più scalabile l'intera applicazione tenendo i carichi di lavoro con esecuzione prolungata fuori dal percorso critico e scalandoli indipendentemente?</span><span class="sxs-lookup"><span data-stu-id="944fe-261">Are you using queues to make your entire application more scalable by keeping long-running workloads out of the critical path and scale then independently?</span></span>](#subheading45) |

## <span data-ttu-id="944fe-262"><a name="allservices"></a>Tutti i servizi</span><span class="sxs-lookup"><span data-stu-id="944fe-262"><a name="allservices"></a>All Services</span></span>
<span data-ttu-id="944fe-263">Questa sezione elenca le procedure comprovate applicabili all'uso di tutti i servizi di archiviazione di Azure (BLOB, tabelle, code o file).</span><span class="sxs-lookup"><span data-stu-id="944fe-263">This section lists proven practices that are applicable to the use of any of the Azure Storage services (blobs, tables, queues, or files).</span></span>  

### <span data-ttu-id="944fe-264"><a name="subheading1"></a>Obiettivi di scalabilità</span><span class="sxs-lookup"><span data-stu-id="944fe-264"><a name="subheading1"></a>Scalability Targets</span></span>
<span data-ttu-id="944fe-265">Tutti i servizi di archiviazione di Azure hanno degli obiettivi di scalabilità per la capacità (GB), la frequenza di transazioni e la larghezza di banda.</span><span class="sxs-lookup"><span data-stu-id="944fe-265">Each of the Azure Storage services has scalability targets for capacity (GB), transaction rate, and bandwidth.</span></span> <span data-ttu-id="944fe-266">Se l'applicazione raggiunge o supera uno o più obiettivi di scalabilità, può verificarsi un aumento delle latenze o delle limitazioni della transazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-266">If your application approaches or exceeds any of the scalability targets, it may encounter increased transaction latencies or throttling.</span></span> <span data-ttu-id="944fe-267">Quando un servizio di archiviazione limita l'applicazione, il servizio inizia a restituire i codici di errore "503 Server occupato" o "500 Timeout operazione" per alcune transazioni di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-267">When a Storage service throttles your application, the service begins to return "503 Server busy" or "500 Operation timeout" error codes for some storage transactions.</span></span> <span data-ttu-id="944fe-268">Questa sezione descrive l'approccio generale per la gestione degli obiettivi di scalabilità e, in dettaglio, gli obiettivi di scalabilità della larghezza di banda.</span><span class="sxs-lookup"><span data-stu-id="944fe-268">This section discusses both the general approach to dealing with scalability targets and bandwidth scalability targets in particular.</span></span> <span data-ttu-id="944fe-269">Le sezioni successive, che si occupano dei singoli servizi di archiviazione, trattano gli obiettivi di scalabilità nel contesto del servizio specifico:</span><span class="sxs-lookup"><span data-stu-id="944fe-269">Later sections that deal with individual storage services discuss scalability targets in the context of that specific service:</span></span>  

* [<span data-ttu-id="944fe-270">Larghezza di banda BLOB e richieste al secondo</span><span class="sxs-lookup"><span data-stu-id="944fe-270">Blob bandwidth and requests per second</span></span>](#subheading16)
* [<span data-ttu-id="944fe-271">Entità di tabella al secondo</span><span class="sxs-lookup"><span data-stu-id="944fe-271">Table entities per second</span></span>](#subheading24)
* [<span data-ttu-id="944fe-272">Messaggi della coda al secondo</span><span class="sxs-lookup"><span data-stu-id="944fe-272">Queue messages per second</span></span>](#subheading39)  

#### <span data-ttu-id="944fe-273"><a name="sub1bandwidth"></a>Obiettivo di scalabilità della larghezza di banda per tutti i servizi</span><span class="sxs-lookup"><span data-stu-id="944fe-273"><a name="sub1bandwidth"></a>Bandwidth Scalability Target for All Services</span></span>
<span data-ttu-id="944fe-274">Al momento della redazione di questo documento, gli obiettivi di larghezza di banda negli Stati Uniti per un account di archiviazione con ridondanza geografica (GRS) sono di 10 gigabit al secondo (Gbps) in ingresso (dati inviati all'account di archiviazione) e di 20 Gbps in uscita (dati inviati dall'account di archiviazione).</span><span class="sxs-lookup"><span data-stu-id="944fe-274">At the time of writing, the bandwidth targets in the US for a geo-redundant storage (GRS) account are 10 gigabits per second (Gbps) for ingress (data sent to the storage account) and 20 Gbps for egress (data sent from the storage account).</span></span> <span data-ttu-id="944fe-275">Per un account di archiviazione con ridondanza locale (LRS), i limiti sono più alti: 20 Gbps in ingresso e 30 Gbps in uscita.</span><span class="sxs-lookup"><span data-stu-id="944fe-275">For a locally redundant storage (LRS) account, the limits are higher – 20 Gbps for ingress and 30 Gbps for egress.</span></span>  <span data-ttu-id="944fe-276">I limiti di larghezza di banda internazionali possono essere inferiori e possono essere visualizzati nella [pagina degli obiettivi di scalabilità](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span><span class="sxs-lookup"><span data-stu-id="944fe-276">International bandwidth limits may be lower and can be found on our [scalability targets page](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span></span>  <span data-ttu-id="944fe-277">Per altre informazioni sulle opzioni di ridondanza dell'archiviazione, vedere i collegamenti nella sezione seguente [Risorse utili](#sub1useful) .</span><span class="sxs-lookup"><span data-stu-id="944fe-277">For more information on the storage redundancy options, see the links in [Useful Resources](#sub1useful) below.</span></span>  

#### <a name="what-to-do-when-approaching-a-scalability-target"></a><span data-ttu-id="944fe-278">Cosa fare quando si raggiunge un obiettivo di scalabilità</span><span class="sxs-lookup"><span data-stu-id="944fe-278">What to do when approaching a scalability target</span></span>
<span data-ttu-id="944fe-279">Se l'applicazione sta raggiungendo gli obiettivi di scalabilità per un singolo account di archiviazione, valutare uno dei seguenti approcci:</span><span class="sxs-lookup"><span data-stu-id="944fe-279">If your application is approaching the scalability targets for a single storage account, consider adopting one of the following approaches:</span></span>  

* <span data-ttu-id="944fe-280">Esaminare di nuovo il carico di lavoro che causa il raggiungimento o il superamento dell'obiettivo di scalabilità da parte dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-280">Reconsider the workload that causes your application to approach or exceed the scalability target.</span></span> <span data-ttu-id="944fe-281">È possibile progettarlo in modo diverso in modo che usi una quantità minore di larghezza di banda o capacità o un minor numero di transazioni?</span><span class="sxs-lookup"><span data-stu-id="944fe-281">Can you design it differently to use less bandwidth or capacity, or fewer transactions?</span></span>
* <span data-ttu-id="944fe-282">Se un'applicazione deve superare uno degli obiettivi di scalabilità, è necessario creare più account di archiviazione e partizionare i dati dell'applicazione tra questi account di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-282">If an application must exceed one of the scalability targets, you should create multiple storage accounts and partition your application data across those multiple storage accounts.</span></span> <span data-ttu-id="944fe-283">Se si usa questo modello, assicurarsi di progettare l'applicazione in modo da aggiungere altri account di archiviazione in futuro per il bilanciamento del carico.</span><span class="sxs-lookup"><span data-stu-id="944fe-283">If you use this pattern, then be sure to design your application so that you can add more storage accounts in the future for load balancing.</span></span> <span data-ttu-id="944fe-284">Al momento della redazione di questo documento, ogni sottoscrizione di Azure può supportare fino a 100 account di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-284">At time of writing, each Azure subscription can have up to 100 storage accounts.</span></span>  <span data-ttu-id="944fe-285">Gli account di archiviazione, inoltre, non hanno costi aggiuntivi rispetto a quelli per l'uso, ossia associati ai dati archiviati, alle transazioni effettuate o ai dati trasferiti.</span><span class="sxs-lookup"><span data-stu-id="944fe-285">Storage accounts also have no cost other than your usage in terms of data stored, transactions made, or data transferred.</span></span>
* <span data-ttu-id="944fe-286">Se l'applicazione raggiunge gli obiettivi di larghezza di banda, valutare la compressione dei dati nel client per ridurre la larghezza di banda necessaria a inviare i dati al servizio di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-286">If your application hits the bandwidth targets, consider compressing data in the client to reduce the bandwidth required to send the data to the storage service.</span></span>  <span data-ttu-id="944fe-287">Questa operazione, che consente di risparmiare la larghezza di banda e migliorare le prestazioni di rete, può avere anche degli effettivi negativi.</span><span class="sxs-lookup"><span data-stu-id="944fe-287">Note that while this may save bandwidth and improve network performance, it can also have some negative impacts.</span></span>  <span data-ttu-id="944fe-288">Valutare gli effetti sulle prestazioni dovuti ai requisiti di elaborazione aggiuntivi per la compressione e la decompressione dei dati nel client.</span><span class="sxs-lookup"><span data-stu-id="944fe-288">You should evaluate the performance impact of this due to the additional processing requirements for compressing and decompressing data in the client.</span></span> <span data-ttu-id="944fe-289">Inoltre, l'archiviazione dei dati compressi può rendere più difficile la risoluzione dei problemi perché ostacola la visualizzazione dei dati archiviati mediante gli strumenti standard.</span><span class="sxs-lookup"><span data-stu-id="944fe-289">In addition, storing compressed data can make it more difficult to troubleshoot issues since it could be more difficult to view stored data using standard tools.</span></span>
* <span data-ttu-id="944fe-290">Se l'applicazione raggiunge gli obiettivi di scalabilità, assicurarsi di usare un backoff esponenziale per i nuovi tentativi (vedere [Tentativi](#subheading14)).</span><span class="sxs-lookup"><span data-stu-id="944fe-290">If your application hits the scalability targets, then ensure that you are using an exponential backoff for retries (see [Retries](#subheading14)).</span></span>  <span data-ttu-id="944fe-291">È meglio cercare di non raggiungere mai gli obiettivi di scalabilità (usando uno dei modi descritti), tuttavia ciò impedirà all'applicazione di riprendere a eseguire rapidamente nuovi tentativi, peggiorando così la limitazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-291">It's better to make sure you never approach the scalability targets (by using one of the above methods), but this will ensure your application won't just keep retrying rapidly, making the throttling worse.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="944fe-292">Risorse utili</span><span class="sxs-lookup"><span data-stu-id="944fe-292">Useful Resources</span></span>
<span data-ttu-id="944fe-293">I seguenti collegamenti forniscono ulteriori dettagli sugli obiettivi di scalabilità:</span><span class="sxs-lookup"><span data-stu-id="944fe-293">The following links provide additional detail on scalability targets:</span></span>

* <span data-ttu-id="944fe-294">Per informazioni sugli obiettivi di scalabilità, vedere [Obiettivi di scalabilità e prestazioni per Archiviazione di Azure](storage-scalability-targets.md) .</span><span class="sxs-lookup"><span data-stu-id="944fe-294">See [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md) for information about scalability targets.</span></span>
* <span data-ttu-id="944fe-295">Per informazioni sulle opzioni di ridondanza di archiviazione, vedere [Replica di Archiviazione di Azure](storage-redundancy.md) e il post di blog relativo alle [opzioni di ridondanza di Archiviazione di Azure e archiviazione con ridondanza geografica e accesso in lettura](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx).</span><span class="sxs-lookup"><span data-stu-id="944fe-295">See [Azure Storage replication](storage-redundancy.md) and the blog post [Azure Storage Redundancy Options and Read Access Geo Redundant Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) for information about storage redundancy options.</span></span>
* <span data-ttu-id="944fe-296">Per informazioni aggiornate sui prezzi dei servizi Azure, vedere [Prezzi di Azure](https://azure.microsoft.com/pricing/overview/).</span><span class="sxs-lookup"><span data-stu-id="944fe-296">For current information about pricing for Azure services, see [Azure pricing](https://azure.microsoft.com/pricing/overview/).</span></span>  

### <span data-ttu-id="944fe-297"><a name="subheading47"></a>Convenzione di denominazione delle partizioni</span><span class="sxs-lookup"><span data-stu-id="944fe-297"><a name="subheading47"></a>Partition Naming Convention</span></span>
<span data-ttu-id="944fe-298">Archiviazione di Azure usa uno schema di partizionamento basato sugli intervalli per la scalabilità e il bilanciamento del carico del sistema.</span><span class="sxs-lookup"><span data-stu-id="944fe-298">Azure Storage uses a range-based partitioning scheme to scale and load balance the system.</span></span> <span data-ttu-id="944fe-299">La chiave di partizione è usata per suddividere i dati in intervalli; tali intervalli vengono bilanciati a livello di carico nell'intero sistema.</span><span class="sxs-lookup"><span data-stu-id="944fe-299">The partition key is used to partition data into ranges and these ranges are load-balanced across the system.</span></span> <span data-ttu-id="944fe-300">Ciò significa che le convenzioni di denominazione quali l'ordinamento lessicale (ad esempio msftpayroll, msftperformance, msftemployees e così via) o l'uso di timestamp (log20160101, log20160102, log20160102 e così via) determinano la possibilità che le partizioni vengano condivise nello stesso server di partizioni, finché un'operazione di bilanciamento del carico non le suddivide in intervalli più piccoli.</span><span class="sxs-lookup"><span data-stu-id="944fe-300">This means naming conventions such as lexical ordering (e.g. msftpayroll, msftperformance, msftemployees, etc) or using time-stamps (log20160101, log20160102, log20160102, etc) will lend itself to the partitions being potentially co-located on the same partition server, until a load balancing operation splits them out into smaller ranges.</span></span> <span data-ttu-id="944fe-301">Ad esempio, tutti i BLOB in un contenitore possono essere serviti da un singolo server fino a quando il carico di questi BLOB richiede un ulteriore bilanciamento degli intervalli di partizione.</span><span class="sxs-lookup"><span data-stu-id="944fe-301">For example, all blobs within a container can be served by a single server until the load on these blobs requires further rebalancing of the partition ranges.</span></span> <span data-ttu-id="944fe-302">Analogamente, un gruppo di account con carico ridotto i cui nomi sono disposti in ordine lessicale può essere servito da un unico server, fino a quando il carico di uno o di tutti gli account non ne richiede la suddivisione su più server di partizioni.</span><span class="sxs-lookup"><span data-stu-id="944fe-302">Similarly, a group of lightly loaded accounts with their names arranged in lexical order may be served by a single server until the load on one or all of these accounts require them to be split across multiple partitions servers.</span></span> <span data-ttu-id="944fe-303">Ogni operazione di bilanciamento del carico può incidere negativamente sulla latenza delle chiamate di archiviazione durante l'operazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-303">Each load balancing operation may impact the latency of storage calls during the operation.</span></span> <span data-ttu-id="944fe-304">La capacità del sistema di gestire un improvviso picco di traffico destinato a una partizione è limitata dalla scalabilità di un singolo server di partizioni, fino a quando non viene attivata l'operazione di bilanciamento del carico che torna a bilanciare l'intervallo di chiavi di partizione.</span><span class="sxs-lookup"><span data-stu-id="944fe-304">The system's ability to handle a sudden burst of traffic to a partition is limited by the scalability of a single partition server until the load balancing operation kicks-in and rebalances the partition key range.</span></span>  

<span data-ttu-id="944fe-305">Alcune procedure consigliate consentono di ridurre la frequenza di queste operazioni.</span><span class="sxs-lookup"><span data-stu-id="944fe-305">You can follow some best practices to reduce the frequency of such operations.</span></span>  

* <span data-ttu-id="944fe-306">Esaminare nel dettaglio le convenzioni di denominazione usate per account, contenitori, BLOB, tabelle e code.</span><span class="sxs-lookup"><span data-stu-id="944fe-306">Examine the naming convention you use for accounts, containers, blobs, tables and queues, closely.</span></span> <span data-ttu-id="944fe-307">Considerare l'aggiunta di un prefisso ai nomi di account con un hash di 3 cifre, mediante la funzione di hashing più adatta alle esigenze.</span><span class="sxs-lookup"><span data-stu-id="944fe-307">Consider prefixing account names with a 3-digit hash using a hashing function that best suits your needs.</span></span>  
* <span data-ttu-id="944fe-308">Se si organizzano i dati con timestamp o identificatori numerici, assicurarsi di non usare modelli di traffico Solo accodamenti (o Solo anteposizioni).</span><span class="sxs-lookup"><span data-stu-id="944fe-308">If you organize your data using timestamps or numerical identifiers, you have to ensure you are not using an append-only (or prepend-only) traffic patterns.</span></span> <span data-ttu-id="944fe-309">Questi modelli non sono adatti a un sistema di partizionamento basato su intervalli e potrebbero indirizzare tutto il traffico a una singola partizione, impedendo un bilanciamento del carico efficiente nel sistema.</span><span class="sxs-lookup"><span data-stu-id="944fe-309">These patterns are not suitable for a range -based partitioning system, and could lead to all the traffic going to a single partition and limiting the system from effectively load balancing.</span></span> <span data-ttu-id="944fe-310">Ad esempio, se sono presenti operazioni giornaliere che usano un oggetto BLOB con un timestamp quale aaaammgg, tutto il traffico dell'operazione giornaliera viene indirizzato a un singolo oggetto, gestito da un unico server di partizioni.</span><span class="sxs-lookup"><span data-stu-id="944fe-310">For instance, if you have daily operations that use a blob object with a timestamp such as yyyymmdd, then all the traffic for that daily operation is directed to a single object which is served by a single partition server.</span></span> <span data-ttu-id="944fe-311">Verificare se i limiti per BLOB e i limiti per partizione soddisfano le esigenze e, se necessario, considerare la possibilità di suddividere l'operazione in più BLOB.</span><span class="sxs-lookup"><span data-stu-id="944fe-311">Look at whether the per blob limits and per partition limits meet your needs, and consider breaking this operation into multiple blobs if needed.</span></span> <span data-ttu-id="944fe-312">In modo analogo, se si archiviano dati della serie temporale nelle tabelle, è possibile che tutto il traffico venga indirizzato all'ultima parte dello spazio dei nomi della chiave.</span><span class="sxs-lookup"><span data-stu-id="944fe-312">Similarly, if you store time series data in your tables, all the traffic could be directed to the last part of the key namespace.</span></span> <span data-ttu-id="944fe-313">Se l'uso di timestamp o ID numerici è imprescindibile, aggiungere un hash di 3 cifre come prefisso dell'ID. Nel caso dei timestamp, aggiungere come prefisso i secondi nella stringa di data/ora, ad esempio ssaaaammgg.</span><span class="sxs-lookup"><span data-stu-id="944fe-313">If you must use timestamps or numerical IDs, prefix the id with a 3-digit hash, or in the case of timestamps prefix the seconds part of the time such as ssyyyymmdd.</span></span> <span data-ttu-id="944fe-314">Se vengono eseguite regolarmente operazioni di query e creazione elenchi, scegliere una funzione di hashing che limiti il numero di query.</span><span class="sxs-lookup"><span data-stu-id="944fe-314">If listing and querying operations are routinely performed, choose a hashing function that will limit your number of queries.</span></span> <span data-ttu-id="944fe-315">In altri casi può essere sufficiente un prefisso casuale.</span><span class="sxs-lookup"><span data-stu-id="944fe-315">In other cases, a random prefix may be sufficient.</span></span>  
* <span data-ttu-id="944fe-316">Per altre informazioni sullo schema di partizionamento usato in Archiviazione di Azure, leggere il documento SOSP [qui](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span><span class="sxs-lookup"><span data-stu-id="944fe-316">For additional information on the partitioning scheme used in Azure Storage, read the SOSP paper [here](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span></span>

### <a name="networking"></a><span data-ttu-id="944fe-317">Rete</span><span class="sxs-lookup"><span data-stu-id="944fe-317">Networking</span></span>
<span data-ttu-id="944fe-318">Oltre alle chiamate API, anche i vincoli fisici della rete dell'applicazione hanno spesso effetti significativi sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="944fe-318">While the API calls matter, often the physical network constraints of the application have a significant impact on performance.</span></span> <span data-ttu-id="944fe-319">Di seguito vengono descritte alcune limitazioni che gli utenti possono incontrare.</span><span class="sxs-lookup"><span data-stu-id="944fe-319">The following describe some of limitations users may encounter.</span></span>  

#### <a name="client-network-capability"></a><span data-ttu-id="944fe-320">Capacità della rete client</span><span class="sxs-lookup"><span data-stu-id="944fe-320">Client Network Capability</span></span>
##### <span data-ttu-id="944fe-321"><a name="subheading2"></a>Velocità effettiva.</span><span class="sxs-lookup"><span data-stu-id="944fe-321"><a name="subheading2"></a>Throughput</span></span>
<span data-ttu-id="944fe-322">Per la larghezza di banda il problema dipende spesso dalle capacità del client.</span><span class="sxs-lookup"><span data-stu-id="944fe-322">For bandwidth, the problem is often the capabilities of the client.</span></span> <span data-ttu-id="944fe-323">Se ad esempio un singolo account di archiviazione può gestire 10 Gbps o più in ingresso (vedere gli [obiettivi di scalabilità della larghezza di banda](#sub1bandwidth)), la velocità di rete in un'istanza "ridotta" del ruolo di lavoro di Azure arriva solo a circa 100 Mbps.</span><span class="sxs-lookup"><span data-stu-id="944fe-323">For example, while a single storage account can handle 10 Gbps or more of ingress (see [bandwidth scalability targets](#sub1bandwidth)), the network speed in a "Small" Azure Worker Role instance is only capable of approximately 100 Mbps.</span></span> <span data-ttu-id="944fe-324">Le istanze di Azure più grandi possono avere schede di interfaccia di rete con capacità più elevate ed è quindi opportuno prendere in considerazione l'uso di un'istanza più grande o di più macchine virtuali se è necessario che un singolo computer abbia limiti di rete più elevati.</span><span class="sxs-lookup"><span data-stu-id="944fe-324">Larger Azure instances have NICs with greater capacity, so you should consider using a larger instance or more VM's if you need higher network limits from a single machine.</span></span> <span data-ttu-id="944fe-325">Se si accede a un servizio di archiviazione da un'applicazione locale, si applica la stessa regola: comprendere le capacità di rete del dispositivo client e la connettività di rete della posizione di archiviazione di Azure, quindi aumentarle in base alle esigenze o progettare l'applicazione in modo che funzioni con i limiti di capacità disponibili.</span><span class="sxs-lookup"><span data-stu-id="944fe-325">If you are accessing a Storage service from an on premises application, then the same rule applies: understand the network capabilities of the client device and the network connectivity to the Azure Storage location and either improve them as needed or design your application to work within their capabilities.</span></span>  

##### <span data-ttu-id="944fe-326"><a name="subheading3"></a>Qualità del collegamento</span><span class="sxs-lookup"><span data-stu-id="944fe-326"><a name="subheading3"></a>Link Quality</span></span>
<span data-ttu-id="944fe-327">Come accade in ogni rete, tenere presente che le condizioni di rete che generano errori e perdita di pacchetti riducono la velocità effettiva.</span><span class="sxs-lookup"><span data-stu-id="944fe-327">As with any network usage, be aware that network conditions resulting in errors and packet loss will slow effective throughput.</span></span>  <span data-ttu-id="944fe-328">L'uso di WireShark o NetMon può contribuire a diagnosticare il problema.</span><span class="sxs-lookup"><span data-stu-id="944fe-328">Using WireShark or NetMon may help in diagnosing this issue.</span></span>  

##### <a name="useful-resources"></a><span data-ttu-id="944fe-329">Risorse utili</span><span class="sxs-lookup"><span data-stu-id="944fe-329">Useful Resources</span></span>
<span data-ttu-id="944fe-330">Per altre informazioni sulle dimensioni della macchina virtuale e sulla larghezza di banda allocata, vedere [Dimensioni delle macchine virtuali di Windows](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) o [Dimensioni delle macchine virtuali di Linux](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span><span class="sxs-lookup"><span data-stu-id="944fe-330">For more information about virtual machine sizes and allocated bandwidth, see [Windows VM sizes](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) or [Linux VM sizes](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span></span>  

#### <span data-ttu-id="944fe-331"><a name="subheading4"></a>Posizione</span><span class="sxs-lookup"><span data-stu-id="944fe-331"><a name="subheading4"></a>Location</span></span>
<span data-ttu-id="944fe-332">In qualsiasi ambiente distribuito, il posizionamento del client accanto al server offre le prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="944fe-332">In any distributed environment, placing the client near to the server delivers in the best performance.</span></span> <span data-ttu-id="944fe-333">Per accedere all'archiviazione di Azure con la minor latenza possibile, è opportuno posizionare il client nella stessa area di Azure.</span><span class="sxs-lookup"><span data-stu-id="944fe-333">For accessing Azure Storage with the lowest latency, the best location for your client is within the same Azure region.</span></span> <span data-ttu-id="944fe-334">Ad esempio, se si ha un sito Web di Azure che usa l'archiviazione di Azure, posizionare entrambi in un'unica area (ad esempio, Stati Uniti occidentali o Asia sudorientale).</span><span class="sxs-lookup"><span data-stu-id="944fe-334">For example, if you have an Azure Web Site that uses Azure Storage, you should locate them both within a single region (for example, US West or Asia Southeast).</span></span> <span data-ttu-id="944fe-335">In questo modo si riducono latenza e costi. Attualmente, infatti, l'uso della larghezza di banda in un'unica area è gratuito.</span><span class="sxs-lookup"><span data-stu-id="944fe-335">This reduces the latency and the cost — at the time of writing, bandwidth usage within a single region is free.</span></span>  

<span data-ttu-id="944fe-336">Anche nel caso di applicazioni client non ospitate in Azure (ad esempio, app di dispositivi mobili o servizi aziendali locali) la latenza viene ridotta se si posiziona l'account di archiviazione in un'area vicina ai dispositivi che si connetteranno a tale account.</span><span class="sxs-lookup"><span data-stu-id="944fe-336">If your client applications are not hosted within Azure (such as mobile device apps or on premises enterprise services), then again placing the storage account in a region near to the devices that will access it, will generally reduce latency.</span></span> <span data-ttu-id="944fe-337">Se i client sono distribuiti in un'area ampia (ad esempio, alcuni in America del Nord e altri in Europa), è opportuno usare più account di archiviazione: uno nell'area nordamericana e uno in quella europea.</span><span class="sxs-lookup"><span data-stu-id="944fe-337">If your clients are broadly distributed (for example, some in North America, and some in Europe), then you should consider using multiple storage accounts: one located in a North American region and one in a European region.</span></span> <span data-ttu-id="944fe-338">Ciò consente di ridurre la latenza per gli utenti di entrambe le aree.</span><span class="sxs-lookup"><span data-stu-id="944fe-338">This will help to reduce latency for users in both regions.</span></span> <span data-ttu-id="944fe-339">Questo approccio è generalmente più semplice da implementare se i dati archiviati dall'applicazione sono specifici di singoli utenti e non richiedono la replica tra gli account di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-339">This approach is usually easier to implement if the data the application stores is specific to individual users, and does not require replicating data between storage accounts.</span></span>  <span data-ttu-id="944fe-340">Per una distribuzione dei contenuti di grandi dimensioni si consiglia l'uso di una rete CDN. Vedere la sezione seguente per altri dettagli.</span><span class="sxs-lookup"><span data-stu-id="944fe-340">For broad content distribution, a CDN is recommended – see the next section for more details.</span></span>  

### <span data-ttu-id="944fe-341"><a name="subheading5"></a>Distribuzione di contenuti</span><span class="sxs-lookup"><span data-stu-id="944fe-341"><a name="subheading5"></a>Content Distribution</span></span>
<span data-ttu-id="944fe-342">A volte un'applicazione deve fornire lo stesso contenuto a più utenti (ad esempio, un video dimostrativo di un prodotto usato nella home page di un sito Web) che si trovano in un'unica area o in aree diverse.</span><span class="sxs-lookup"><span data-stu-id="944fe-342">Sometimes, an application needs to serve the same content to many users (e.g. a product demo video used in the home page of a website), located in either the same or multiple regions.</span></span> <span data-ttu-id="944fe-343">In questo scenario è opportuno usare una rete per la distribuzione di contenuti (CDN, Content Delivery Network), ad esempio la rete CDN di Azure, che usa l'archiviazione di Azure come origine dei dati.</span><span class="sxs-lookup"><span data-stu-id="944fe-343">In this scenario, you should use a Content Delivery Network (CDN) such as Azure CDN, and the CDN would use Azure storage as the origin of the data.</span></span> <span data-ttu-id="944fe-344">A differenza di un account di archiviazione di Azure, presente in un'unica area e che non può fornire contenuti con una bassa latenza in altre aree, la rete CDN di Azure usa diversi server in più data center in tutto il mondo.</span><span class="sxs-lookup"><span data-stu-id="944fe-344">Unlike an Azure Storage account that exists in a single region and that cannot deliver content with low latency to other regions, Azure CDN uses servers in multiple data centers around the world.</span></span> <span data-ttu-id="944fe-345">Inoltre, una rete CDN in genere supporta limiti in uscita molto più elevati rispetto a un singolo account di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-345">Additionally, a CDN can typically support much higher egress limits than a single storage account.</span></span>  

<span data-ttu-id="944fe-346">Per altre informazioni sulla rete CDN di Azure, vedere [rete CDN di Azure](https://azure.microsoft.com/services/cdn/).</span><span class="sxs-lookup"><span data-stu-id="944fe-346">For more information about Azure CDN, see [Azure CDN](https://azure.microsoft.com/services/cdn/).</span></span>  

### <span data-ttu-id="944fe-347"><a name="subheading6"></a>Uso delle firme di accesso condiviso (SAS) e della condivisione risorse tra le origini (CORS)</span><span class="sxs-lookup"><span data-stu-id="944fe-347"><a name="subheading6"></a>Using SAS and CORS</span></span>
<span data-ttu-id="944fe-348">Per autorizzare il codice, ad esempio JavaScript, in un Web browser dell'utente o in un'app di un telefono cellulare per accedere ai dati in Archiviazione di Azure, un approccio consiste nell'usare un'applicazione nel ruolo Web come proxy: il dispositivo dell'utente viene autenticato con il ruolo Web che a sua volta viene autenticato con il servizio di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-348">When you need to authorize code such as JavaScript in a user's web browser or a mobile phone app to access data in Azure Storage, one approach is to use an application in web role as a proxy: the user's device authenticates with the web role, which in turn authenticates with the storage service.</span></span> <span data-ttu-id="944fe-349">In questo modo si evita di esporre le chiavi dell'account di archiviazione in dispositivi non sicuri.</span><span class="sxs-lookup"><span data-stu-id="944fe-349">In this way, you can avoid exposing your storage account keys on insecure devices.</span></span> <span data-ttu-id="944fe-350">Ciò causa tuttavia un notevole sovraccarico del ruolo Web perché tutti i dati trasferiti tra il dispositivo dell'utente e il servizio di archiviazione devono passare attraverso il ruolo Web.</span><span class="sxs-lookup"><span data-stu-id="944fe-350">However, this places a big overhead on the web role because all the data transferred between the user's device and the storage service must pass through the web role.</span></span> <span data-ttu-id="944fe-351">È possibile evitare l'uso di un ruolo Web come proxy per il servizio di archiviazione usando le firme di accesso condiviso, talvolta insieme alle intestazioni di condivisione risorse tra le origini (CORS).</span><span class="sxs-lookup"><span data-stu-id="944fe-351">You can avoid using a web role as a proxy for the storage service by using Shared Access Signatures (SAS), sometimes in conjunction with Cross-Origin Resource Sharing headers (CORS).</span></span> <span data-ttu-id="944fe-352">Con le firme di accesso condiviso (SAS) è possibile consentire al dispositivo dell'utente di indirizzare le richieste direttamente a un servizio di archiviazione attraverso un token con accesso limitato.</span><span class="sxs-lookup"><span data-stu-id="944fe-352">Using SAS, you can allow your user's device to make requests directly to a storage service by means of a limited access token.</span></span> <span data-ttu-id="944fe-353">Se ad esempio un utente vuole caricare una foto nell'applicazione, il ruolo Web può generare e inviare al dispositivo dell'utente un token SAS che concede un'autorizzazione di scrittura in uno specifico BLOB o in un contenitore per i successivi 30 minuti (dopo i quali il token SAS scade).</span><span class="sxs-lookup"><span data-stu-id="944fe-353">For example, if a user wants to upload a photo to your application, your web role can generate and send to the user's device a SAS token that grants permission to write to a specific blob or container for the next 30 minutes (after which the SAS token expires).</span></span>

<span data-ttu-id="944fe-354">Un browser non consente in genere codice JavaScript in una pagina ospitata da un sito Web in un dominio per l'esecuzione di operazioni specifiche come "PUT" in un altro dominio.</span><span class="sxs-lookup"><span data-stu-id="944fe-354">Normally, a browser will not allow JavaScript in a page hosted by a website on one domain to perform specific operations such as a "PUT" to another domain.</span></span> <span data-ttu-id="944fe-355">Se si ospita ad esempio un ruolo Web in "contosomarketing.cloudapp.net" e si vuole usare JavaScript sul lato client per caricare un BLOB nell'account di archiviazione in "contosoproducts.blob.core.windows.net", i "criteri di corrispondenza all'origine" del browser impediscono l'operazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-355">For example, if you host a web role at "contosomarketing.cloudapp.net," and want to use client side JavaScript to upload a blob to your storage account at "contosoproducts.blob.core.windows.net," the browser's "same origin policy" will forbid this operation.</span></span> <span data-ttu-id="944fe-356">CORS è una funzionalità del browser che consente al dominio di destinazione (in questo caso l'account di archiviazione) di comunicare con il browser di cui reputa attendibili le richieste originate nel dominio di origine (in questo caso il ruolo Web).</span><span class="sxs-lookup"><span data-stu-id="944fe-356">CORS is a browser feature that allows the target domain (in this case the storage account) to communicate to the browser that it trusts requests originating in the source domain (in this case the web role).</span></span>  

<span data-ttu-id="944fe-357">Entrambe le tecnologie possono aiutare a evitare carichi o colli di bottiglia non necessari nell'applicazione Web.</span><span class="sxs-lookup"><span data-stu-id="944fe-357">Both of these technologies can help you avoid unnecessary load (and bottlenecks) on your web application.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="944fe-358">Risorse utili</span><span class="sxs-lookup"><span data-stu-id="944fe-358">Useful Resources</span></span>
<span data-ttu-id="944fe-359">Per altre informazioni sulle firme di accesso condiviso, vedere [Firme di accesso condiviso, parte 1: informazioni sul modello di firma di accesso condiviso](../storage-dotnet-shared-access-signature-part-1.md).</span><span class="sxs-lookup"><span data-stu-id="944fe-359">For more information about SAS, see [Shared Access Signatures, Part 1: Understanding the SAS Model](../storage-dotnet-shared-access-signature-part-1.md).</span></span>  

<span data-ttu-id="944fe-360">Per altre informazioni sulla condivisione risorse tra le origini, vedere [Supporto della condivisione delle risorse tra le origini (CORS) per i servizi di archiviazione Azure](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span><span class="sxs-lookup"><span data-stu-id="944fe-360">For more information about CORS, see [Cross-Origin Resource Sharing (CORS) Support for the Azure Storage Services](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span></span>  

### <a name="caching"></a><span data-ttu-id="944fe-361">Memorizzazione nella cache</span><span class="sxs-lookup"><span data-stu-id="944fe-361">Caching</span></span>
#### <span data-ttu-id="944fe-362"><a name="subheading7"></a>Recupero dei dati</span><span class="sxs-lookup"><span data-stu-id="944fe-362"><a name="subheading7"></a>Getting Data</span></span>
<span data-ttu-id="944fe-363">In generale è meglio recuperare i dati da un servizio una sola volta e non ripetutamente.</span><span class="sxs-lookup"><span data-stu-id="944fe-363">In general, getting data from a service once is better than getting it twice.</span></span> <span data-ttu-id="944fe-364">Considerare l'esempio di un'applicazione Web MVC eseguita in un ruolo Web che ha già recuperato un BLOB da 50 MB dal servizio di archiviazione da usare come contenuto per un utente.</span><span class="sxs-lookup"><span data-stu-id="944fe-364">Consider the example of an MVC web application running in a web role that has already retrieved a 50MB blob from the storage service to serve as content to a user.</span></span> <span data-ttu-id="944fe-365">L'applicazione può quindi recuperare lo stesso BLOB ogni volta che un utente lo richiede o può memorizzarlo nella cache locale sul disco e riusare questa versione per le successive richieste dell'utente.</span><span class="sxs-lookup"><span data-stu-id="944fe-365">The application could then retrieve that same blob every time a user requests it, or it could cache it locally to disk and reuse the cached version for subsequent user requests.</span></span> <span data-ttu-id="944fe-366">Quando un utente richiede i dati, l'applicazione può inoltre generare un'operazione GET con un'intestazione condizionale per il tempo di modifica che evita di recuperare l'intero BLOB se non è stato modificato.</span><span class="sxs-lookup"><span data-stu-id="944fe-366">Furthermore, whenever a user requests the data, the application could issue GET with a conditional header for modification time, which would avoid getting the entire blob if it hasn't been modified.</span></span> <span data-ttu-id="944fe-367">È possibile applicare lo stesso modello quando si usano le entità di tabella.</span><span class="sxs-lookup"><span data-stu-id="944fe-367">You can apply this same pattern to working with table entities.</span></span>  

<span data-ttu-id="944fe-368">In alcuni casi si può impostare l'applicazione in modo che consideri valido il BLOB per un breve periodo di tempo dopo il recupero e che, durante questo periodo, non controlli se il BLOB sia stato modificato.</span><span class="sxs-lookup"><span data-stu-id="944fe-368">In some cases, you may decide that your application can assume that the blob remains valid for a short period after retrieving it, and that during this period the application does not need to check if the blob was modified.</span></span>

<span data-ttu-id="944fe-369">I dati di configurazione, di ricerca e altri dati usati di frequente dall'applicazione sono ottimi candidati per la memorizzazione nella cache.</span><span class="sxs-lookup"><span data-stu-id="944fe-369">Configuration, lookup, and other data that are always used by the application are great candidates for caching.</span></span>  

<span data-ttu-id="944fe-370">Per un esempio di come recuperare le proprietà di un BLOB per individuare la data dell'ultima modifica con .NET, vedere [Impostare e recuperare proprietà e metadati](../blobs/storage-properties-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="944fe-370">For an example of how to get a blob's properties to discover the last modified date using .NET, see [Set and Retrieve Properties and Metadata](../blobs/storage-properties-metadata.md).</span></span> <span data-ttu-id="944fe-371">Per altre informazioni sui download condizionali, vedere [Aggiornare una copia locale di un Blob in modo condizionale](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span><span class="sxs-lookup"><span data-stu-id="944fe-371">For more information about conditional downloads, see [Conditionally Refresh a Local Copy of a Blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span></span>  

#### <span data-ttu-id="944fe-372"><a name="subheading8"></a>Caricamento dei dati in batch</span><span class="sxs-lookup"><span data-stu-id="944fe-372"><a name="subheading8"></a>Uploading Data in Batches</span></span>
<span data-ttu-id="944fe-373">In alcuni scenari dell'applicazione è possibile aggregare i dati localmente e caricarli periodicamente in un batch invece di caricare subito i singoli dati.</span><span class="sxs-lookup"><span data-stu-id="944fe-373">In some application scenarios, you can aggregate data locally, and then periodically upload it in a batch instead of uploading each piece of data immediately.</span></span> <span data-ttu-id="944fe-374">Ad esempio, un'applicazione Web può mantenere un file di log delle attività: l'applicazione può caricare i dettagli delle singole attività man mano che vengono eseguite come entità di tabella (il che richiede molte operazioni di archiviazione) oppure può salvarli in un file di log locale e caricare periodicamente tutti i dettagli dell'attività in un file delimitato in un BLOB.</span><span class="sxs-lookup"><span data-stu-id="944fe-374">For example, a web application might keep a log file of activities: the application could either upload details of every activity as it happens as a table entity (which requires many storage operations), or it could save activity details to a local log file, and then periodically upload all activity details as a delimited file to a blob.</span></span> <span data-ttu-id="944fe-375">Se ogni voce di log ha una dimensione pari a 1 KB, è possibile caricare migliaia di voci in un'unica transazione "Put Blob", considerando che è possibile caricare un BLOB con una dimensione massima di 64 MB in un'unica transazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-375">If each log entry is 1KB in size, you can upload thousands in a single "Put Blob" transaction (you can upload a blob of up to 64MB in size in a single transaction).</span></span> <span data-ttu-id="944fe-376">Ovviamente se il computer locale si arresta prima del caricamento, è possibile che vengano persi dei dati del log: lo sviluppatore di applicazioni deve tenere conto della possibilità di un arresto del dispositivo client o del caricamento.</span><span class="sxs-lookup"><span data-stu-id="944fe-376">Of course, if the local machine crashes prior to the upload, you will potentially lose some log data: the application developer must design for the possibility of client device or upload failures.</span></span>  <span data-ttu-id="944fe-377">Se i dati dell'attività devono essere scaricati in base agli intervalli di tempo (non alle singole attività), si consiglia di usare i BLOB invece delle tabelle.</span><span class="sxs-lookup"><span data-stu-id="944fe-377">If the activity data needs to be downloaded for timespans (not just single activity), then blobs are recommended over tables.</span></span>

### <a name="net-configuration"></a><span data-ttu-id="944fe-378">Configurazione .NET</span><span class="sxs-lookup"><span data-stu-id="944fe-378">.NET Configuration</span></span>
<span data-ttu-id="944fe-379">Se si usa .NET Framework, in questa sezione vengono elencate diverse impostazioni di configurazione rapide che è possibile usare per migliorare significativamente le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="944fe-379">If using the .NET Framework, this section lists several quick configuration settings that you can use to make significant performance improvements.</span></span>  <span data-ttu-id="944fe-380">Se si usano altri linguaggi, controllare se esistono procedure simili per il linguaggio prescelto.</span><span class="sxs-lookup"><span data-stu-id="944fe-380">If using other languages, check to see if similar concepts apply in your chosen language.</span></span>  

#### <span data-ttu-id="944fe-381"><a name="subheading9"></a>Aumento del limite di connessione predefinito</span><span class="sxs-lookup"><span data-stu-id="944fe-381"><a name="subheading9"></a>Increase default connection limit</span></span>
<span data-ttu-id="944fe-382">In .NET, il seguente codice aumenta il limite di connessione predefinito (in genere pari a 2 in un ambiente client o 10 in un ambiente server) a 100.</span><span class="sxs-lookup"><span data-stu-id="944fe-382">In .NET, the following code increases the default connection limit (which is usually 2 in a client environment or 10 in a server environment) to 100.</span></span> <span data-ttu-id="944fe-383">Solitamente il valore deve essere impostato basandosi approssimativamente sul numero di thread usato dall'applicazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-383">Typically, you should set the value to approximately the number of threads used by your application.</span></span>  

```csharp
ServicePointManager.DefaultConnectionLimit = 100; //(Or More)  
```

<span data-ttu-id="944fe-384">È necessario impostare il limite di connessione prima di aprire le connessioni.</span><span class="sxs-lookup"><span data-stu-id="944fe-384">You must set the connection limit before opening any connections.</span></span>  

<span data-ttu-id="944fe-385">Per gli altri linguaggi di programmazione, vedere la documentazione specifica per determinare come impostare il limite di connessione.</span><span class="sxs-lookup"><span data-stu-id="944fe-385">For other programming languages, see that language's documentation to determine how to set the connection limit.</span></span>  

<span data-ttu-id="944fe-386">Per altre informazioni, vedere il blog post [Servizi Web: connessioni simultanee](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span><span class="sxs-lookup"><span data-stu-id="944fe-386">For additional information, see the blog post [Web Services: Concurrent Connections](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span></span>  

#### <span data-ttu-id="944fe-387"><a name="subheading10"></a>Aumentare il numero minimo di thread di ThreadPool se si usa codice sincrono con attività asincrone</span><span class="sxs-lookup"><span data-stu-id="944fe-387"><a name="subheading10"></a>Increase ThreadPool Min Threads if using synchronous code with Async Tasks</span></span>
<span data-ttu-id="944fe-388">Questo codice aumenta il numero minimo di thread del pool di thread:</span><span class="sxs-lookup"><span data-stu-id="944fe-388">This code will increase the thread pool min threads:</span></span>  

```csharp
ThreadPool.SetMinThreads(100,100); //(Determine the right number for your application)  
```

<span data-ttu-id="944fe-389">Per altre informazioni, vedere [Metodo ThreadPool.SetMinThreads](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span><span class="sxs-lookup"><span data-stu-id="944fe-389">For more information, see [ThreadPool.SetMinThreads Method](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span></span>  

#### <span data-ttu-id="944fe-390"><a name="subheading11"></a>Vantaggi della funzionalità Garbage Collection di .NET 4.5</span><span class="sxs-lookup"><span data-stu-id="944fe-390"><a name="subheading11"></a>Take advantage of .NET 4.5 Garbage Collection</span></span>
<span data-ttu-id="944fe-391">Usare .NET 4.5 o versione successiva per consentire all'applicazione client di sfruttare i miglioramenti delle prestazioni relativi alla funzionalità Garbage Collection del server.</span><span class="sxs-lookup"><span data-stu-id="944fe-391">Use .NET 4.5 or later for the client application to take advantage of performance improvements in server garbage collection.</span></span>

<span data-ttu-id="944fe-392">Per altre informazioni, vedere l'articolo [Panoramica dei miglioramenti delle prestazioni in .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span><span class="sxs-lookup"><span data-stu-id="944fe-392">For more information, see the article [An Overview of Performance Improvements in .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span></span>  

### <span data-ttu-id="944fe-393"><a name="subheading12"></a>Parallelismo non associato</span><span class="sxs-lookup"><span data-stu-id="944fe-393"><a name="subheading12"></a>Unbounded Parallelism</span></span>
<span data-ttu-id="944fe-394">Il parallelismo è un metodo efficace per mantenere il livello delle prestazioni, tuttavia è necessario prestare attenzione quando si usa il parallelismo non associato (senza limiti sul numero di thread e/o di richieste parallele) per caricare o scaricare i dati, quando si usano più lavori per accedere a diverse partizioni (contenitori, code o partizioni di tabelle) nello stesso account di archiviazione o per accedere a più elementi nella stessa partizione.</span><span class="sxs-lookup"><span data-stu-id="944fe-394">While parallelism can be great for performance, be careful about using unbounded parallelism (no limit on the number of threads and/or parallel requests) to upload or download data, using multiple workers to access multiple partitions (containers, queues, or table partitions) in the same storage account or to access multiple items in the same partition.</span></span> <span data-ttu-id="944fe-395">Se il parallelismo non è associato, l'applicazione può superare le capacità del dispositivo client o gli obiettivi di scalabilità dell'account di archiviazione producendo latenze più lunghe e limitazioni.</span><span class="sxs-lookup"><span data-stu-id="944fe-395">If the parallelism is unbounded, your application can exceed the client device's capabilities or the storage account's scalability targets resulting in longer latencies and throttling.</span></span>  

### <span data-ttu-id="944fe-396"><a name="subheading13"></a>Librerie e strumenti client dell'archiviazione</span><span class="sxs-lookup"><span data-stu-id="944fe-396"><a name="subheading13"></a>Storage Client Libraries and Tools</span></span>
<span data-ttu-id="944fe-397">Usare sempre l'ultima versione delle librerie e degli strumenti client forniti da Microsoft.</span><span class="sxs-lookup"><span data-stu-id="944fe-397">Always use the latest Microsoft provided client libraries and tools.</span></span> <span data-ttu-id="944fe-398">Al momento della redazione di questo documento, sono disponibili librerie client per .NET, Windows Phone, Windows Runtime, Java e C++ nonché librerie di anteprima per altri linguaggi.</span><span class="sxs-lookup"><span data-stu-id="944fe-398">At the time of writing, there are client libraries available for .NET, Windows Phone, Windows Runtime, Java, and C++, as well as preview libraries for other languages.</span></span> <span data-ttu-id="944fe-399">Inoltre, Microsoft ha rilasciato i cmdlet di PowerShell e i comandi CLI Azure da usare con l'archiviazione di Azure.</span><span class="sxs-lookup"><span data-stu-id="944fe-399">In addition, Microsoft has released PowerShell cmdlets and Azure CLI commands for working with Azure Storage.</span></span> <span data-ttu-id="944fe-400">Microsoft sviluppa attivamente questi strumenti concentrandosi sulle prestazioni, li mantiene aggiornati con le ultime versioni del servizio e verifica che siano in grado di gestire internamente gran parte delle procedure comprovate relative alle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="944fe-400">Microsoft actively develops these tools with performance in mind, keeps them up to date with the latest service versions, and ensures they handle many of the proven performance practices internally.</span></span>  

### <a name="retries"></a><span data-ttu-id="944fe-401">Tentativi</span><span class="sxs-lookup"><span data-stu-id="944fe-401">Retries</span></span>
#### <span data-ttu-id="944fe-402"><a name="subheading14"></a>Limitazione/ServerBusy</span><span class="sxs-lookup"><span data-stu-id="944fe-402"><a name="subheading14"></a>Throttling/ServerBusy</span></span>
<span data-ttu-id="944fe-403">In alcuni casi il servizio di archiviazione può limitare l'applicazione o semplicemente non essere in grado di completare la richiesta a causa di condizioni temporanee. In questi casi, il servizio restituisce un messaggio "503 Server occupato" o "500 Timeout".</span><span class="sxs-lookup"><span data-stu-id="944fe-403">In some cases, the storage service may throttle your application or may simply be unable to serve the request due to some transient condition and return a "503 Server busy" message or "500 Timeout".</span></span>  <span data-ttu-id="944fe-404">Questo accade se l'applicazione sta raggiungendo gli obiettivi di scalabilità o se il sistema sta ribilanciando i dati partizionati per consentire una maggiore velocità effettiva.</span><span class="sxs-lookup"><span data-stu-id="944fe-404">This can happen if your application is approaching any of the scalability targets, or if the system is rebalancing your partitioned data to allow for higher throughput.</span></span>  <span data-ttu-id="944fe-405">L'applicazione client in genere deve ripetere l'operazione che ha causato l'errore: un tentativo successivo della stessa richiesta può avere esito positivo.</span><span class="sxs-lookup"><span data-stu-id="944fe-405">The client application should typically retry the operation that causes such an error: attempting the same request later can succeed.</span></span> <span data-ttu-id="944fe-406">Tuttavia, se il servizio di archiviazione sta limitando l'applicazione perché supera gli obiettivi di scalabilità o non è in grado di completare la richiesta per altri motivi, la ripetizione dei tentativi non fa che peggiorare il problema.</span><span class="sxs-lookup"><span data-stu-id="944fe-406">However, if the storage service is throttling your application because it is exceeding scalability targets, or even if the service was unable to serve the request for some other reason, aggressive retries usually make the problem worse.</span></span> <span data-ttu-id="944fe-407">Per questo motivo è opportuno usare un backoff esponenziale (nelle librerie client è il comportamento predefinito).</span><span class="sxs-lookup"><span data-stu-id="944fe-407">For this reason, you should use an exponential back off (the client libraries default to this behavior).</span></span> <span data-ttu-id="944fe-408">Ad esempio, l'applicazione può riprovare l'operazione dopo 2 secondi, 4 secondi, 10 secondi, 30 secondi, dopo di che non effettua altri tentativi.</span><span class="sxs-lookup"><span data-stu-id="944fe-408">For example, your application may retry after 2 seconds, then 4 seconds, then 10 seconds, then 30 seconds, and then give up completely.</span></span> <span data-ttu-id="944fe-409">Piuttosto che peggiorare il problema, questo comportamento consente di ridurre notevolmente il carico dell'applicazione sul servizio.</span><span class="sxs-lookup"><span data-stu-id="944fe-409">This behavior results in your application significantly reducing its load on the service rather than exacerbating any problems.</span></span>  

<span data-ttu-id="944fe-410">I nuovi tentativi relativi a errori di connettività possono eseguiti immediatamente perché non dipendono dalle limitazioni e sono considerati temporanei.</span><span class="sxs-lookup"><span data-stu-id="944fe-410">Note that connectivity errors can be retried immediately, because they are not the result of throttling and are expected to be transient.</span></span>  

#### <span data-ttu-id="944fe-411"><a name="subheading15"></a>Errori irreversibili</span><span class="sxs-lookup"><span data-stu-id="944fe-411"><a name="subheading15"></a>Non-Retryable Errors</span></span>
<span data-ttu-id="944fe-412">Le librerie client distinguono gli errori reversibili da quelli irreversibili.</span><span class="sxs-lookup"><span data-stu-id="944fe-412">The client libraries are aware of which errors are retry-able and which are not.</span></span> <span data-ttu-id="944fe-413">Tuttavia, se si scrive il proprio codice in base all'API REST di archiviazione, ricordare che esistono degli errori per i quali non devono essere effettuati nuovi tentativi: ad esempio, una risposta 400 (Richiesta non valida) indica che l'applicazione client ha inviato una richiesta che non è possibile elaborare perché non è nel formato previsto.</span><span class="sxs-lookup"><span data-stu-id="944fe-413">However, if you are writing your own code against the storage REST API, remember there are some errors that you should not retry: for example, a 400 (Bad Request) response indicates that the client application sent a request that could not be processed because it was not in an expected form.</span></span> <span data-ttu-id="944fe-414">Un nuovo invio di questa richiesta genererà sempre la stessa risposta, quindi è inutile riprovare.</span><span class="sxs-lookup"><span data-stu-id="944fe-414">Resending this request will result the same response every time, so there is no point in retrying it.</span></span> <span data-ttu-id="944fe-415">Se si scrive il proprio codice in base all'API REST di archiviazione, tenere presente il significato dei codici di errore e il modo corretto (e quello errato) di eseguire nuovi tentativi per ciascuno di essi.</span><span class="sxs-lookup"><span data-stu-id="944fe-415">If you are writing your own code against the storage REST API, be aware of what the error codes mean and the proper way to retry (or not) for each of them.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="944fe-416">Risorse utili</span><span class="sxs-lookup"><span data-stu-id="944fe-416">Useful Resources</span></span>
<span data-ttu-id="944fe-417">Per altre informazioni sui codici di errore di archiviazione, vedere [Codici ed errori di stato](http://msdn.microsoft.com/library/azure/dd179382.aspx) nel sito Web di Microsoft Azure.</span><span class="sxs-lookup"><span data-stu-id="944fe-417">For more information about storage error codes, see [Status and Error Codes](http://msdn.microsoft.com/library/azure/dd179382.aspx) on the Microsoft Azure web site.</span></span>  

## <a name="blobs"></a><span data-ttu-id="944fe-418">Blobs</span><span class="sxs-lookup"><span data-stu-id="944fe-418">Blobs</span></span>
<span data-ttu-id="944fe-419">Oltre alle procedure comprovate per [Tutti i servizi](#allservices) descritte prima, le seguenti procedure comprovate si applicano specificamente al servizio BLOB.</span><span class="sxs-lookup"><span data-stu-id="944fe-419">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the blob service.</span></span>  

### <a name="blob-specific-scalability-targets"></a><span data-ttu-id="944fe-420">Obiettivi di scalabilità specifici per BLOB</span><span class="sxs-lookup"><span data-stu-id="944fe-420">Blob-Specific Scalability Targets</span></span>
#### <span data-ttu-id="944fe-421"><a name="subheading46"></a>Accesso simultaneo di più client a un singolo oggetto</span><span class="sxs-lookup"><span data-stu-id="944fe-421"><a name="subheading46"></a>Multiple clients accessing a single object concurrently</span></span>
<span data-ttu-id="944fe-422">Se si ha un numero elevato di client che accedono contemporaneamente a un singolo oggetto, è necessario prendere in considerazione obiettivi di scalabilità per oggetto e account di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-422">If you have a large number of clients accessing a single object concurrently you will need to consider per object and storage account scalability targets.</span></span> <span data-ttu-id="944fe-423">Il numero esatto di client che possono accedere a un singolo oggetto dipende da fattori quali il numero di client che richiedono l'oggetto contemporaneamente, le dimensioni dell'oggetto, le condizioni della rete e così via.</span><span class="sxs-lookup"><span data-stu-id="944fe-423">The exact number of clients that can access a single object will vary depending on factors such as the number of clients requesting the object simultaneously, the size of the object, network conditions etc.</span></span>

<span data-ttu-id="944fe-424">Se l'oggetto può essere distribuito tramite una rete CDN, ad esempio nel caso di immagini o video serviti da un sito Web, è consigliabile usare una rete CDN.</span><span class="sxs-lookup"><span data-stu-id="944fe-424">If the object can be distributed through a CDN such as images or videos served from a website then you should use a CDN.</span></span> <span data-ttu-id="944fe-425">Vedere [qui](#subheading5).</span><span class="sxs-lookup"><span data-stu-id="944fe-425">See [here](#subheading5).</span></span>

<span data-ttu-id="944fe-426">In altri scenari, ad esempio simulazioni scientifiche in cui i dati sono riservati, sono disponibili due opzioni.</span><span class="sxs-lookup"><span data-stu-id="944fe-426">In other scenarios such as scientific simulations where the data is confidential you have two options.</span></span> <span data-ttu-id="944fe-427">La prima consiste nel suddividere l'accesso del carico di lavoro in fasi successive in modo che l'accesso all'oggetto sia diluito nel tempo e non simultaneo.</span><span class="sxs-lookup"><span data-stu-id="944fe-427">The first is to stagger your workload's access such that the object is accessed over a period of time vs being accessed simultaneously.</span></span> <span data-ttu-id="944fe-428">In alternativa, è possibile copiare temporaneamente l'oggetto in più account di archiviazione, aumentando il numero totale di IOPS per ogni oggetto e tra gli account di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-428">Alternatively, you can temporarily copy the object to multiple storage accounts thus increasing the total IOPS per object and across storage accounts.</span></span> <span data-ttu-id="944fe-429">In test limitati è stato rilevato che circa 25 macchine virtuali possono scaricare simultaneamente un BLOB di 100 GB in parallelo, ogni macchina virtuale ha parallelizzato il download con 32 thread.</span><span class="sxs-lookup"><span data-stu-id="944fe-429">In limited testing we found that around 25 VMs could simultaneously download a 100GB blob in parallel (each VM was parallelizing the download using 32 threads).</span></span> <span data-ttu-id="944fe-430">Se 100 client devono accedere all'oggetto, copiarlo prima di tutto in un secondo account di archiviazione e quindi fare in modo che le prime 50 macchine virtuali accedano al primo BLOB e le seconde 50 macchine virtuali accedano al secondo BLOB.</span><span class="sxs-lookup"><span data-stu-id="944fe-430">If you had 100 clients needing to access the object, first copy it to a second storage account and then have the first 50 VMs access the first blob and the second 50 VMs access the second blob.</span></span> <span data-ttu-id="944fe-431">I risultati variano a seconda del comportamento delle applicazioni. È quindi opportuno eseguire dei test in fase di progettazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-431">Results will vary depending on your applications behavior so you should test this during design.</span></span> 

#### <span data-ttu-id="944fe-432"><a name="subheading16"></a>Larghezza di banda e operazioni per BLOB</span><span class="sxs-lookup"><span data-stu-id="944fe-432"><a name="subheading16"></a>Bandwidth and operations per Blob</span></span>
<span data-ttu-id="944fe-433">È possibile leggere o scrivere in un singolo BLOB a un massimo di 60 MB/secondo (circa 480 Mbps, un valore che supera le capacità di molte reti sul lato client inclusa la scheda di interfaccia di rete fisica nel dispositivo client).</span><span class="sxs-lookup"><span data-stu-id="944fe-433">You can read or write to a single blob at up to a maximum of 60 MB/second (this is approximately 480 Mbps which exceeds the capabilities of many client side networks (including the physical NIC on the client device).</span></span> <span data-ttu-id="944fe-434">Inoltre, un singolo BLOB supporta fino a 500 richieste al secondo.</span><span class="sxs-lookup"><span data-stu-id="944fe-434">In addition, a single blob supports up to 500 requests per second.</span></span> <span data-ttu-id="944fe-435">Se si hanno più client che devono leggere lo stesso BLOB e si teme di superare questi limiti, valutare l'uso di una rete CDN per la distribuzione del BLOB.</span><span class="sxs-lookup"><span data-stu-id="944fe-435">If you have multiple clients that need to read the same blob and you might exceed these limits, you should consider using a CDN for distributing the blob.</span></span>  

<span data-ttu-id="944fe-436">Per altre informazioni sulla velocità effettiva da raggiungere per i BLOB, vedere [Obiettivi di scalabilità e prestazioni di archiviazione di Azure](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="944fe-436">For more information about target throughput for blobs, see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <a name="copying-and-moving-blobs"></a><span data-ttu-id="944fe-437">Copia e spostamento dei BLOB</span><span class="sxs-lookup"><span data-stu-id="944fe-437">Copying and Moving Blobs</span></span>
#### <span data-ttu-id="944fe-438"><a name="subheading17"></a>Copia Blob</span><span class="sxs-lookup"><span data-stu-id="944fe-438"><a name="subheading17"></a>Copy Blob</span></span>
<span data-ttu-id="944fe-439">La versione dell'API REST di archiviazione 2012-02-12 ha introdotto un'utile funzionalità che consente di copiare i BLOB in diversi account: un'applicazione client può impostare il servizio di archiviazione in modo che copi un BLOB da un'altra origine (possibilmente in un altro account di archiviazione) e lasciare che il servizio esegua la copia in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="944fe-439">The storage REST API version 2012-02-12 introduced the useful ability to copy blobs across accounts: a client application can instruct the storage service to copy a blob from another source (possibly in a different storage account), and then let the service perform the copy asynchronously.</span></span> <span data-ttu-id="944fe-440">Ciò consente di ridurre notevolmente la larghezza di banda necessaria all'applicazione quando si esegue la migrazione dei dati da altri account di archiviazione perché non si devono scaricare e caricare i dati.</span><span class="sxs-lookup"><span data-stu-id="944fe-440">This can significantly reduce the bandwidth needed for the application when you are migrating data from other storage accounts because you do not need to download and upload the data.</span></span>  

<span data-ttu-id="944fe-441">Tuttavia, tenere presente che quando si eseguono copie tra gli account di archiviazione non esistono garanzie sul tempo richiesto per il completamento.</span><span class="sxs-lookup"><span data-stu-id="944fe-441">One consideration, however, is that, when copying between storage accounts, there is no time guarantee on when the copy will complete.</span></span> <span data-ttu-id="944fe-442">Se l'applicazione deve completare rapidamente una copia BLOB sotto il controllo dell'utente, si consiglia di copiare il BLOB scaricandolo in una macchina virtuale e caricandolo nella destinazione desiderata.</span><span class="sxs-lookup"><span data-stu-id="944fe-442">If your application needs to complete a blob copy quickly under your control, it may be better to copy the blob by downloading it to a VM and then uploading it to the destination.</span></span>  <span data-ttu-id="944fe-443">Per una prevedibilità completa in questa situazione verificare che la copia venga eseguita da una macchina virtuale in esecuzione nella stessa area di Azure; in caso contrario, è possibile (anzi, probabile) che le condizioni di rete abbiano effetto sulle prestazioni di copia.</span><span class="sxs-lookup"><span data-stu-id="944fe-443">For full predictability in that situation, ensure that the copy is performed by a VM running in the same Azure region, or else network conditions may (and probably will) affect your copy performance.</span></span>  <span data-ttu-id="944fe-444">Inoltre, è possibile monitorare lo stato di una copia asincrona a livello di codice.</span><span class="sxs-lookup"><span data-stu-id="944fe-444">In addition, you can monitor the progress of an asynchronous copy programmatically.</span></span>  

<span data-ttu-id="944fe-445">Le copie nello stesso account di archiviazione vengono generalmente completate rapidamente.</span><span class="sxs-lookup"><span data-stu-id="944fe-445">Note that copies within the same storage account itself are generally completed quickly.</span></span>  

<span data-ttu-id="944fe-446">Per altre informazioni, vedere [Copy Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span><span class="sxs-lookup"><span data-stu-id="944fe-446">For more information, see [Copy Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span></span>  

#### <span data-ttu-id="944fe-447"><a name="subheading18"></a>Usare AzCopy</span><span class="sxs-lookup"><span data-stu-id="944fe-447"><a name="subheading18"></a>Use AzCopy</span></span>
<span data-ttu-id="944fe-448">Il team di Archiviazione di Azure ha rilasciato lo strumento da riga di comando "AzCopy" per supportare il trasferimento in blocco di più BLOB verso, da e tra account di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-448">The Azure Storage team has released a command-line tool "AzCopy" that is meant to help with bulk transferring many blobs to, from, and across storage accounts.</span></span>  <span data-ttu-id="944fe-449">Questo strumento è ottimizzato per questo scenario e può raggiungere elevate velocità di trasferimento.</span><span class="sxs-lookup"><span data-stu-id="944fe-449">This tool is optimized for this scenario, and can achieve high transfer rates.</span></span>  <span data-ttu-id="944fe-450">Se ne consiglia l'uso negli scenari di caricamento, download e copia bulk.</span><span class="sxs-lookup"><span data-stu-id="944fe-450">Its use is encouraged for bulk upload, download, and copy scenarios.</span></span> <span data-ttu-id="944fe-451">Per altre informazioni sullo strumento e per scaricarlo, vedere [Trasferire dati con l'utilità della riga di comando AzCopy](storage-use-azcopy.md).</span><span class="sxs-lookup"><span data-stu-id="944fe-451">To learn more about it and download it, see [Transfer data with the AzCopy Command-Line Utility](storage-use-azcopy.md).</span></span>  

#### <span data-ttu-id="944fe-452"><a name="subheading19"></a>Servizio di importazione/esportazione di Azure</span><span class="sxs-lookup"><span data-stu-id="944fe-452"><a name="subheading19"></a>Azure Import/Export Service</span></span>
<span data-ttu-id="944fe-453">Per volumi di dati molto grandi (più di 1 TB), l'archiviazione di Azure offre il servizio di importazione/esportazione che consente di caricare e scaricare dall'archiviazione BLOB tramite l'invio di dischi rigidi.</span><span class="sxs-lookup"><span data-stu-id="944fe-453">For very large volumes of data (more than 1TB), the Azure Storage offers the Import/Export service, which allows for uploading and downloading from blob storage by shipping hard drives.</span></span>  <span data-ttu-id="944fe-454">È possibile inserire i dati in un disco rigido e inviarlo a Microsoft per il caricamento oppure inviare un disco rigido vuoto a Microsoft per scaricare i dati.</span><span class="sxs-lookup"><span data-stu-id="944fe-454">You can put your data on a hard drive and send it to Microsoft for upload, or send a blank hard drive to Microsoft to download data.</span></span>  <span data-ttu-id="944fe-455">Per altre informazioni, vedere [Usare il servizio di Importazione/Esportazione di Microsoft Azure per trasferire i dati nell'archiviazione BLOB](../storage-import-export-service.md).</span><span class="sxs-lookup"><span data-stu-id="944fe-455">For more information, see [Use the Microsoft Azure Import/Export Service to Transfer Data to Blob Storage](../storage-import-export-service.md).</span></span>  <span data-ttu-id="944fe-456">Questo metodo può risultare più efficace rispetto al caricamento/download di elevati volumi di dati tramite rete.</span><span class="sxs-lookup"><span data-stu-id="944fe-456">This can be much more efficient than uploading/downloading this volume of data over the network.</span></span>  

### <span data-ttu-id="944fe-457"><a name="subheading20"></a>Usare i metadati</span><span class="sxs-lookup"><span data-stu-id="944fe-457"><a name="subheading20"></a>Use metadata</span></span>
<span data-ttu-id="944fe-458">Il servizio BLOB supporta le richieste head che possono includere i metadati relativi al BLOB.</span><span class="sxs-lookup"><span data-stu-id="944fe-458">The blob service supports head requests, which can include metadata about the blob.</span></span> <span data-ttu-id="944fe-459">Ad esempio, se l'applicazione richiede i dati EXIF inclusi in una foto, può recuperare la foto ed estrarli.</span><span class="sxs-lookup"><span data-stu-id="944fe-459">For example, if your application needed the EXIF data out of a photo, it could retrieve the photo and extract it.</span></span> <span data-ttu-id="944fe-460">Per risparmiare larghezza di banda e migliorare le prestazioni, l'applicazione può archiviare i dati EXIF nei metadati del BLOB quando l'applicazione carica la foto. I dati EXIF possono essere poi recuperati nei metadati usando semplicemente una richiesta HEAD, risparmiando una notevole quantità di larghezza di banda e il tempo di elaborazione necessario a estrarre i dati EXIF a ogni lettura del BLOB.</span><span class="sxs-lookup"><span data-stu-id="944fe-460">To save bandwidth and improve performance, your application could store the EXIF data in the blob's metadata when the application uploaded the photo: you can then retrieve the EXIF data in metadata using only a HEAD request, saving significant bandwidth and the processing time needed to extract the EXIF data each time the blob is read.</span></span> <span data-ttu-id="944fe-461">Questa funzionalità è utile in scenari in cui sono necessari solo i metadati e non l'intero contenuto di un BLOB.</span><span class="sxs-lookup"><span data-stu-id="944fe-461">This would be useful in scenarios where you only need the metadata, and not the full content of a blob.</span></span>  <span data-ttu-id="944fe-462">È possibile archiviare solo 8 KB di metadati per BLOB (il servizio non accetta richieste per valori superiori), quindi se i dati superano queste dimensioni non sarà possibile usare questo approccio.</span><span class="sxs-lookup"><span data-stu-id="944fe-462">Note that only 8 KB of metadata can be stored per blob (the service will not accept a request to store more than that), so if the data does not fit in that size, you may not be able to use this approach.</span></span>  

<span data-ttu-id="944fe-463">Per un esempio di come recuperare i metadati di un BLOB con .NET, vedere [Impostare e recuperare proprietà e metadati](../blobs/storage-properties-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="944fe-463">For an example of how to get a blob's metadata using .NET, see [Set and Retrieve Properties and Metadata](../blobs/storage-properties-metadata.md).</span></span>  

### <a name="uploading-fast"></a><span data-ttu-id="944fe-464">Caricamento rapido</span><span class="sxs-lookup"><span data-stu-id="944fe-464">Uploading Fast</span></span>
<span data-ttu-id="944fe-465">Per caricare rapidamente i BLOB, è necessario definire se caricare un solo BLOB o più BLOB.</span><span class="sxs-lookup"><span data-stu-id="944fe-465">To upload blobs fast, the first question to answer is: are you uploading one blob or many?</span></span>  <span data-ttu-id="944fe-466">Usare le indicazioni seguenti per determinare il metodo corretto da usare a seconda dello scenario.</span><span class="sxs-lookup"><span data-stu-id="944fe-466">Use the below guidance to determine the correct method to use depending on your scenario.</span></span>  

#### <span data-ttu-id="944fe-467"><a name="subheading21"></a>Caricamento rapido di un BLOB di grandi dimensioni</span><span class="sxs-lookup"><span data-stu-id="944fe-467"><a name="subheading21"></a>Uploading one large blob quickly</span></span>
<span data-ttu-id="944fe-468">Per caricare rapidamente un singolo BLOB di grandi dimensioni, l'applicazione client deve caricare i blocchi o le pagine in parallelo (tenendo presenti gli obiettivi di scalabilità per i singoli BLOB e per l'intero account di archiviazione).</span><span class="sxs-lookup"><span data-stu-id="944fe-468">To upload a single large blob quickly, your client application should upload its blocks or pages in parallel (being mindful of the scalability targets for individual blobs and the storage account as a whole).</span></span>  <span data-ttu-id="944fe-469">Le librerie client di archiviazione RTM fornite da Microsoft (.NET, Java) includono questa funzionalità.</span><span class="sxs-lookup"><span data-stu-id="944fe-469">Note that the official Microsoft-provided RTM Storage Client libraries (.NET, Java) have the ability to do this.</span></span>  <span data-ttu-id="944fe-470">Per ciascuna libreria usare l'oggetto/proprietà specificato di seguito per impostare il livello di concorrenza:</span><span class="sxs-lookup"><span data-stu-id="944fe-470">For each of the libraries, use the below specified object/property to set the level of concurrency:</span></span>  

* <span data-ttu-id="944fe-471">.NET: Impostare ParallelOperationThreadCount in un oggetto BlobRequestOptions da usare.</span><span class="sxs-lookup"><span data-stu-id="944fe-471">.NET: Set ParallelOperationThreadCount on a BlobRequestOptions object to be used.</span></span>
* <span data-ttu-id="944fe-472">Java/Android: Usare BlobRequestOptions.setConcurrentRequestCount()</span><span class="sxs-lookup"><span data-stu-id="944fe-472">Java/Android: Use BlobRequestOptions.setConcurrentRequestCount()</span></span>
* <span data-ttu-id="944fe-473">Node.js: Usare parallelOperationThreadCount nelle opzioni della richiesta o nel servizio BLOB.</span><span class="sxs-lookup"><span data-stu-id="944fe-473">Node.js: Use parallelOperationThreadCount on either the request options or on the blob service.</span></span>
* <span data-ttu-id="944fe-474">C++: Usare il metodo blob_request_options::set_parallelism_factor.</span><span class="sxs-lookup"><span data-stu-id="944fe-474">C++: Use the blob_request_options::set_parallelism_factor method.</span></span>

#### <span data-ttu-id="944fe-475"><a name="subheading22"></a>Caricamento rapido di più BLOB</span><span class="sxs-lookup"><span data-stu-id="944fe-475"><a name="subheading22"></a>Uploading many blobs quickly</span></span>
<span data-ttu-id="944fe-476">Per caricare rapidamente più BLOB, caricarli in parallelo.</span><span class="sxs-lookup"><span data-stu-id="944fe-476">To upload many blobs quickly, upload blobs in parallel.</span></span> <span data-ttu-id="944fe-477">È una procedura più rapida rispetto al caricamento dei singoli BLOB con caricamenti di blocchi paralleli perché distribuisce il caricamento su più partizioni del servizio di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-477">This is faster than uploading single blobs at a time with parallel block uploads because it spreads the upload across multiple partitions of the storage service.</span></span> <span data-ttu-id="944fe-478">Un singolo BLOB supporta una velocità effettiva di soli 60 MB/secondo (circa 480 Mbps).</span><span class="sxs-lookup"><span data-stu-id="944fe-478">A single blob only supports a throughput of 60 MB/second (approximately 480 Mbps).</span></span> <span data-ttu-id="944fe-479">Al momento della redazione di questo documento, un account di archiviazione con ridondanza locale (LRS) basato negli Stati Uniti supporta fino a 20 Gbps in ingresso, un valore molto più alto della velocità effettiva supportata da un singolo BLOB.</span><span class="sxs-lookup"><span data-stu-id="944fe-479">At the time of writing, a US-based LRS account supports up to 20 Gbps ingress which is far more than the throughput supported by an individual blob.</span></span>  <span data-ttu-id="944fe-480">[AzCopy](#subheading18) esegue i caricamenti in parallelo per impostazione predefinita ed è consigliato per questo scenario.</span><span class="sxs-lookup"><span data-stu-id="944fe-480">[AzCopy](#subheading18) performs uploads in parallel by default, and is recommended for this scenario.</span></span>  

### <span data-ttu-id="944fe-481"><a name="subheading23"></a>Scelta del tipo di BLOB corretto</span><span class="sxs-lookup"><span data-stu-id="944fe-481"><a name="subheading23"></a>Choosing the correct type of blob</span></span>
<span data-ttu-id="944fe-482">Archiviazione di Azure supporta due tipi di BLOB: BLOB di *pagine* e BLOB in *blocchi*.</span><span class="sxs-lookup"><span data-stu-id="944fe-482">Azure Storage supports two types of blob: *page* blobs and *block* blobs.</span></span> <span data-ttu-id="944fe-483">Per un determinato scenario di utilizzo, la scelta del tipo di BLOB influisce sulle prestazioni e sulla scalabilità della soluzione.</span><span class="sxs-lookup"><span data-stu-id="944fe-483">For a given usage scenario, your choice of blob type will affect the performance and scalability of your solution.</span></span> <span data-ttu-id="944fe-484">I BLOB in blocchi sono appropriati quando si vogliono caricare grandi quantità di dati in modo efficace: ad esempio nel caso di un'applicazione client che necessita di caricare foto o video nell'archiviazione BLOB.</span><span class="sxs-lookup"><span data-stu-id="944fe-484">Block blobs are appropriate when you want to upload large amounts of data efficiently: for example, a client application may need to upload photos or video to blob storage.</span></span> <span data-ttu-id="944fe-485">I BLOB di pagine sono appropriati quando l'applicazione deve eseguire scritture casuali sui dati: ad esempio, i dischi rigidi virtuali di Azure vengono archiviati come BLOB di pagine.</span><span class="sxs-lookup"><span data-stu-id="944fe-485">Page blobs are appropriate if the application needs to perform random writes on the data: for example, Azure VHDs are stored as page blobs.</span></span>  

<span data-ttu-id="944fe-486">Per altre informazioni, vedere [Informazioni sui BLOB in blocchi, sui BLOB di aggiunta e sui BLOB di pagine](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span><span class="sxs-lookup"><span data-stu-id="944fe-486">For more information, see [Understanding Block Blobs, Append Blobs, and Page Blobs](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span></span>  

## <a name="tables"></a><span data-ttu-id="944fe-487">Tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-487">Tables</span></span>
<span data-ttu-id="944fe-488">Oltre alle procedure comprovate per [Tutti i servizi](#allservices) descritte prima, le seguenti procedure comprovate si applicano specificamente al servizio tabelle.</span><span class="sxs-lookup"><span data-stu-id="944fe-488">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the table service.</span></span>  

### <span data-ttu-id="944fe-489"><a name="subheading24"></a>Obiettivi di scalabilità specifici per tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-489"><a name="subheading24"></a>Table-Specific Scalability Targets</span></span>
<span data-ttu-id="944fe-490">Oltre ai limiti della larghezza di banda dell'intero account di archiviazione, le tabelle hanno il seguente limite di scalabilità.</span><span class="sxs-lookup"><span data-stu-id="944fe-490">In addition to the bandwidth limitations of an entire storage account, tables have the following specific scalability limit.</span></span>  <span data-ttu-id="944fe-491">Il sistema bilancia il carico man mano che il traffico aumenta, ma se si verificano incrementi improvvisi del traffico il volume della velocità effettiva potrebbe non essere raggiunto immediatamente.</span><span class="sxs-lookup"><span data-stu-id="944fe-491">Note that the system will load balance as your traffic increases, but if your traffic has sudden bursts, you may not be able to get this volume of throughput immediately.</span></span>  <span data-ttu-id="944fe-492">Se il modello presenta degli incrementi improvvisi è probabile che vengano visualizzai messaggi di limitazione e/o timeout durante l'incremento perché il servizio di archiviazione bilancia automaticamente il carico della tabella.</span><span class="sxs-lookup"><span data-stu-id="944fe-492">If your pattern has bursts, you should expect to see throttling and/or timeouts during the burst as the storage service automatically load balances out your table.</span></span>  <span data-ttu-id="944fe-493">Un incremento lento in genere produce risultati migliori perché lascia al sistema il tempo di bilanciare il carico in modo corretto.</span><span class="sxs-lookup"><span data-stu-id="944fe-493">Ramping up slowly generally has better results as it gives the system time to load balance appropriately.</span></span>  

#### <a name="entities-per-second-account"></a><span data-ttu-id="944fe-494">Entità al secondo (account)</span><span class="sxs-lookup"><span data-stu-id="944fe-494">Entities per Second (Account)</span></span>
<span data-ttu-id="944fe-495">Il limite di scalabilità per l'accesso alle tabelle è di 20.000 entità (1 KB ciascuna) al secondo per un account.</span><span class="sxs-lookup"><span data-stu-id="944fe-495">The scalability limit for accessing tables is up to 20,000 entities (1KB each) per second for an account.</span></span>  <span data-ttu-id="944fe-496">In generale ogni entità inserita, aggiornata, eliminata o analizzata viene presa in considerazione ai fini del calcolo per l'obiettivo.</span><span class="sxs-lookup"><span data-stu-id="944fe-496">In general, each entity that is inserted, updated, deleted, or scanned counts toward this target.</span></span>  <span data-ttu-id="944fe-497">Quindi, un inserimento batch che contiene 100 entità conta come 100 entità.</span><span class="sxs-lookup"><span data-stu-id="944fe-497">So a batch insert that contains 100 entities would count as 100 entities.</span></span>  <span data-ttu-id="944fe-498">Una query che analizza 1000 entità e ne restituisce 5 conta come 1000 entità.</span><span class="sxs-lookup"><span data-stu-id="944fe-498">A query that scans 1000 entities and returns 5 would count as 1000 entities.</span></span>  

#### <a name="entities-per-second-partition"></a><span data-ttu-id="944fe-499">Entità al secondo (partizione)</span><span class="sxs-lookup"><span data-stu-id="944fe-499">Entities per Second (Partition)</span></span>
<span data-ttu-id="944fe-500">In una singola partizione l'obiettivo di scalabilità per l'accesso alle tabelle è di 2.000 entità (1 KB ciascuna) al secondo, usando lo stesso conteggio descritto nella sezione precedente.</span><span class="sxs-lookup"><span data-stu-id="944fe-500">Within a single partition, the scalability target for accessing tables is 2,000 entities (1KB each) per second, using the same counting as described in the previous section.</span></span>  

### <a name="configuration"></a><span data-ttu-id="944fe-501">Configurazione</span><span class="sxs-lookup"><span data-stu-id="944fe-501">Configuration</span></span>
<span data-ttu-id="944fe-502">In questa sezione vengono elencate diverse impostazioni di configurazione rapide che è possibile usare per migliorare significativamente le prestazioni nel servizio tabelle:</span><span class="sxs-lookup"><span data-stu-id="944fe-502">This section lists several quick configuration settings that you can use to make significant performance improvements in the table service:</span></span>  

#### <span data-ttu-id="944fe-503"><a name="subheading25"></a>Usare JSON</span><span class="sxs-lookup"><span data-stu-id="944fe-503"><a name="subheading25"></a>Use JSON</span></span>
<span data-ttu-id="944fe-504">A partire dalla versione del servizio di archiviazione 2013-08-15, il servizio tabelle supporta l'uso di JSON al posto del formato AtomPub basato su XML per il trasferimento dei dati della tabella.</span><span class="sxs-lookup"><span data-stu-id="944fe-504">Beginning with storage service version 2013-08-15, the table service supports using JSON instead of the XML-based AtomPub format for transferring table data.</span></span> <span data-ttu-id="944fe-505">Ciò consente di ridurre le dimensioni del payload di una percentuale massima del 75% e può migliorare notevolmente le prestazioni dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-505">This can reduce payload sizes by as much as 75% and can significantly improve the performance of your application.</span></span>

<span data-ttu-id="944fe-506">Per altre informazioni, vedere il post [Microsoft Azure Tables: Introducing JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) (Tabelle di Microsoft Azure: introduzione a JSON) e [Payload Format for Table Service Operations](http://msdn.microsoft.com/library/azure/dn535600.aspx) (Formato di Payload per operazioni del servizio tabelle).</span><span class="sxs-lookup"><span data-stu-id="944fe-506">For more information, see the post [Microsoft Azure Tables: Introducing JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) and [Payload Format for Table Service Operations](http://msdn.microsoft.com/library/azure/dn535600.aspx).</span></span>

#### <span data-ttu-id="944fe-507"><a name="subheading26"></a>Disattivazione di Nagle</span><span class="sxs-lookup"><span data-stu-id="944fe-507"><a name="subheading26"></a>Nagle Off</span></span>
<span data-ttu-id="944fe-508">L'algoritmo Nagle viene spesso implementato nelle reti TCP/IP come strumento per migliorare le prestazioni di rete.</span><span class="sxs-lookup"><span data-stu-id="944fe-508">Nagle's algorithm is widely implemented across TCP/IP networks as a means to improve network performance.</span></span> <span data-ttu-id="944fe-509">Tuttavia, non è la soluzione ottimale in tutti gli scenari (ad esempio, gli ambienti ad alta interazione).</span><span class="sxs-lookup"><span data-stu-id="944fe-509">However, it is not optimal in all circumstances (such as highly interactive environments).</span></span> <span data-ttu-id="944fe-510">In Archiviazione di Azure l'algoritmo Nagle ha un impatto negativo sulle prestazioni delle richieste ai servizi tabelle e di accodamento e, se possibile, dovrebbe essere disabilitato.</span><span class="sxs-lookup"><span data-stu-id="944fe-510">For Azure Storage, Nagle's algorithm has a negative impact on the performance of requests to the table and queue services, and you should disable it if possible.</span></span>  

<span data-ttu-id="944fe-511">Per altre informazioni, vedere il post del blog relativo al [comportamento dell'algoritmo Nagle nei confronti delle piccole richieste](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx), che spiega il motivo per cui questo algoritmo interagisce in modo poco efficace con le richieste relative a tabelle e code e che mostra come disabilitarlo nell'applicazione client.</span><span class="sxs-lookup"><span data-stu-id="944fe-511">For more information, see our blog post [Nagle's Algorithm is Not Friendly towards Small Requests](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx), which explains why Nagle's algorithm interacts poorly with table and queue requests, and shows how to disable it in your client application.</span></span>  

### <a name="schema"></a><span data-ttu-id="944fe-512">Schema</span><span class="sxs-lookup"><span data-stu-id="944fe-512">Schema</span></span>
<span data-ttu-id="944fe-513">La modalità con cui vengono rappresentati i dati e vengono eseguite query su di essi è il fattore singolo più importante che influisce sulle prestazioni del servizio tabelle.</span><span class="sxs-lookup"><span data-stu-id="944fe-513">How you represent and query your data is the biggest single factor that affects the performance of the table service.</span></span> <span data-ttu-id="944fe-514">Ogni applicazione è diversa, ma in questa sezione vengono descritte alcune procedure comprovate generali relative a:</span><span class="sxs-lookup"><span data-stu-id="944fe-514">While every application is different, this section outlines some general proven practices that relate to:</span></span>  

* <span data-ttu-id="944fe-515">Progettazione della tabella</span><span class="sxs-lookup"><span data-stu-id="944fe-515">Table design</span></span>
* <span data-ttu-id="944fe-516">Query efficaci</span><span class="sxs-lookup"><span data-stu-id="944fe-516">Efficient queries</span></span>
* <span data-ttu-id="944fe-517">Aggiornamenti dei dati efficaci</span><span class="sxs-lookup"><span data-stu-id="944fe-517">Efficient data updates</span></span>  

#### <span data-ttu-id="944fe-518"><a name="subheading27"></a>Tabelle e partizioni</span><span class="sxs-lookup"><span data-stu-id="944fe-518"><a name="subheading27"></a>Tables and partitions</span></span>
<span data-ttu-id="944fe-519">Le tabella sono divise in partizioni.</span><span class="sxs-lookup"><span data-stu-id="944fe-519">Tables are divided into partitions.</span></span> <span data-ttu-id="944fe-520">Ogni entità archiviata in una partizione condivide la stessa chiave di partizione e dispone di una chiave di riga univoca che la identifica all'interno della partizione.</span><span class="sxs-lookup"><span data-stu-id="944fe-520">Every entity stored in a partition shares the same partition key and has a unique row key to identify it within that partition.</span></span> <span data-ttu-id="944fe-521">Le partizioni offrono dei vantaggi ma introducono anche dei limiti di scalabilità.</span><span class="sxs-lookup"><span data-stu-id="944fe-521">Partitions provide benefits but also introduce scalability limits.</span></span>  

* <span data-ttu-id="944fe-522">Benefici: È possibile aggiornare le entità nella stessa partizione in un'unica transazione batch atomica che contiene fino a 100 operazioni di archiviazione distinte (limite di 4 MB di dimensioni totali).</span><span class="sxs-lookup"><span data-stu-id="944fe-522">Benefits: You can update entities in the same partition in a single, atomic, batch transaction that contains up to 100 separate storage operations (limit of 4MB total size).</span></span> <span data-ttu-id="944fe-523">Presupponendo lo stesso numero di entità da recuperare, è anche possibile eseguire query sui dati all'interno di una singola partizione in modo più efficiente rispetto ai dati distribuiti in più partizioni (tuttavia, leggere più avanti per ulteriori consigli sulle query sui dati nelle tabelle).</span><span class="sxs-lookup"><span data-stu-id="944fe-523">Assuming the same number of entities to be retrieved, you can also query data within a single partition more efficiently than data that spans partitions (though read on for further recommendations on querying table data).</span></span>
* <span data-ttu-id="944fe-524">Limite di scalabilità: L'accesso alle entità archiviate in una singola partizione non può essere sottoposto a bilanciamento del carico perché le partizioni supportano le transazioni batch atomiche.</span><span class="sxs-lookup"><span data-stu-id="944fe-524">Scalability limit: Access to entities stored in a single partition cannot be load-balanced because partitions support atomic batch transactions.</span></span> <span data-ttu-id="944fe-525">Per questo motivo, l'obiettivo di scalabilità per una singola partizione della tabella è inferiore rispetto a quello dell'intero servizio tabelle.</span><span class="sxs-lookup"><span data-stu-id="944fe-525">For this reason, the scalability target for an individual table partition is lower than for the table service as a whole.</span></span>  

<span data-ttu-id="944fe-526">Tenendo conto delle caratteristiche descritte di tabelle e partizioni, adottare i seguenti principi di progettazione:</span><span class="sxs-lookup"><span data-stu-id="944fe-526">Because of these characteristics of tables and partitions, you should adopt the following design principles:</span></span>  

* <span data-ttu-id="944fe-527">I dati aggiornati o su cui vengono eseguite query più di frequente da parte dell'applicazione client nella stessa unità logica di lavoro devono trovarsi nella stessa partizione.</span><span class="sxs-lookup"><span data-stu-id="944fe-527">Data that your client application frequently updated or queried in the same logical unit of work should be located in the same partition.</span></span>  <span data-ttu-id="944fe-528">Questo perché l'applicazione sta aggregando le scritture oppure perché l'utente vuole usare le operazioni batch atomiche.</span><span class="sxs-lookup"><span data-stu-id="944fe-528">This may be because your application is aggregating writes, or because you want to take advantage of atomic batch operations.</span></span>  <span data-ttu-id="944fe-529">Inoltre, le query sui dati in una singola partizione possono essere eseguite in modo più efficace con un'unica query rispetto a quelle sui dati in più partizioni.</span><span class="sxs-lookup"><span data-stu-id="944fe-529">Also, data in a single partition can be more efficiently queried in a single query than data across partitions.</span></span>
* <span data-ttu-id="944fe-530">I dati che l'applicazione client non inserisce/aggiorna o di cui non esegue query nella stessa unità logica di lavoro (query singola o aggiornamento batch) devono essere posizionati in partizioni separate.</span><span class="sxs-lookup"><span data-stu-id="944fe-530">Data that your client application does not insert/update or query in the same logical unit of work (single query or batch update) should be located in separate partitions.</span></span>  <span data-ttu-id="944fe-531">È importante notare che non esiste un limite al numero di chiavi di partizione in una singola tabella, quindi l'esistenza di milioni di chiavi di partizione non rappresenta un problema e non influisce sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="944fe-531">One important note is that there is no limit to the number of partition keys in a single table, so having millions of partition keys is not a problem and will not impact performance.</span></span>  <span data-ttu-id="944fe-532">Ad esempio, se l'applicazione è un sito Web diffuso con accesso utente, l'uso dell'ID utente come chiave di partizione potrebbe rappresentare una buona scelta.</span><span class="sxs-lookup"><span data-stu-id="944fe-532">For example, if your application is a popular website with user login, using the User Id as the partition key could be a good choice.</span></span>  

#### <a name="hot-partitions"></a><span data-ttu-id="944fe-533">Partizioni critiche</span><span class="sxs-lookup"><span data-stu-id="944fe-533">Hot Partitions</span></span>
<span data-ttu-id="944fe-534">Una partizione critica riceve una percentuale sproporzionata del traffico di un account e non è possibile sottoporla a bilanciamento del carico perché è una partizione singola.</span><span class="sxs-lookup"><span data-stu-id="944fe-534">A hot partition is one that is receiving a disproportionate percentage of the traffic to an account, and cannot be load balanced because it is a single partition.</span></span>  <span data-ttu-id="944fe-535">In generale, le partizioni critiche vengono create in uno di questi due modi:</span><span class="sxs-lookup"><span data-stu-id="944fe-535">In general, hot partitions are created one of two ways:</span></span>  

##### <span data-ttu-id="944fe-536"><a name="subheading28"></a>Modelli Solo accodamenti e Solo anteposizioni</span><span class="sxs-lookup"><span data-stu-id="944fe-536"><a name="subheading28"></a>Append Only and Prepend Only patterns</span></span>
<span data-ttu-id="944fe-537">In un modello "Solo accodamenti" tutto (o quasi tutto) il traffico verso un determinato PK aumenta o diminuisce in base all'ora corrente.</span><span class="sxs-lookup"><span data-stu-id="944fe-537">The "Append Only" pattern is one where all (or nearly all) of the traffic to a given PK increases and decreases according to the current time.</span></span>  <span data-ttu-id="944fe-538">Un esempio è quello dell'applicazione che usa la data corrente come chiave di partizione per i dati di log.</span><span class="sxs-lookup"><span data-stu-id="944fe-538">An example is if your application used the current date as a partition key for log data.</span></span>  <span data-ttu-id="944fe-539">Ciò comporta che tutti gli inserimenti vanno nell'ultima partizione della tabella e il sistema non riesce a bilanciare il carico perché tutte le scritture si trovano alla fine della tabella.</span><span class="sxs-lookup"><span data-stu-id="944fe-539">This results in all of the inserts going to the last partition in your table, and the system cannot load balance because all of the writes are going to the end of your table.</span></span>  <span data-ttu-id="944fe-540">Se il volume di traffico verso la partizione supera l'obiettivo di scalabilità a livello della partizione viene generata una limitazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-540">If the volume of traffic to that partition exceeds the partition-level scalability target, then it will result in throttling.</span></span>  <span data-ttu-id="944fe-541">È opportuno assicurarsi che il traffico sia inviato a più partizioni per abilitare il bilanciamento del carico delle richieste nella tabella.</span><span class="sxs-lookup"><span data-stu-id="944fe-541">It's better to ensure that traffic is sent to multiple partitions, to enable load balance the requests across your table.</span></span>  

##### <span data-ttu-id="944fe-542"><a name="subheading29"></a>Dati con traffico elevato</span><span class="sxs-lookup"><span data-stu-id="944fe-542"><a name="subheading29"></a>High-Traffic Data</span></span>
<span data-ttu-id="944fe-543">Se lo schema di partizionamento produce una singola partizione con dati molto più usati rispetto alle altre partizioni, può essere generata una limitazione man mano che la partizione raggiunge l'obiettivo di scalabilità per una singola partizione.</span><span class="sxs-lookup"><span data-stu-id="944fe-543">If your partitioning scheme results in a single partition that just has data that is far more used than other partitions, you may also see throttling as that partition approaches the scalability target for a single partition.</span></span>  <span data-ttu-id="944fe-544">È opportuno verificare che lo schema di partizione non generi partizioni singole che raggiungono gli obiettivi di scalabilità.</span><span class="sxs-lookup"><span data-stu-id="944fe-544">It's better to make sure that your partition scheme results in no single partition approaching the scalability targets.</span></span>  

#### <a name="querying"></a><span data-ttu-id="944fe-545">Query</span><span class="sxs-lookup"><span data-stu-id="944fe-545">Querying</span></span>
<span data-ttu-id="944fe-546">Questa sezione descrive le procedure comprovate per le eseguire query nel servizio tabelle.</span><span class="sxs-lookup"><span data-stu-id="944fe-546">This section describes proven practices for querying the table service.</span></span>  

##### <span data-ttu-id="944fe-547"><a name="subheading30"></a>Ambito delle query</span><span class="sxs-lookup"><span data-stu-id="944fe-547"><a name="subheading30"></a>Query Scope</span></span>
<span data-ttu-id="944fe-548">Esistono diversi metodi per specificare l'intervallo di entità su cui eseguire query.</span><span class="sxs-lookup"><span data-stu-id="944fe-548">There are several ways to specify the range of entities to query.</span></span>  <span data-ttu-id="944fe-549">Di seguito viene descritto l'uso di ciascun metodo.</span><span class="sxs-lookup"><span data-stu-id="944fe-549">The following is a discussion of the uses of each.</span></span>  

<span data-ttu-id="944fe-550">Come regola generale, si consiglia di evitare le analisi (query più grandi di una singola entità), ma, se sono necessarie, provare a organizzare i dati in modo che le analisi recuperino i dati necessari senza analizzare o restituire grandi quantità di entità non necessarie.</span><span class="sxs-lookup"><span data-stu-id="944fe-550">In general, avoid scans (queries larger than a single entity), but if you must scan, try to organize your data so that your scans retrieve the data you need without scanning or returning significant amounts of entities you don't need.</span></span>  

###### <a name="point-queries"></a><span data-ttu-id="944fe-551">Query di tipo punto</span><span class="sxs-lookup"><span data-stu-id="944fe-551">Point Queries</span></span>
<span data-ttu-id="944fe-552">Una query di tipo punto recupera esattamente un'entità.</span><span class="sxs-lookup"><span data-stu-id="944fe-552">A point query retrieves exactly one entity.</span></span> <span data-ttu-id="944fe-553">Per farlo specifica sia la chiave di partizione che la chiave di riga dell'entità da recuperare.</span><span class="sxs-lookup"><span data-stu-id="944fe-553">It does this by specifying both the partition key and row key of the entity to retrieve.</span></span> <span data-ttu-id="944fe-554">Queste query sono molto efficaci e vanno usate quando possibile.</span><span class="sxs-lookup"><span data-stu-id="944fe-554">These queries are very efficient, and you should use them wherever possible.</span></span>  

###### <a name="partition-queries"></a><span data-ttu-id="944fe-555">Query sulle partizioni</span><span class="sxs-lookup"><span data-stu-id="944fe-555">Partition Queries</span></span>
<span data-ttu-id="944fe-556">Una query sulle partizioni recupera un set di dati che condivide una chiave di partizione comune.</span><span class="sxs-lookup"><span data-stu-id="944fe-556">A partition query is a query that retrieves a set of data that shares a common partition key.</span></span> <span data-ttu-id="944fe-557">In genere la query specifica un intervallo di valori della chiave di riga o un intervallo di valori relativi a una proprietà dell'entità, oltre alla chiave di partizione.</span><span class="sxs-lookup"><span data-stu-id="944fe-557">Typically, the query specifies a range of row key values or a range of values for some entity property in addition to a partition key.</span></span> <span data-ttu-id="944fe-558">Queste query sono meno efficaci delle query di tipo punto e devono essere usate in casi limitati.</span><span class="sxs-lookup"><span data-stu-id="944fe-558">These are less efficient than point queries, and should be used sparingly.</span></span>  

###### <a name="table-queries"></a><span data-ttu-id="944fe-559">Query sulle tabelle</span><span class="sxs-lookup"><span data-stu-id="944fe-559">Table Queries</span></span>
<span data-ttu-id="944fe-560">Una query sulle tabelle recupera un set di entità che non condivide una chiave di partizione comune.</span><span class="sxs-lookup"><span data-stu-id="944fe-560">A table query is a query that retrieves a set of entities that does not share a common partition key.</span></span> <span data-ttu-id="944fe-561">Queste query non sono efficaci e, se possibile, vanno evitate.</span><span class="sxs-lookup"><span data-stu-id="944fe-561">These queries are not efficient and you should avoid them if possible.</span></span>  

##### <span data-ttu-id="944fe-562"><a name="subheading31"></a>Densità delle query</span><span class="sxs-lookup"><span data-stu-id="944fe-562"><a name="subheading31"></a>Query Density</span></span>
<span data-ttu-id="944fe-563">Un altro fattore importante in termini di efficacia delle query è il numero di entità restituite rispetto al numero di entità analizzate per trovare il set restituito.</span><span class="sxs-lookup"><span data-stu-id="944fe-563">Another key factor in query efficiency is the number of entities returned as compared to the number of entities scanned to find the returned set.</span></span> <span data-ttu-id="944fe-564">Se l'applicazione esegue una query sulle tabelle con un filtro per un valore della proprietà condiviso solo dall'1% dei dati, la query analizza 100 entità per ciascuna entità restituita.</span><span class="sxs-lookup"><span data-stu-id="944fe-564">If your application performs a table query with a filter for a property value that only 1% of the data shares, the query will scan 100 entities for every one entity it returns.</span></span> <span data-ttu-id="944fe-565">Gli obiettivi di scalabilità della tabella descritti in precedenza fanno tutti riferimento al numero di entità analizzate e non al numero di entità restituite: è probabile che una densità delle query bassa produca una limitazione dell'applicazione nel servizio tabelle perché devono essere analizzate troppe entità per recuperare quella cercata.</span><span class="sxs-lookup"><span data-stu-id="944fe-565">The table scalability targets discussed previously all relate to the number of entities scanned, and not the number of entities returned: a low query density can easily cause the table service to throttle your application because it must scan so many entities to retrieve the entity you are looking for.</span></span>  <span data-ttu-id="944fe-566">Vedere la sezione seguente sulla [denormalizzazione](#subheading34) per altre informazioni su come evitare il problema.</span><span class="sxs-lookup"><span data-stu-id="944fe-566">See the section below on [denormalization](#subheading34) for more information on how to avoid this.</span></span>  

##### <a name="limiting-the-amount-of-data-returned"></a><span data-ttu-id="944fe-567">Limitazione della quantità di dati restituiti</span><span class="sxs-lookup"><span data-stu-id="944fe-567">Limiting the Amount of Data Returned</span></span>
###### <span data-ttu-id="944fe-568"><a name="subheading32"></a>Filtri</span><span class="sxs-lookup"><span data-stu-id="944fe-568"><a name="subheading32"></a>Filtering</span></span>
<span data-ttu-id="944fe-569">Se si prevede che una query restituisca entità non necessarie nell'applicazione client, valutare l'uso di un filtro per ridurre le dimensioni del set restituito.</span><span class="sxs-lookup"><span data-stu-id="944fe-569">Where you know that a query will return entities that you don't need in the client application, consider using a filter to reduce the size of the returned set.</span></span> <span data-ttu-id="944fe-570">Le entità non restituite al client vengono comunque considerate per il calcolo dei limiti di scalabilità, ma le prestazioni dell'applicazione migliorano grazie alle minori dimensioni del payload di rete e al numero ridotto di entità che l'applicazione client deve elaborare.</span><span class="sxs-lookup"><span data-stu-id="944fe-570">While the entities not returned to the client still count toward the scalability limits, your application performance will improve because of the reduced network payload size and the reduced number of entities that your client application must process.</span></span>  <span data-ttu-id="944fe-571">Tuttavia, anche qui si applica la nota precedente sulla [Densità delle query](#subheading31): gli obiettivi di scalabilità fanno riferimento al numero di entità analizzate quindi una query che esclude molte entità può comunque produrre una limitazione, anche se vengono restituite poche entità.</span><span class="sxs-lookup"><span data-stu-id="944fe-571">See above note on [Query Density](#subheading31), however – the scalability targets relate to the number of entities scanned, so a query that filters out many entities may still result in throttling, even if few entities are returned.</span></span>  

###### <span data-ttu-id="944fe-572"><a name="subheading33"></a>Proiezione</span><span class="sxs-lookup"><span data-stu-id="944fe-572"><a name="subheading33"></a>Projection</span></span>
<span data-ttu-id="944fe-573">Se l'applicazione client necessita solo di un set di proprietà limitato dall'entità nella tabella, è possibile usare la proiezione per limitare le dimensioni del set di dati restituito.</span><span class="sxs-lookup"><span data-stu-id="944fe-573">If your client application needs only a limited set of properties from the entities in your table, you can use projection to limit the size of the returned data set.</span></span> <span data-ttu-id="944fe-574">Come nel caso dei filtri, questa funzionalità consente di ridurre il carico di rete e l'elaborazione del client.</span><span class="sxs-lookup"><span data-stu-id="944fe-574">As with filtering, this helps to reduce network load and client processing.</span></span>  

##### <span data-ttu-id="944fe-575"><a name="subheading34"></a>Denormalizzazione</span><span class="sxs-lookup"><span data-stu-id="944fe-575"><a name="subheading34"></a>Denormalization</span></span>
<span data-ttu-id="944fe-576">A differenza dell'uso dei database relazionali, le procedure comprovate per l'esecuzione di query efficaci sui dati della tabella portano alla denormalizzazione dei dati.</span><span class="sxs-lookup"><span data-stu-id="944fe-576">Unlike working with relational databases, the proven practices for efficiently querying table data lead to denormalizing your data.</span></span> <span data-ttu-id="944fe-577">In altre parole, invece di analizzare numeri elevati di entità per individuare i dati richiesti dall'applicazione, vengono duplicati gli stessi dati in più entità (una per ogni chiave usata per trovare i dati) per ridurre il numero di entità che una query deve analizzare per trovare i dati richiesti dal client.</span><span class="sxs-lookup"><span data-stu-id="944fe-577">That is, duplicating the same data in multiple entities (one for each key you may use to find the data) to minimize the number of entities that a query must scan to find the data the client needs, rather than having to scan large numbers of entities to find the data your application needs.</span></span>  <span data-ttu-id="944fe-578">In un sito Web di e-commerce è possibile, ad esempio, cercare un ordine in base all'ID cliente (ricerca degli ordini dello specifico cliente) e alla data (ricerca degli ordini con una specifica data).</span><span class="sxs-lookup"><span data-stu-id="944fe-578">For example, in an e-commerce website, you may want to find an order both by the customer ID (give me this customer's orders) and by the date (give me orders on a date).</span></span>  <span data-ttu-id="944fe-579">Nell'archiviazione tabelle si consiglia di archiviare l'entità (o un riferimento all'entità) due volte: una con nome tabella, PK e RK per semplificare la ricerca in base all'ID cliente e una per semplificare la ricerca in base alla data.</span><span class="sxs-lookup"><span data-stu-id="944fe-579">In Table Storage, it is best to store the entity (or a reference to it) twice – once with Table Name, PK, and RK to facilitate finding by customer ID, once to facilitate finding it by the date.</span></span>  

#### <a name="insertupdatedelete"></a><span data-ttu-id="944fe-580">Inserimento/aggiornamento/eliminazione</span><span class="sxs-lookup"><span data-stu-id="944fe-580">Insert/Update/Delete</span></span>
<span data-ttu-id="944fe-581">Questa sezione descrive le procedure comprovate per modificare le entità archiviate nel servizio tabelle.</span><span class="sxs-lookup"><span data-stu-id="944fe-581">This section describes proven practices for modifying entities stored in the table service.</span></span>  

##### <span data-ttu-id="944fe-582"><a name="subheading35"></a>Creazione di batch</span><span class="sxs-lookup"><span data-stu-id="944fe-582"><a name="subheading35"></a>Batching</span></span>
<span data-ttu-id="944fe-583">Le transazioni batch sono note come transazioni dei gruppi di entità (ETG, Entity Group Transaction) nell'archiviazione di Azure; tutte le operazioni all'interno di un'ETG devono essere su una singola partizione in una tabella singola.</span><span class="sxs-lookup"><span data-stu-id="944fe-583">Batch transactions are known as Entity Group Transactions (ETG) in Azure Storage; all the operations within an ETG must be on a single partition in a single table.</span></span> <span data-ttu-id="944fe-584">Dove possibile, usare le ETG per eseguire inserimenti, aggiornamenti ed eliminazioni in batch.</span><span class="sxs-lookup"><span data-stu-id="944fe-584">Where possible, use ETGs to perform inserts, updates, and deletes in batches.</span></span> <span data-ttu-id="944fe-585">In questo modo si riduce il numero di round trip dall'applicazione client al server, si limita il numero di transazioni fatturabili (un'ETG conta come una singola transazione ai fini della fatturazione e può contenere fino a 100 operazioni di archiviazione) e si abilitano gli aggiornamenti atomici (l'esito positivo o negativo di un processo si applica a tutte le operazioni all'interno dell'ETG).</span><span class="sxs-lookup"><span data-stu-id="944fe-585">This reduces the number of round trips from your client application to the server, reduces the number of billable transactions (an ETG counts as a single transaction for billing purposes and can contain up to 100 storage operations), and enables atomic updates (all operations succeed or all fail within an ETG).</span></span> <span data-ttu-id="944fe-586">Gli ambienti con latenze elevate come i dispositivi mobili possono trarre grandi vantaggi dall'uso delle ETG.</span><span class="sxs-lookup"><span data-stu-id="944fe-586">Environments with high latencies such as mobile devices will benefit greatly from using ETGs.</span></span>  

##### <span data-ttu-id="944fe-587"><a name="subheading36"></a>Upsert</span><span class="sxs-lookup"><span data-stu-id="944fe-587"><a name="subheading36"></a>Upsert</span></span>
<span data-ttu-id="944fe-588">Usare le operazioni della tabella **Upsert** quando possibile.</span><span class="sxs-lookup"><span data-stu-id="944fe-588">Use table **Upsert** operations wherever possible.</span></span> <span data-ttu-id="944fe-589">Esistono due tipi di **Upsert**, entrambi più efficaci di una tradizionale operazione di **inserimento** e **aggiornamento**:</span><span class="sxs-lookup"><span data-stu-id="944fe-589">There are two types of **Upsert**, both of which can be more efficient than a traditional **Insert** and **Update** operations:</span></span>  

* <span data-ttu-id="944fe-590">**InsertOrMerge**: da usare quando si vuole caricare un subset di proprietà dell'entità, ma non si è certi che l'entità esista già.</span><span class="sxs-lookup"><span data-stu-id="944fe-590">**InsertOrMerge**: Use this when you want to upload a subset of the entity's properties, but aren't sure whether the entity already exists.</span></span> <span data-ttu-id="944fe-591">Se l'entità esiste, questa chiamata aggiorna le proprietà incluse nell'operazione **Upsert** e lascia inalterate tutte le proprietà esistenti; se l'entità non esiste, ne inserisce una nuova.</span><span class="sxs-lookup"><span data-stu-id="944fe-591">If the entity exists, this call updates the properties included in the **Upsert** operation, and leaves all existing properties as they are, if the entity does not exist, it inserts the new entity.</span></span> <span data-ttu-id="944fe-592">La procedura è analoga all'uso della proiezione in una query perché è necessario caricare solo le proprietà modificate.</span><span class="sxs-lookup"><span data-stu-id="944fe-592">This is similar to using projection in a query, in that you only need to upload the properties that are changing.</span></span>
* <span data-ttu-id="944fe-593">**InsertOrReplace**: da usare quando si vuole caricare un'entità completamente nuova, ma non si è certi se l'entità esista già.</span><span class="sxs-lookup"><span data-stu-id="944fe-593">**InsertOrReplace**: Use this when you want to upload an entirely new entity, but you aren't sure whether it already exists.</span></span> <span data-ttu-id="944fe-594">Va usato solo se si è certi che l'entità appena caricata è corretta perché questa sovrascrive completamente l'entità esistente.</span><span class="sxs-lookup"><span data-stu-id="944fe-594">You should only use this when you know that the newly uploaded entity is entirely correct because it completely overwrites the old entity.</span></span> <span data-ttu-id="944fe-595">Si vuole ad esempio aggiornare l'entità in cui è archiviata la posizione corrente di un utente indipendentemente dal fatto che l'applicazione abbia o meno archiviato in precedenza dati sulla posizione dell'utente. La nuova entità di posizione è completa e non occorrono altre informazioni da entità precedenti.</span><span class="sxs-lookup"><span data-stu-id="944fe-595">For example, you want to update the entity that stores a user's current location regardless of whether or not the application has previously stored location data for the user; the new location entity is complete, and you do not need any information from any previous entity.</span></span>

##### <span data-ttu-id="944fe-596"><a name="subheading37"></a>Archiviazione di serie di dati in una singola entità</span><span class="sxs-lookup"><span data-stu-id="944fe-596"><a name="subheading37"></a>Storing Data Series in a Single Entity</span></span>
<span data-ttu-id="944fe-597">A volte un'applicazione archivia una serie di dati richiesti di frequente per recuperarli tutti simultaneamente: ad esempio, un'applicazione può tenere traccia dell'utilizzo della CPU nel tempo per tracciare un grafico in sequenza dei dati relativo alle ultime 24 ore.</span><span class="sxs-lookup"><span data-stu-id="944fe-597">Sometimes, an application stores a series of data that it frequently needs to retrieve all at once: for example, an application might track CPU usage over time in order to plot a rolling chart of the data from the last 24 hours.</span></span> <span data-ttu-id="944fe-598">Un approccio prevede un'entità di tabella all'ora, in cui ogni entità rappresenta un'ora specifica e archivia l'utilizzo della CPU per quell'ora.</span><span class="sxs-lookup"><span data-stu-id="944fe-598">One approach is to have one table entity per hour, with each entity representing a specific hour and storing the CPU usage for that hour.</span></span> <span data-ttu-id="944fe-599">Per tracciare questi dati, l'applicazione deve recuperare le entità che comprendono i dati delle ultime 24 ore.</span><span class="sxs-lookup"><span data-stu-id="944fe-599">To plot this data, the application needs to retrieve the entities holding the data from the 24 most recent hours.</span></span>  

<span data-ttu-id="944fe-600">In alternativa, l'applicazione può archiviare l'utilizzo della CPU per ciascuna ora sotto forma di proprietà separata di una singola entità: per aggiornare le singole ore, l'applicazione può usare una singola chiamata **InsertOrMerge Upsert** per aggiornare il valore per l'ora più recente.</span><span class="sxs-lookup"><span data-stu-id="944fe-600">Alternatively, your application could store the CPU usage for each hour as a separate property of a single entity: to update each hour, your application can use a single **InsertOrMerge Upsert** call to update the value for the most recent hour.</span></span> <span data-ttu-id="944fe-601">Per tracciare i dati, l'applicazione deve recuperare solo una singola entità invece di 24, aumentando l'efficacia della query (vedere la discussione precedente sull' [ambito delle query](#subheading30)).</span><span class="sxs-lookup"><span data-stu-id="944fe-601">To plot the data, the application only needs to retrieve a single entity instead of 24, making for a very efficient query (see above discussion on [query scope](#subheading30)).</span></span>

##### <span data-ttu-id="944fe-602"><a name="subheading38"></a>Archiviazione di dati strutturati in BLOB</span><span class="sxs-lookup"><span data-stu-id="944fe-602"><a name="subheading38"></a>Storing structured data in blobs</span></span>
<span data-ttu-id="944fe-603">A volte sembra che i dati strutturati debbano essere inseriti nelle tabelle, tuttavia gli intervalli delle entità vengono sempre recuperati insieme e possono essere inseriti in batch.</span><span class="sxs-lookup"><span data-stu-id="944fe-603">Sometimes structured data feels like it should go in tables, but ranges of entities are always retrieved together and can be batch inserted.</span></span>  <span data-ttu-id="944fe-604">Per spiegarlo efficacemente, si prenda l'esempio di un file di log.</span><span class="sxs-lookup"><span data-stu-id="944fe-604">A good example of this is a log file.</span></span>  <span data-ttu-id="944fe-605">In questo caso è possibile creare in batch e inserire diversi minuti di log. Questi minuti di log vengono anche recuperati tutti in una volta.</span><span class="sxs-lookup"><span data-stu-id="944fe-605">In this case, you can batch several minutes of logs, insert them, and then you are always retrieving several minutes of logs at a time as well.</span></span>  <span data-ttu-id="944fe-606">Per motivi di prestazioni, si consiglia in questo caso di usare i BLOB invece delle tabelle perché consentono di ridurre significativamente il numero di oggetti scritti/restituiti e, di solito, anche il numero di richieste che occorre effettuare.</span><span class="sxs-lookup"><span data-stu-id="944fe-606">In this case, for performance, it's better to use blobs instead of tables, since you can significantly reduce the number of objects written/returned, as well as usually the number of requests that need made.</span></span>  

## <a name="queues"></a><span data-ttu-id="944fe-607">Code</span><span class="sxs-lookup"><span data-stu-id="944fe-607">Queues</span></span>
<span data-ttu-id="944fe-608">Oltre alle procedure comprovate per [tutti i servizi](#allservices) descritte prima, le procedure comprovate seguenti si applicano specificamente al servizio di accodamento.</span><span class="sxs-lookup"><span data-stu-id="944fe-608">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the queue service.</span></span>  

### <span data-ttu-id="944fe-609"><a name="subheading39"></a>Limiti di scalabilità</span><span class="sxs-lookup"><span data-stu-id="944fe-609"><a name="subheading39"></a>Scalability Limits</span></span>
<span data-ttu-id="944fe-610">Una singola coda può elaborare circa 2000 messaggi (da 1 KB ciascuno) al secondo (in questo caso, i metodi AddMessage, GetMessage e DeleteMessage vengono considerati come singoli messaggi).</span><span class="sxs-lookup"><span data-stu-id="944fe-610">A single queue can process approximately 2,000 messages (1KB each) per second (each AddMessage, GetMessage, and DeleteMessage count as a message here).</span></span> <span data-ttu-id="944fe-611">Se questo non è sufficiente per l'applicazione, è consigliabile usare più code e distribuire i messaggi fra di esse.</span><span class="sxs-lookup"><span data-stu-id="944fe-611">If this is insufficient for your application, you should use multiple queues and spread the messages across them.</span></span>  

<span data-ttu-id="944fe-612">È possibile visualizzare gli obiettivi di scalabilità correnti nella pagina [Obiettivi di scalabilità e prestazioni di archiviazione Azure](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="944fe-612">View current scalability targets at [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <span data-ttu-id="944fe-613"><a name="subheading40"></a>Disattivazione di Nagle</span><span class="sxs-lookup"><span data-stu-id="944fe-613"><a name="subheading40"></a>Nagle Off</span></span>
<span data-ttu-id="944fe-614">Vedere la sezione nella configurazione della tabella che descrive l'algoritmo Nagle. Questo algoritmo in genere ha un effetto negativo sulle prestazioni delle richieste relative alle code ed è opportuno disabilitarlo.</span><span class="sxs-lookup"><span data-stu-id="944fe-614">See the section on table configuration that discusses the Nagle algorithm — the Nagle algorithm is generally bad for the performance of queue requests, and you should disable it.</span></span>  

### <span data-ttu-id="944fe-615"><a name="subheading41"></a>Dimensioni del messaggio</span><span class="sxs-lookup"><span data-stu-id="944fe-615"><a name="subheading41"></a>Message Size</span></span>
<span data-ttu-id="944fe-616">Le prestazioni e la scalabilità della coda diminuiscono con l'aumentare delle dimensioni del messaggio.</span><span class="sxs-lookup"><span data-stu-id="944fe-616">Queue performance and scalability decreases as message size increases.</span></span> <span data-ttu-id="944fe-617">In un messaggio è consigliabile inserire solo le informazioni richieste dal ricevitore.</span><span class="sxs-lookup"><span data-stu-id="944fe-617">You should place only the information the receiver needs in a message.</span></span>  

### <span data-ttu-id="944fe-618"><a name="subheading42"></a>Recupero in batch</span><span class="sxs-lookup"><span data-stu-id="944fe-618"><a name="subheading42"></a>Batch Retrieval</span></span>
<span data-ttu-id="944fe-619">È possibile recuperare fino a 32 messaggi da una coda in una singola operazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-619">You can retrieve up to 32 messages from a queue in a single operation.</span></span> <span data-ttu-id="944fe-620">Questo può ridurre il numero di round trip dall'applicazione client, particolarmente utile per gli ambienti con latenza elevata, come i dispositivi mobili.</span><span class="sxs-lookup"><span data-stu-id="944fe-620">This can reduce the number of roundtrips from the client application, which is especially useful for environments, such as mobile devices, with high latency.</span></span>  

### <span data-ttu-id="944fe-621"><a name="subheading43"></a>Intervallo di polling della coda</span><span class="sxs-lookup"><span data-stu-id="944fe-621"><a name="subheading43"></a>Queue Polling Interval</span></span>
<span data-ttu-id="944fe-622">La maggior parte delle applicazioni esegue il polling dei messaggi da una coda, che può costituire una delle principali origini di transazioni per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-622">Most applications poll for messages from a queue, which can be one of the largest sources of transactions for that application.</span></span> <span data-ttu-id="944fe-623">L'intervallo di polling deve essere scelto con attenzione: se si esegue il polling con eccessiva frequenza, l'applicazione potrebbe avvicinarsi all'obiettivo di scalabilità per la coda.</span><span class="sxs-lookup"><span data-stu-id="944fe-623">Select your polling interval wisely: polling too frequently could cause your application to approach the scalability targets for the queue.</span></span> <span data-ttu-id="944fe-624">Tuttavia, al prezzo di 0,01 USD per 200.000 transazioni (al momento della stesura di questo documento), il costo del polling eseguito da un singolo processore una volta al secondo per un intero mese non supererebbe 15 centesimi. Il costo non è dunque un fattore determinante nella scelta dell'intervallo di polling.</span><span class="sxs-lookup"><span data-stu-id="944fe-624">However, at 200,000 transactions for $0.01 (at the time of writing), a single processor polling once every second for a month would cost less than 15 cents so cost is not typically a factor that affects your choice of polling interval.</span></span>  

<span data-ttu-id="944fe-625">Per informazioni aggiornate sui costi, vedere [Prezzi di Archiviazione di Azure](https://azure.microsoft.com/pricing/details/storage/).</span><span class="sxs-lookup"><span data-stu-id="944fe-625">For up-to-date cost information, see [Azure Storage Pricing](https://azure.microsoft.com/pricing/details/storage/).</span></span>  

### <span data-ttu-id="944fe-626"><a name="subheading44"></a>UpdateMessage</span><span class="sxs-lookup"><span data-stu-id="944fe-626"><a name="subheading44"></a>UpdateMessage</span></span>
<span data-ttu-id="944fe-627">È possibile usare **UpdateMessage** per aumentare il timeout di invisibilità o aggiornare le informazioni di stato di un messaggio.</span><span class="sxs-lookup"><span data-stu-id="944fe-627">You can use **UpdateMessage** to increase the invisibility timeout or to update state information of a message.</span></span> <span data-ttu-id="944fe-628">Si tratta di una funzionalità potente, ma occorre ricordare che ogni operazione **UpdateMessage** viene presa in considerazione per il calcolo dell'obiettivo di scalabilità.</span><span class="sxs-lookup"><span data-stu-id="944fe-628">While this is powerful, remember that each **UpdateMessage** operation counts towards the scalability target.</span></span> <span data-ttu-id="944fe-629">Tuttavia, può essere un approccio più efficace rispetto al passaggio di un processo da una coda alla successiva mediante un flusso di lavoro man mano che i singoli passaggi del processo vengono completati.</span><span class="sxs-lookup"><span data-stu-id="944fe-629">However, this can be a much more efficient approach than having a workflow that passes a job from one queue to the next, as each step of the job is completed.</span></span> <span data-ttu-id="944fe-630">Con l'operazione **UpdateMessage** , l'applicazione può salvare lo stato del processo nel messaggio e continuare il lavoro invece di riaccodare il messaggio per il passaggio successivo del processo ogni volta che viene completato un passaggio.</span><span class="sxs-lookup"><span data-stu-id="944fe-630">Using the **UpdateMessage** operation allows your application to save the job state to the message and then continue working, instead of re-queuing the message for the next step of the job every time a step completes.</span></span>  

<span data-ttu-id="944fe-631">Per ulteriori informazioni, vedere l'articolo [Procedura: modificare il contenuto di un messaggio in coda](../queues/storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span><span class="sxs-lookup"><span data-stu-id="944fe-631">For more information, see the article [How to: Change the contents of a queued message](../queues/storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span></span>  

### <span data-ttu-id="944fe-632"><a name="subheading45"></a>Architettura dell'applicazione</span><span class="sxs-lookup"><span data-stu-id="944fe-632"><a name="subheading45"></a>Application architecture</span></span>
<span data-ttu-id="944fe-633">Usare le code per rendere scalabile l'architettura dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-633">You should use queues to make your application architecture scalable.</span></span> <span data-ttu-id="944fe-634">Di seguito vengono elencati alcuni modi in cui le code possono essere usate per rendere più scalabile l'applicazione:</span><span class="sxs-lookup"><span data-stu-id="944fe-634">The following lists some ways you can use queues to make your application more scalable:</span></span>  

* <span data-ttu-id="944fe-635">Le code possono essere usate per creare backlog di lavoro per l'elaborazione e il contenimento dei carichi di lavoro nell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="944fe-635">You can use queues to create backlogs of work for processing and smooth out workloads in your application.</span></span> <span data-ttu-id="944fe-636">Ad esempio, è possibile accodare le richieste degli utenti per eseguire un lavoro che prevede un utilizzo intensivo del processore, ad esempio il ridimensionamento delle immagini caricate.</span><span class="sxs-lookup"><span data-stu-id="944fe-636">For example, you could queue up requests from users to perform processor intensive work such as resizing uploaded images.</span></span>
* <span data-ttu-id="944fe-637">È possibile usare le code per separare i componenti dell'applicazione per eseguirne la scalabilità in modo indipendente.</span><span class="sxs-lookup"><span data-stu-id="944fe-637">You can use queues to decouple parts of your application so that you can scale them independently.</span></span> <span data-ttu-id="944fe-638">Ad esempio, un front-end Web può inserire i risultati di un sondaggio degli utenti in una coda per l'analisi e l'archiviazione successive.</span><span class="sxs-lookup"><span data-stu-id="944fe-638">For example, a web front-end could place survey results from users into a queue for later analysis and storage.</span></span> <span data-ttu-id="944fe-639">È possibile aggiungere più istanze del ruolo di lavoro per elaborare i dati della coda come richiesto.</span><span class="sxs-lookup"><span data-stu-id="944fe-639">You could add more worker role instances to process the queue data as required.</span></span>  

## <a name="conclusion"></a><span data-ttu-id="944fe-640">Conclusione</span><span class="sxs-lookup"><span data-stu-id="944fe-640">Conclusion</span></span>
<span data-ttu-id="944fe-641">In questo articolo sono state descritte alcune delle procedure comprovate più comuni per l'ottimizzazione delle prestazioni durante l'uso d Archiviazione di Azure.</span><span class="sxs-lookup"><span data-stu-id="944fe-641">This article discussed some of the most common, proven practices for optimizing performance when using Azure Storage.</span></span> <span data-ttu-id="944fe-642">Si consiglia a tutti gli sviluppatori di applicazioni di valutare la propria applicazione in base alle procedure descritte sopra e di prendere in considerazione l'attuazione di alcune misure per migliorare le prestazioni delle applicazioni che usano Archiviazione di Azure.</span><span class="sxs-lookup"><span data-stu-id="944fe-642">We encourage every application developer to assess their application against each of the above practices and consider acting on the recommendations to get great performance for their applications that use Azure Storage.</span></span>