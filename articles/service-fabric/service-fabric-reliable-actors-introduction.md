---
title: aaaService infrastruttura affidabile attori Panoramica | Documenti Microsoft
description: Introduzione toohello Service Fabric Reliable Actors modello di programmazione.
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: ab010cbf936c6cf723b3d453ef95a9bf51f76c95
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 10/06/2017
---
# <a name="introduction-tooservice-fabric-reliable-actors"></a><span data-ttu-id="67480-103">Introduzione tooService infrastruttura Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="67480-103">Introduction tooService Fabric Reliable Actors</span></span>
<span data-ttu-id="67480-104">Reliable Actors è un framework di applicazione di Service Fabric in base a hello [Actor virtuale](http://research.microsoft.com/en-us/projects/orleans/) modello.</span><span class="sxs-lookup"><span data-stu-id="67480-104">Reliable Actors is a Service Fabric application framework based on hello [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="67480-105">Hello affidabile attori API fornisce un modello di programmazione a thread singolo compilato in hello scalabilità e affidabilità garanzie fornite dall'infrastruttura del servizio.</span><span class="sxs-lookup"><span data-stu-id="67480-105">hello Reliable Actors API provides a single-threaded programming model built on hello scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="67480-106">Che cosa sono gli attori?</span><span class="sxs-lookup"><span data-stu-id="67480-106">What are Actors?</span></span>
<span data-ttu-id="67480-107">Un attore è un'unità isolata e indipendente di calcolo e di stato con esecuzione a thread singolo.</span><span class="sxs-lookup"><span data-stu-id="67480-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="67480-108">Hello [modello attore](https://en.wikipedia.org/wiki/Actor_model) è un modello di calcolo per i sistemi simultanei o distribuiti che un numero elevato di questi operatori possono essere eseguite simultaneamente in modo indipendente.</span><span class="sxs-lookup"><span data-stu-id="67480-108">hello [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="67480-109">Gli attori possono comunicare tra loro e possono creare altri attori.</span><span class="sxs-lookup"><span data-stu-id="67480-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-toouse-reliable-actors"></a><span data-ttu-id="67480-110">Quando toouse Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="67480-110">When toouse Reliable Actors</span></span>
<span data-ttu-id="67480-111">Servizio Fabric Reliable Actors è un'implementazione del modello di progettazione di hello attore.</span><span class="sxs-lookup"><span data-stu-id="67480-111">Service Fabric Reliable Actors is an implementation of hello actor design pattern.</span></span> <span data-ttu-id="67480-112">Come con qualsiasi modello di progettazione del software, decisione hello se toouse un pattern specifico viene eseguito in base a o meno un software per progettare problema soddisfa il criterio di hello.</span><span class="sxs-lookup"><span data-stu-id="67480-112">As with any software design pattern, hello decision whether toouse a specific pattern is made based on whether or not a software design problem fits hello pattern.</span></span>

<span data-ttu-id="67480-113">Sebbene l'attore hello progettazione modello può essere che ideale tooa numerosi problemi di sistemi distribuiti e gli scenari, un'attenta considerazione dei vincoli di hello del criterio di hello e framework hello implementarlo deve essere eseguita.</span><span class="sxs-lookup"><span data-stu-id="67480-113">Although hello actor design pattern can be a good fit tooa number of distributed systems problems and scenarios, careful consideration of hello constraints of hello pattern and hello framework implementing it must be made.</span></span> <span data-ttu-id="67480-114">Come indicazione generale, prendere in considerazione hello attore modello toomodel il problema o scenario se:</span><span class="sxs-lookup"><span data-stu-id="67480-114">As general guidance, consider hello actor pattern toomodel your problem or scenario if:</span></span>

* <span data-ttu-id="67480-115">Il problema riguarda un gran numero (migliaia o più) di piccole unità indipendenti e isolate di stato e logica.</span><span class="sxs-lookup"><span data-stu-id="67480-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="67480-116">Si desidera toowork con oggetti a thread singolo che non richiedono una notevole interazione da componenti esterni, incluse l'esecuzione di query dello stato in un set di attori.</span><span class="sxs-lookup"><span data-stu-id="67480-116">You want toowork with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="67480-117">Le istanze degli attori non bloccano i chiamanti con ritardi imprevedibili eseguendo operazioni I/O.</span><span class="sxs-lookup"><span data-stu-id="67480-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="67480-118">Attori in Service Fabric</span><span class="sxs-lookup"><span data-stu-id="67480-118">Actors in Service Fabric</span></span>
<span data-ttu-id="67480-119">In Service Fabric, attori vengono implementati in framework Reliable Actors hello: un framework di applicazione basato su attori modello compilato in cima [affidabili servizi dell'infrastruttura](service-fabric-reliable-services-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="67480-119">In Service Fabric, actors are implemented in hello Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="67480-120">Ogni servizio di tipo Reliable Actor che viene scritto è di fatto un servizio Reliable partizionato con stato.</span><span class="sxs-lookup"><span data-stu-id="67480-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="67480-121">Ogni attore è definito come un'istanza di un tipo attore, identici toohello modo un oggetto .NET è un'istanza di un tipo .NET.</span><span class="sxs-lookup"><span data-stu-id="67480-121">Every actor is defined as an instance of an actor type, identical toohello way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="67480-122">Potrebbe esserci più attori di quel tipo distribuiti su vari nodi in un cluster, ad esempio, potrebbe esserci un tipo actor che implementa la funzionalità di hello di una calcolatrice.</span><span class="sxs-lookup"><span data-stu-id="67480-122">For example, there may be an actor type that implements hello functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="67480-123">Ciascuno di questi attori è identificato in modo univoco da un ID.</span><span class="sxs-lookup"><span data-stu-id="67480-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="67480-124">Durata attore</span><span class="sxs-lookup"><span data-stu-id="67480-124">Actor Lifetime</span></span>
<span data-ttu-id="67480-125">Gli attori di Service Fabric sono virtuali, che significa che la durata non rappresentazione in memoria vincolata tootheir.</span><span class="sxs-lookup"><span data-stu-id="67480-125">Service Fabric actors are virtual, meaning that their lifetime is not tied tootheir in-memory representation.</span></span> <span data-ttu-id="67480-126">Di conseguenza, non è necessario toobe creato o eliminato in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="67480-126">As a result, they do not need toobe explicitly created or destroyed.</span></span> <span data-ttu-id="67480-127">runtime Reliable Actors Hello attiva automaticamente hello un attore prima volta che riceve una richiesta per tale ID attore.</span><span class="sxs-lookup"><span data-stu-id="67480-127">hello Reliable Actors runtime automatically activates an actor hello first time it receives a request for that actor ID.</span></span> <span data-ttu-id="67480-128">Se un attore non viene utilizzato per un periodo di tempo, hello Reliable Actors runtime garbage-raccoglie oggetti in memoria hello.</span><span class="sxs-lookup"><span data-stu-id="67480-128">If an actor is not used for a period of time, hello Reliable Actors runtime garbage-collects hello in-memory object.</span></span> <span data-ttu-id="67480-129">Anche manterrà conoscenza dell'esistenza dell'attore hello dovrebbe essere necessario toobe riattivati in un secondo momento.</span><span class="sxs-lookup"><span data-stu-id="67480-129">It will also maintain knowledge of hello actor's existence should it need toobe reactivated later.</span></span> <span data-ttu-id="67480-130">Per altre informazioni, vedere [Ciclo di vita degli attori e Garbage Collection](service-fabric-reliable-actors-lifecycle.md).</span><span class="sxs-lookup"><span data-stu-id="67480-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="67480-131">Questa astrazione durata actor virtuale esegue alcune raccomandazioni come risultato modello actor virtuale hello e in realtà hello implementazione Reliable Actors devia orari da questo modello.</span><span class="sxs-lookup"><span data-stu-id="67480-131">This virtual actor lifetime abstraction carries some caveats as a result of hello virtual actor model, and in fact hello Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="67480-132">Un attore viene attivato automaticamente (causando un attore toobe oggetto costruito) hello prima volta che un messaggio viene inviato ID attore tooits</span><span class="sxs-lookup"><span data-stu-id="67480-132">An actor is automatically activated (causing an actor object toobe constructed) hello first time a message is sent tooits actor ID.</span></span> <span data-ttu-id="67480-133">Dopo un certo periodo di tempo, l'oggetto attore hello è sottoposto a garbage collection.</span><span class="sxs-lookup"><span data-stu-id="67480-133">After some period of time, hello actor object is garbage collected.</span></span> <span data-ttu-id="67480-134">In hello futuro, utilizzando di nuovo ID attore hello provoca un attore nuovo toobe oggetto costruito.</span><span class="sxs-lookup"><span data-stu-id="67480-134">In hello future, using hello actor ID again, causes a new actor object toobe constructed.</span></span> <span data-ttu-id="67480-135">Stato di un attore sia maggiore di quella durata dell'oggetto hello quando archiviata nel gestore degli stati hello.</span><span class="sxs-lookup"><span data-stu-id="67480-135">An actor's state outlives hello object's lifetime when stored in hello state manager.</span></span>
* <span data-ttu-id="67480-136">La chiamata di un qualsiasi metodo di attore per l'ID attore attiva l'attore.</span><span class="sxs-lookup"><span data-stu-id="67480-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="67480-137">Per questo motivo, attore hanno il relativo costruttore chiamato in modo implicito dal runtime di hello.</span><span class="sxs-lookup"><span data-stu-id="67480-137">For this reason, actor types have their constructor called implicitly by hello runtime.</span></span> <span data-ttu-id="67480-138">Pertanto, il codice client non è possibile passare al costruttore del tipo di parametri toohello attore, anche se i parametri possono essere passati costruttore toohello actor dal servizio hello stesso.</span><span class="sxs-lookup"><span data-stu-id="67480-138">Therefore, client code cannot pass parameters toohello actor type's constructor, although parameters may be passed toohello actor's constructor by hello service itself.</span></span> <span data-ttu-id="67480-139">il risultato di Hello è che gli attori possono essere costruiti in uno stato parzialmente inizializzata da altri metodi vengono chiamati su di esso, tempo di hello se attore hello richiede parametri di inizializzazione da client hello.</span><span class="sxs-lookup"><span data-stu-id="67480-139">hello result is that actors may be constructed in a partially-initialized state by hello time other methods are called on it, if hello actor requires initialization parameters from hello client.</span></span> <span data-ttu-id="67480-140">Non è presente alcun singolo punto di ingresso per l'attivazione di un attore da client hello hello.</span><span class="sxs-lookup"><span data-stu-id="67480-140">There is no single entry point for hello activation of an actor from hello client.</span></span>
* <span data-ttu-id="67480-141">Sebbene Reliable Actors creare in modo implicito oggetti attore. è hello possibilità tooexplicitly eliminare un attore e il relativo stato.</span><span class="sxs-lookup"><span data-stu-id="67480-141">Although Reliable Actors implicitly create actor objects; you do have hello ability tooexplicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="67480-142">Distribuzione e failover</span><span class="sxs-lookup"><span data-stu-id="67480-142">Distribution and failover</span></span>
<span data-ttu-id="67480-143">tooprovide scalabilità e affidabilità, Service Fabric distribuisce gli attori in tutto il cluster hello e automaticamente consente di migrare da nodi con errori toohealthy quelli come richiesto.</span><span class="sxs-lookup"><span data-stu-id="67480-143">tooprovide scalability and reliability, Service Fabric distributes actors throughout hello cluster and automatically migrates them from failed nodes toohealthy ones as required.</span></span> <span data-ttu-id="67480-144">Questa è un'astrazione su un [Reliable Service partizionato con stato](service-fabric-concepts-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="67480-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="67480-145">Distribuzione, la scalabilità, affidabilità e il failover automatico vengono forniti in virtù dei fatti hello attori in esecuzione all'interno di un servizio affidabile con stato chiamato hello *servizio Actor*.</span><span class="sxs-lookup"><span data-stu-id="67480-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of hello fact that actors are running inside a stateful Reliable Service called hello *Actor Service*.</span></span>

<span data-ttu-id="67480-146">Le partizioni siano distribuite in nodi hello in un cluster di Service Fabric attori vengono distribuiti tra partizioni hello di hello servizio Actor.</span><span class="sxs-lookup"><span data-stu-id="67480-146">Actors are distributed across hello partitions of hello Actor Service, and those partitions are distributed across hello nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="67480-147">Ogni partizione del servizio contiene un set di attori.</span><span class="sxs-lookup"><span data-stu-id="67480-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="67480-148">Service Fabric gestisce la distribuzione e il failover delle partizioni servizio hello.</span><span class="sxs-lookup"><span data-stu-id="67480-148">Service Fabric manages distribution and failover of hello service partitions.</span></span>

<span data-ttu-id="67480-149">Ad esempio, un servizio actor con nove partizioni distribuiti vengono distribuiti i nodi utilizzando il posizionamento di partizione hello predefinito attore thusly toothree:</span><span class="sxs-lookup"><span data-stu-id="67480-149">For example, an actor service with nine partitions deployed toothree nodes using hello default actor partition placement would be distributed thusly:</span></span>

![Distribuzione di Reliable Actors][2]

<span data-ttu-id="67480-151">Hello attore Framework gestisce le impostazioni di intervallo dello schema e la chiave di partizione per l'utente.</span><span class="sxs-lookup"><span data-stu-id="67480-151">hello Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="67480-152">In tal modo la scelta è più semplice, ma occorre tenere presente alcune considerazioni:</span><span class="sxs-lookup"><span data-stu-id="67480-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="67480-153">Servizi affidabili consente toochoose uno schema di partizionamento, l'intervallo di chiavi (quando si usa un intervallo di schema di partizionamento) e il numero di partizione.</span><span class="sxs-lookup"><span data-stu-id="67480-153">Reliable Services allows you toochoose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="67480-154">Reliable Actors è schema di partizionamento toohello limitato intervallo (schema Int64 uniforme hello) e richiede l'utilizzo di hello completo Int64 intervalli di chiavi.</span><span class="sxs-lookup"><span data-stu-id="67480-154">Reliable Actors is restricted toohello range partitioning scheme (hello uniform Int64 scheme) and requires you use hello full Int64 key range.</span></span>
* <span data-ttu-id="67480-155">Per impostazione predefinita, gli attori vengono posizionati in modo casuale nelle partizioni, in modo che la distribuzione risulti uniforme.</span><span class="sxs-lookup"><span data-stu-id="67480-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="67480-156">Poiché gli attori vengono posizionati in modo casuale, è prevedibile che le operazioni dell'attore richiedano sempre la comunicazione di rete, incluse la serializzazione e deserializzazione dei dati di chiamata del metodo, la latenza riscontrata e il sovraccarico.</span><span class="sxs-lookup"><span data-stu-id="67480-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="67480-157">In scenari avanzati, è la selezione di partizione attore toocontrol possibili con attore Int64 ID che eseguono il mapping delle partizioni toospecific.</span><span class="sxs-lookup"><span data-stu-id="67480-157">In advanced scenarios, it is possible toocontrol actor partition placement by using Int64 actor IDs that map toospecific partitions.</span></span> <span data-ttu-id="67480-158">Questo metodo può tuttavia comportare una distribuzione sbilanciata degli attori tra le partizioni.</span><span class="sxs-lookup"><span data-stu-id="67480-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="67480-159">Per ulteriori informazioni sulla modalità di partizionamento servizi actor di, vedere troppo[partizionamento concetti per attori](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span><span class="sxs-lookup"><span data-stu-id="67480-159">For more information on how actor services are partitioned, refer too[partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="67480-160">Comunicazione tra attori</span><span class="sxs-lookup"><span data-stu-id="67480-160">Actor communication</span></span>
<span data-ttu-id="67480-161">Interazioni attore sono definite in un'interfaccia che viene condiviso da attore hello che implementa l'interfaccia hello e hello client che consente di ottenere un proxy attore tooan tramite hello stessa interfaccia.</span><span class="sxs-lookup"><span data-stu-id="67480-161">Actor interactions are defined in an interface that is shared by hello actor that implements hello interface, and hello client that gets a proxy tooan actor via hello same interface.</span></span> <span data-ttu-id="67480-162">Poiché questa interfaccia è utilizzata tooinvoke attore metodi in modo asincrono, ogni metodo nell'interfaccia hello deve essere restituzione di attività.</span><span class="sxs-lookup"><span data-stu-id="67480-162">Because this interface is used tooinvoke actor methods asynchronously, every method on hello interface must be Task-returning.</span></span>

<span data-ttu-id="67480-163">Chiamate ai metodi e le relative risposte implicano, in richieste di rete tra cluster hello, argomenti hello in tal caso e tipi di risultati hello delle attività hello che restituiscono deve essere serializzabile dalla piattaforma hello.</span><span class="sxs-lookup"><span data-stu-id="67480-163">Method invocations and their responses ultimately result in network requests across hello cluster, so hello arguments and hello result types of hello tasks that they return must be serializable by hello platform.</span></span> <span data-ttu-id="67480-164">In particolare, devono essere [contratto dati serializzabili](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="67480-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="hello-actor-proxy"></a><span data-ttu-id="67480-165">proxy attore Hello</span><span class="sxs-lookup"><span data-stu-id="67480-165">hello actor proxy</span></span>
<span data-ttu-id="67480-166">API client di Reliable Actors Hello fornisce la comunicazione tra un'istanza di attore e un client attore.</span><span class="sxs-lookup"><span data-stu-id="67480-166">hello Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="67480-167">toocommunicate con un attore, un client crea un oggetto proxy attore che implementa l'interfaccia di hello attore.</span><span class="sxs-lookup"><span data-stu-id="67480-167">toocommunicate with an actor, a client creates an actor proxy object that implements hello actor interface.</span></span> <span data-ttu-id="67480-168">client Hello interagisce con attore hello per richiamare metodi su oggetti proxy hello.</span><span class="sxs-lookup"><span data-stu-id="67480-168">hello client interacts with hello actor by invoking methods on hello proxy object.</span></span> <span data-ttu-id="67480-169">proxy attore Hello è utilizzabile per la comunicazione client-a-attore e attore-a-attore.</span><span class="sxs-lookup"><span data-stu-id="67480-169">hello actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="67480-170">Si noti che i tipi di informazioni hello due utilizzato oggetto proxy attore di hello toocreate sono hello attore ID e nome dell'applicazione hello.</span><span class="sxs-lookup"><span data-stu-id="67480-170">Note that hello two pieces of information used toocreate hello actor proxy object are hello actor ID and hello application name.</span></span> <span data-ttu-id="67480-171">ID attore Hello identifica in modo univoco l'attore hello, mentre il nome dell'applicazione hello identifica hello [applicazione di Service Fabric](service-fabric-reliable-actors-platform.md#application-model) in cui è distribuito attore hello.</span><span class="sxs-lookup"><span data-stu-id="67480-171">hello actor ID uniquely identifies hello actor, while hello application name identifies hello [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where hello actor is deployed.</span></span>

<span data-ttu-id="67480-172">Hello `ActorProxy`(c#) o `ActorProxyBase`classe (linguaggio) sul lato client hello esegue attore di hello risoluzione necessarie toolocate hello dall'ID e aprire un canale di comunicazione con esso.</span><span class="sxs-lookup"><span data-stu-id="67480-172">hello `ActorProxy`(C#) / `ActorProxyBase`(Java) class on hello client side performs hello necessary resolution toolocate hello actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="67480-173">Effettua inoltre attore hello toolocate nei casi di hello di errori di comunicazione e di failover.</span><span class="sxs-lookup"><span data-stu-id="67480-173">It also retries toolocate hello actor in hello cases of communication failures and failovers.</span></span> <span data-ttu-id="67480-174">Di conseguenza, il recapito dei messaggi è hello seguenti caratteristiche:</span><span class="sxs-lookup"><span data-stu-id="67480-174">As a result, message delivery has hello following characteristics:</span></span>

* <span data-ttu-id="67480-175">Il recapito del messaggio è il massimo sforzo.</span><span class="sxs-lookup"><span data-stu-id="67480-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="67480-176">Gli attori possono ricevere messaggi duplicati da hello client stesso.</span><span class="sxs-lookup"><span data-stu-id="67480-176">Actors may receive duplicate messages from hello same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="67480-177">Concorrenza</span><span class="sxs-lookup"><span data-stu-id="67480-177">Concurrency</span></span>
<span data-ttu-id="67480-178">Hello Reliable Actors runtime fornisce un modello di accesso basato su semplice per accedere ai metodi attore.</span><span class="sxs-lookup"><span data-stu-id="67480-178">hello Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="67480-179">Ciò significa che, in qualsiasi momento, all'interno del codice oggetto dell'attore non può essere attivo più di un thread.</span><span class="sxs-lookup"><span data-stu-id="67480-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="67480-180">L'accesso a turno semplifica notevolmente i sistemi simultanei, poiché non occorrono meccanismi di sincronizzazione per l'accesso ai dati.</span><span class="sxs-lookup"><span data-stu-id="67480-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="67480-181">Significa anche i sistemi devono essere progettati con considerazioni relative alla natura a thread singolo accesso hello di ogni istanza attore.</span><span class="sxs-lookup"><span data-stu-id="67480-181">It also means systems must be designed with special considerations for hello single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="67480-182">Un'istanza di un solo attore non può elaborare più di una richiesta alla volta.</span><span class="sxs-lookup"><span data-stu-id="67480-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="67480-183">Un'istanza di attore può causare un collo di bottiglia della velocità effettiva in caso di richieste simultanee toohandle previsto.</span><span class="sxs-lookup"><span data-stu-id="67480-183">An actor instance can cause a throughput bottleneck if it is expected toohandle concurrent requests.</span></span>
* <span data-ttu-id="67480-184">Gli attori possono causare un deadlock tra loro se esiste una richiesta circolare tra due attori durante una richiesta esterna è tooone degli attori hello contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="67480-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made tooone of hello actors simultaneously.</span></span> <span data-ttu-id="67480-185">Hello attore runtime verrà automaticamente una volta sulla attore chiama e generare un toointerrupt chiamante di eccezione toohello situazione di blocco critico.</span><span class="sxs-lookup"><span data-stu-id="67480-185">hello actor runtime will automatically time out on actor calls and throw an exception toohello caller toointerrupt possible deadlock situations.</span></span>

![Comunicazioni di Reliable Actors][3]

#### <a name="turn-based-access"></a><span data-ttu-id="67480-187">Accesso basato su turni</span><span class="sxs-lookup"><span data-stu-id="67480-187">Turn-based access</span></span>
<span data-ttu-id="67480-188">Una volta è costituito da hello esecuzione completa di un metodo attore nella richiesta tooa risposta da un client o altri attori o completare l'esecuzione hello di un [timer/promemoria](service-fabric-reliable-actors-timers-reminders.md) callback.</span><span class="sxs-lookup"><span data-stu-id="67480-188">A turn consists of hello complete execution of an actor method in response tooa request from other actors or clients, or hello complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="67480-189">Anche se questi metodi e i callback asincroni, il runtime di attori hello non interleave.</span><span class="sxs-lookup"><span data-stu-id="67480-189">Even though these methods and callbacks are asynchronous, hello Actors runtime does not interleave them.</span></span> <span data-ttu-id="67480-190">Un turno deve essere interamente completato prima che sia consentito un nuovo turno.</span><span class="sxs-lookup"><span data-stu-id="67480-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="67480-191">In altre parole, un callback di metodo o timer/promemoria attore attualmente in esecuzione deve essere completamente terminato prima di un nuovo metodo di chiamata tooa o callback è consentito.</span><span class="sxs-lookup"><span data-stu-id="67480-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call tooa method or callback is allowed.</span></span> <span data-ttu-id="67480-192">Un metodo o il callback viene considerato toohave completata se l'esecuzione di hello ha restituito dal metodo hello o di completamento dell'attività di callback e hello restituito dal metodo hello o un callback.</span><span class="sxs-lookup"><span data-stu-id="67480-192">A method or callback is considered toohave finished if hello execution has returned from hello method or callback and hello task returned by hello method or callback has finished.</span></span> <span data-ttu-id="67480-193">È opportuno sottolineare che la concorrenza basata su turni viene rispettata anche su metodi, timer e callback diversi.</span><span class="sxs-lookup"><span data-stu-id="67480-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="67480-194">runtime attori Hello impone concorrenza basato su acquisendo un blocco actor all'inizio di hello di una volta e attivare il rilascio blocco hello alla fine hello hello.</span><span class="sxs-lookup"><span data-stu-id="67480-194">hello Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at hello beginning of a turn and releasing hello lock at hello end of hello turn.</span></span> <span data-ttu-id="67480-195">Pertanto, la concorrenza basata su turni viene applicata a livello di singolo attore e non per più attori.</span><span class="sxs-lookup"><span data-stu-id="67480-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="67480-196">I metodi e i callback di timer/promemoria degli attori possono essere eseguiti simultaneamente per conto di diversi attori.</span><span class="sxs-lookup"><span data-stu-id="67480-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="67480-197">Hello di esempio seguente viene illustrato hello sopra i concetti.</span><span class="sxs-lookup"><span data-stu-id="67480-197">hello following example illustrates hello above concepts.</span></span> <span data-ttu-id="67480-198">Si consideri un tipo di attore che implementa due metodi asincroni, ad esempio *Method1* e *Method2*, un timer e un promemoria.</span><span class="sxs-lookup"><span data-stu-id="67480-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="67480-199">diagramma di Hello seguente viene illustrato un esempio di una sequenza temporale per l'esecuzione di hello di questi metodi e i callback per conto di due attori (*ActorId1* e *ActorId2*) che appartengono toothis attore tipo.</span><span class="sxs-lookup"><span data-stu-id="67480-199">hello diagram below shows an example of a timeline for hello execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong toothis actor type.</span></span>

![Accesso e concorrenza basata su turni del runtime di Reliable Actors][1]

<span data-ttu-id="67480-201">Il diagramma adotta queste convenzioni:</span><span class="sxs-lookup"><span data-stu-id="67480-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="67480-202">Ogni linea verticale mostra il flusso logico hello dell'esecuzione di un metodo o un callback per conto dell'attore un particolare.</span><span class="sxs-lookup"><span data-stu-id="67480-202">Each vertical line shows hello logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="67480-203">gli eventi di Hello contrassegnati su ogni linea verticale si verificano in ordine cronologico, con gli eventi più recenti che si verificano di sotto di quelle meno recenti.</span><span class="sxs-lookup"><span data-stu-id="67480-203">hello events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="67480-204">Vengono utilizzati colori diversi per le sequenze temporali corrispondenti toodifferent attori.</span><span class="sxs-lookup"><span data-stu-id="67480-204">Different colors are used for timelines corresponding toodifferent actors.</span></span>
* <span data-ttu-id="67480-205">Evidenziazione è durata hello tooindicate utilizzato per la quale hello actor blocco per conto di un metodo o un callback.</span><span class="sxs-lookup"><span data-stu-id="67480-205">Highlighting is used tooindicate hello duration for which hello per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="67480-206">Tooconsider alcuni punti importanti:</span><span class="sxs-lookup"><span data-stu-id="67480-206">Some important points tooconsider:</span></span>

* <span data-ttu-id="67480-207">Mentre *Method1* è in esecuzione per conto di *ActorId2* nella richiesta di risposta tooclient *xyz789*, un'altra richiesta del client (*abc123*) arriva che richiede inoltre *Method1* toobe eseguito da *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="67480-207">While *Method1* is executing on behalf of *ActorId2* in response tooclient request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* toobe executed by *ActorId2*.</span></span> <span data-ttu-id="67480-208">Tuttavia, hello seconda esecuzione di *Method1* non viene avviato finché termina l'esecuzione precedente hello.</span><span class="sxs-lookup"><span data-stu-id="67480-208">However, hello second execution of *Method1* does not begin until hello prior execution has finished.</span></span> <span data-ttu-id="67480-209">Analogamente, un promemoria registrata da *ActorId2* generato durante *Method1* viene eseguito nella richiesta di risposta tooclient *xyz789*.</span><span class="sxs-lookup"><span data-stu-id="67480-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response tooclient request *xyz789*.</span></span> <span data-ttu-id="67480-210">Hello callback promemoria viene eseguita solo dopo che entrambe le esecuzioni di *Method1* sono state completate.</span><span class="sxs-lookup"><span data-stu-id="67480-210">hello reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="67480-211">Tutte queste operazioni a causa della concorrenza basata su tooturn viene applicata per *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="67480-211">All of this is due tooturn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="67480-212">Analogamente, basato su concorrenza viene anche applicata per *ActorId1*, come illustrato dall'esecuzione hello *Method1*, *Method2*, e hello callback del timer per conto di *ActorId1* il problema in modo seriale.</span><span class="sxs-lookup"><span data-stu-id="67480-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by hello execution of *Method1*, *Method2*, and hello timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="67480-213">L'esecuzione di *Method1* per conto di *ActorId1* si sovrappone all'esecuzione per conto di *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="67480-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="67480-214">Questo accade perché la concorrenza basata su turni viene applicata solo all'interno di un attore e non tra più attori.</span><span class="sxs-lookup"><span data-stu-id="67480-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="67480-215">In alcune delle esecuzioni di metodo/callback hello, hello `Task`(c#) o `CompletableFuture`(linguaggio) restituito da hello metodo/callback termina una volta completato il metodo hello.</span><span class="sxs-lookup"><span data-stu-id="67480-215">In some of hello method/callback executions, hello `Task`(C#) / `CompletableFuture`(Java) returned by hello method/callback finishes after hello method returns.</span></span> <span data-ttu-id="67480-216">In alcuni altri, operazione asincrona di hello è già terminata dal tempo hello hello metodo/callback restituisce.</span><span class="sxs-lookup"><span data-stu-id="67480-216">In some others, hello asynchronous operation has already finished by hello time hello method/callback returns.</span></span> <span data-ttu-id="67480-217">In entrambi i casi, hello actor viene sbloccata solo dopo che entrambi hello metodo/callback restituisce e completamento dell'operazione asincrona di hello.</span><span class="sxs-lookup"><span data-stu-id="67480-217">In both cases, hello per-actor lock is released only after both hello method/callback returns and hello asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="67480-218">Rientranza</span><span class="sxs-lookup"><span data-stu-id="67480-218">Reentrancy</span></span>
<span data-ttu-id="67480-219">il runtime di attori Hello consente reentrancy per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="67480-219">hello Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="67480-220">Questo significa che se un metodo attore *attore A* chiama un metodo su *attore B*, che a sua volta chiama un altro metodo in *attore A*, che metodo è consentito toorun.</span><span class="sxs-lookup"><span data-stu-id="67480-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed toorun.</span></span> <span data-ttu-id="67480-221">Infatti, fa parte di hello stesso contesto logico della catena di chiamate.</span><span class="sxs-lookup"><span data-stu-id="67480-221">This is because it is part of hello same logical call-chain context.</span></span> <span data-ttu-id="67480-222">Tutte le chiamate timer e promemoria iniziano con il nuovo contesto di chiamata logico hello.</span><span class="sxs-lookup"><span data-stu-id="67480-222">All timer and reminder calls start with hello new logical call context.</span></span> <span data-ttu-id="67480-223">Vedere hello [reentrancy Reliable Actors](service-fabric-reliable-actors-reentrancy.md) per altri dettagli.</span><span class="sxs-lookup"><span data-stu-id="67480-223">See hello [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="67480-224">Ambito delle garanzie di concorrenza</span><span class="sxs-lookup"><span data-stu-id="67480-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="67480-225">il runtime di attori Hello fornisce le garanzie di concorrenza in situazioni in cui tale vincolo controlla chiamata hello di questi metodi.</span><span class="sxs-lookup"><span data-stu-id="67480-225">hello Actors runtime provides these concurrency guarantees in situations where it controls hello invocation of these methods.</span></span> <span data-ttu-id="67480-226">Ad esempio, fornisce le garanzie hello nelle chiamate ai metodi che viene eseguite nella richiesta client tooa di risposta, nonché per i callback del timer e promemoria.</span><span class="sxs-lookup"><span data-stu-id="67480-226">For example, it provides these guarantees for hello method invocations that are done in response tooa client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="67480-227">Tuttavia, se codice attore hello richiama direttamente questi metodi di fuori di meccanismi di hello forniti dal runtime di attori hello, hello runtime non fornisce alcuna garanzia di concorrenza.</span><span class="sxs-lookup"><span data-stu-id="67480-227">However, if hello actor code directly invokes these methods outside of hello mechanisms provided by hello Actors runtime, then hello runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="67480-228">Ad esempio, se il metodo hello viene richiamato nel contesto di hello di alcune attività che non sia associata con attività hello restituiti dai metodi attore hello, hello runtime non fornisce garanzie di concorrenza.</span><span class="sxs-lookup"><span data-stu-id="67480-228">For example, if hello method is invoked in hello context of some task that is not associated with hello task returned by hello actor methods, then hello runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="67480-229">Se il metodo hello viene richiamato da un thread in tale attore hello crea autonomamente, quindi hello runtime non può anche fornire le garanzie di concorrenza.</span><span class="sxs-lookup"><span data-stu-id="67480-229">If hello method is invoked from a thread that hello actor creates on its own, then hello runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="67480-230">Pertanto, le operazioni in background tooperform, attori devono utilizzare [timer attore e i promemoria attore](service-fabric-reliable-actors-timers-reminders.md) che rispettano concorrenza basata su attiva.</span><span class="sxs-lookup"><span data-stu-id="67480-230">Therefore, tooperform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="67480-231">Passaggi successivi</span><span class="sxs-lookup"><span data-stu-id="67480-231">Next steps</span></span>
* <span data-ttu-id="67480-232">Per iniziare, creare il primo servizio Reliable Actors:</span><span class="sxs-lookup"><span data-stu-id="67480-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="67480-233">Introduzione a Reliable Actors in .NET</span><span class="sxs-lookup"><span data-stu-id="67480-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="67480-234">Introduzione a Reliable Actors in Java</span><span class="sxs-lookup"><span data-stu-id="67480-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
