---
title: Panoramica di Reliable Actors di Service Fabric| Documentazione Microsoft
description: Introduzione al modello di programmazione Service Fabric Reliable Actors
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: e89be04a0d6fe90a89e293e67d42f0204eb7000a
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/11/2017
---
# <a name="introduction-to-service-fabric-reliable-actors"></a><span data-ttu-id="658ad-103">Introduzione a Service Fabric Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="658ad-103">Introduction to Service Fabric Reliable Actors</span></span>
<span data-ttu-id="658ad-104">Reliable Actors è un framework di applicazione Service Fabric basato sul criterio [Actor virtuale](http://research.microsoft.com/en-us/projects/orleans/).</span><span class="sxs-lookup"><span data-stu-id="658ad-104">Reliable Actors is a Service Fabric application framework based on the [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="658ad-105">L'API Reliable Actors offre un modello di programmazione a thread singolo basato sulle garanzie di affidabilità e scalabilità offerte da Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="658ad-105">The Reliable Actors API provides a single-threaded programming model built on the scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="658ad-106">Che cosa sono gli attori?</span><span class="sxs-lookup"><span data-stu-id="658ad-106">What are Actors?</span></span>
<span data-ttu-id="658ad-107">Un attore è un'unità isolata e indipendente di calcolo e di stato con esecuzione a thread singolo.</span><span class="sxs-lookup"><span data-stu-id="658ad-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="658ad-108">Il [criterio Actor](https://en.wikipedia.org/wiki/Actor_model) è un modello di calcolo per sistemi simultanei o distribuiti in cui è possibile eseguire un numero elevato di attori simultaneamente e indipendente.</span><span class="sxs-lookup"><span data-stu-id="658ad-108">The [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="658ad-109">Gli attori possono comunicare tra loro e possono creare altri attori.</span><span class="sxs-lookup"><span data-stu-id="658ad-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-to-use-reliable-actors"></a><span data-ttu-id="658ad-110">Quando usare Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="658ad-110">When to use Reliable Actors</span></span>
<span data-ttu-id="658ad-111">Service Fabric Reliable Actors è un'implementazione dello schema progettuale dell'attore.</span><span class="sxs-lookup"><span data-stu-id="658ad-111">Service Fabric Reliable Actors is an implementation of the actor design pattern.</span></span> <span data-ttu-id="658ad-112">Come per gli altri schemi progettuali del software, la scelta di usare un criterio specifico dipende dalla capacità di un problema di progettazione software di seguire lo schema.</span><span class="sxs-lookup"><span data-stu-id="658ad-112">As with any software design pattern, the decision whether to use a specific pattern is made based on whether or not a software design problem fits the pattern.</span></span>

<span data-ttu-id="658ad-113">Sebbene lo schema progettuale dell'attore possa risultare idoneo per vari problemi e scenari di sistemi distribuiti, occorre valutare attentamente i limiti dello schema e il framework in cui viene implementato.</span><span class="sxs-lookup"><span data-stu-id="658ad-113">Although the actor design pattern can be a good fit to a number of distributed systems problems and scenarios, careful consideration of the constraints of the pattern and the framework implementing it must be made.</span></span> <span data-ttu-id="658ad-114">In generale conviene prendere in considerazione il criterio dell'attore per modellare il problema o lo scenario nei casi seguenti:</span><span class="sxs-lookup"><span data-stu-id="658ad-114">As general guidance, consider the actor pattern to model your problem or scenario if:</span></span>

* <span data-ttu-id="658ad-115">Il problema riguarda un gran numero (migliaia o più) di piccole unità indipendenti e isolate di stato e logica.</span><span class="sxs-lookup"><span data-stu-id="658ad-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="658ad-116">Si desidera usare oggetti a thread singolo che non richiedono un'interazione significativa con componenti esterni, incluse query dello stato tra un insieme di attori.</span><span class="sxs-lookup"><span data-stu-id="658ad-116">You want to work with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="658ad-117">Le istanze degli attori non bloccano i chiamanti con ritardi imprevedibili eseguendo operazioni I/O.</span><span class="sxs-lookup"><span data-stu-id="658ad-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="658ad-118">Attori in Service Fabric</span><span class="sxs-lookup"><span data-stu-id="658ad-118">Actors in Service Fabric</span></span>
<span data-ttu-id="658ad-119">In Service Fabric gli attori sono implementati nel framework Reliable Actors: un framework di applicazioni imperniato sul criterio attore e basato su [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="658ad-119">In Service Fabric, actors are implemented in the Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="658ad-120">Ogni servizio di tipo Reliable Actor che viene scritto è di fatto un servizio Reliable partizionato con stato.</span><span class="sxs-lookup"><span data-stu-id="658ad-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="658ad-121">Ogni attore è definito come un'istanza di un tipo di attore, come un oggetto .NET è un'istanza di un tipo .NET.</span><span class="sxs-lookup"><span data-stu-id="658ad-121">Every actor is defined as an instance of an actor type, identical to the way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="658ad-122">Ad esempio, può essere definito un tipo di attore che implementa la funzionalità di una calcolatrice e possono esistere molti attori di quel tipo distribuiti su vari nodi di un cluster.</span><span class="sxs-lookup"><span data-stu-id="658ad-122">For example, there may be an actor type that implements the functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="658ad-123">Ciascuno di questi attori è identificato in modo univoco da un ID.</span><span class="sxs-lookup"><span data-stu-id="658ad-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="658ad-124">Durata attore</span><span class="sxs-lookup"><span data-stu-id="658ad-124">Actor Lifetime</span></span>
<span data-ttu-id="658ad-125">Gli attori Service Fabric sono virtuali, vale a dire che la loro durata non è correlata alla loro rappresentazione in memoria.</span><span class="sxs-lookup"><span data-stu-id="658ad-125">Service Fabric actors are virtual, meaning that their lifetime is not tied to their in-memory representation.</span></span> <span data-ttu-id="658ad-126">Di conseguenza, non devono essere esplicitamente create o eliminate.</span><span class="sxs-lookup"><span data-stu-id="658ad-126">As a result, they do not need to be explicitly created or destroyed.</span></span> <span data-ttu-id="658ad-127">Il runtime di Reliable Actors attiva automaticamente un attore la prima volta che riceve una richiesta per l'ID attore.</span><span class="sxs-lookup"><span data-stu-id="658ad-127">The Reliable Actors runtime automatically activates an actor the first time it receives a request for that actor ID.</span></span> <span data-ttu-id="658ad-128">Se un attore rimane inutilizzato per un determinato periodo di tempo, il runtime di Reliable Actors esegue la Garbage Collection dell'oggetto in memoria.</span><span class="sxs-lookup"><span data-stu-id="658ad-128">If an actor is not used for a period of time, the Reliable Actors runtime garbage-collects the in-memory object.</span></span> <span data-ttu-id="658ad-129">Mantiene inoltre conoscenza dell'esistenza dell'attore, nel caso in cui debba essere riattivato in un secondo momento.</span><span class="sxs-lookup"><span data-stu-id="658ad-129">It will also maintain knowledge of the actor's existence should it need to be reactivated later.</span></span> <span data-ttu-id="658ad-130">Per altre informazioni, vedere [Ciclo di vita degli attori e Garbage Collection](service-fabric-reliable-actors-lifecycle.md).</span><span class="sxs-lookup"><span data-stu-id="658ad-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="658ad-131">L'astrazione della durata dell'attore virtuale produce alcune avvertenze in seguito al modello di attore virtuale, infatti in alcuni casi l'implementazione di Reliable Actors devia dal modello.</span><span class="sxs-lookup"><span data-stu-id="658ad-131">This virtual actor lifetime abstraction carries some caveats as a result of the virtual actor model, and in fact the Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="658ad-132">Un attore viene automaticamente attivato, causando la costruzione di un oggetto attore, quando all'ID attore viene inviato un messaggio per la prima volta.</span><span class="sxs-lookup"><span data-stu-id="658ad-132">An actor is automatically activated (causing an actor object to be constructed) the first time a message is sent to its actor ID.</span></span> <span data-ttu-id="658ad-133">Dopo un po' di tempo viene eseguita la Garbage Collection dell'oggetto attore.</span><span class="sxs-lookup"><span data-stu-id="658ad-133">After some period of time, the actor object is garbage collected.</span></span> <span data-ttu-id="658ad-134">In futuro viene costruito un nuovo oggetto attore quando l'ID attore viene usato di nuovo.</span><span class="sxs-lookup"><span data-stu-id="658ad-134">In the future, using the actor ID again, causes a new actor object to be constructed.</span></span> <span data-ttu-id="658ad-135">Quando un attore viene archiviato nella gestione stati, la durata del suo stato supera quella dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="658ad-135">An actor's state outlives the object's lifetime when stored in the state manager.</span></span>
* <span data-ttu-id="658ad-136">La chiamata di un qualsiasi metodo di attore per l'ID attore attiva l'attore.</span><span class="sxs-lookup"><span data-stu-id="658ad-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="658ad-137">Per questo motivo il runtime richiama implicitamente il costruttore dei tipi di attore.</span><span class="sxs-lookup"><span data-stu-id="658ad-137">For this reason, actor types have their constructor called implicitly by the runtime.</span></span> <span data-ttu-id="658ad-138">Il codice client pertanto non può trasmettere i parametri al costruttore del tipo di attore, anche se i parametri possono essere trasmessi al costruttore dell'attore tramite il servizio stesso.</span><span class="sxs-lookup"><span data-stu-id="658ad-138">Therefore, client code cannot pass parameters to the actor type's constructor, although parameters may be passed to the actor's constructor by the service itself.</span></span> <span data-ttu-id="658ad-139">Di conseguenza, se l'attore richiede i parametri di inizializzazione dal client, gli attori possono essere costruiti in uno stato inizializzato parzialmente nel momento in cui gli altri metodi vengono chiamati su di esso.</span><span class="sxs-lookup"><span data-stu-id="658ad-139">The result is that actors may be constructed in a partially-initialized state by the time other methods are called on it, if the actor requires initialization parameters from the client.</span></span> <span data-ttu-id="658ad-140">Non è presente alcun punto di ingresso singolo per l'attivazione di un attore dal client.</span><span class="sxs-lookup"><span data-stu-id="658ad-140">There is no single entry point for the activation of an actor from the client.</span></span>
* <span data-ttu-id="658ad-141">Sebbene Reliable Actors crei in modo implicito oggetti attore, è possibile eliminare in modo esplicito un attore e il suo stato.</span><span class="sxs-lookup"><span data-stu-id="658ad-141">Although Reliable Actors implicitly create actor objects; you do have the ability to explicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="658ad-142">Distribuzione e failover</span><span class="sxs-lookup"><span data-stu-id="658ad-142">Distribution and failover</span></span>
<span data-ttu-id="658ad-143">Per garantire scalabilità e affidabilità, Service Fabric distribuisce gli attori all'interno del cluster e ne esegue automaticamente la migrazione dai nodi non riusciti a quelli integri, se richiesto.</span><span class="sxs-lookup"><span data-stu-id="658ad-143">To provide scalability and reliability, Service Fabric distributes actors throughout the cluster and automatically migrates them from failed nodes to healthy ones as required.</span></span> <span data-ttu-id="658ad-144">Questa è un'astrazione su un [Reliable Service partizionato con stato](service-fabric-concepts-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="658ad-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="658ad-145">La distribuzione, la scalabilità, l'affidabilità e il failover automatico sono disponibili in virtù del fatto che gli attori sono in esecuzione all'interno di un Reliable Service con stato chiamato *servizio Actor*.</span><span class="sxs-lookup"><span data-stu-id="658ad-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of the fact that actors are running inside a stateful Reliable Service called the *Actor Service*.</span></span>

<span data-ttu-id="658ad-146">Gli attori vengono distribuiti tra le partizioni del servizio Actor e le partizioni a loro volta vengono distribuite tra i nodi in un cluster Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="658ad-146">Actors are distributed across the partitions of the Actor Service, and those partitions are distributed across the nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="658ad-147">Ogni partizione del servizio contiene un set di attori.</span><span class="sxs-lookup"><span data-stu-id="658ad-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="658ad-148">Service Fabric gestisce la distribuzione e il failover delle partizioni del servizio.</span><span class="sxs-lookup"><span data-stu-id="658ad-148">Service Fabric manages distribution and failover of the service partitions.</span></span>

<span data-ttu-id="658ad-149">Ad esempio, quando un servizio Actor con nove partizioni viene distribuito in tre nodi usando la posizione di partizione attore predefinita:</span><span class="sxs-lookup"><span data-stu-id="658ad-149">For example, an actor service with nine partitions deployed to three nodes using the default actor partition placement would be distributed thusly:</span></span>

![Distribuzione di Reliable Actors][2]

<span data-ttu-id="658ad-151">Il framework attore gestisce automaticamente le impostazioni dello schema di partizionamento e dell'intervallo di chiavi.</span><span class="sxs-lookup"><span data-stu-id="658ad-151">The Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="658ad-152">In tal modo la scelta è più semplice, ma occorre tenere presente alcune considerazioni:</span><span class="sxs-lookup"><span data-stu-id="658ad-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="658ad-153">Reliable Services consente di scegliere uno schema di partizionamento, un intervallo di chiavi nel caso in cui si usi uno schema di partizionamento con intervallo e un conteggio partizioni.</span><span class="sxs-lookup"><span data-stu-id="658ad-153">Reliable Services allows you to choose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="658ad-154">Reliable Actors si limita allo schema di partizionamento dell'intervallo, lo schema uniforme Int64, e richiede l'uso di tutto l'intervallo di chiavi Int64.</span><span class="sxs-lookup"><span data-stu-id="658ad-154">Reliable Actors is restricted to the range partitioning scheme (the uniform Int64 scheme) and requires you use the full Int64 key range.</span></span>
* <span data-ttu-id="658ad-155">Per impostazione predefinita, gli attori vengono posizionati in modo casuale nelle partizioni, in modo che la distribuzione risulti uniforme.</span><span class="sxs-lookup"><span data-stu-id="658ad-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="658ad-156">Poiché gli attori vengono posizionati in modo casuale, è prevedibile che le operazioni dell'attore richiedano sempre la comunicazione di rete, incluse la serializzazione e deserializzazione dei dati di chiamata del metodo, la latenza riscontrata e il sovraccarico.</span><span class="sxs-lookup"><span data-stu-id="658ad-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="658ad-157">Negli scenari avanzati è possibile controllare il posizionamento della partizione dell'attore usando gli ID attore Int64 che eseguono il mapping su partizioni specifiche.</span><span class="sxs-lookup"><span data-stu-id="658ad-157">In advanced scenarios, it is possible to control actor partition placement by using Int64 actor IDs that map to specific partitions.</span></span> <span data-ttu-id="658ad-158">Questo metodo può tuttavia comportare una distribuzione sbilanciata degli attori tra le partizioni.</span><span class="sxs-lookup"><span data-stu-id="658ad-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="658ad-159">Per altre informazioni sul partizionamento dei servizi attore vedere [Concetti relativi alla partizione per gli attori](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span><span class="sxs-lookup"><span data-stu-id="658ad-159">For more information on how actor services are partitioned, refer to [partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="658ad-160">Comunicazione tra attori</span><span class="sxs-lookup"><span data-stu-id="658ad-160">Actor communication</span></span>
<span data-ttu-id="658ad-161">Le interazioni tra gli attori sono definite in un'interfaccia condivisa dall'attore che implementa l'interfaccia e dal client che ottiene un proxy per un attore tramite l'interfaccia stessa.</span><span class="sxs-lookup"><span data-stu-id="658ad-161">Actor interactions are defined in an interface that is shared by the actor that implements the interface, and the client that gets a proxy to an actor via the same interface.</span></span> <span data-ttu-id="658ad-162">Dato che questa interfaccia viene usata per richiamare i metodi dell'attore in modo asincrono, ogni metodo nell'interfaccia deve comportare la restituzione di Task.</span><span class="sxs-lookup"><span data-stu-id="658ad-162">Because this interface is used to invoke actor methods asynchronously, every method on the interface must be Task-returning.</span></span>

<span data-ttu-id="658ad-163">Le chiamate ai metodi e le relative risposte risultano nelle richieste di rete eseguite nel cluster, pertanto gli argomenti e i tipi di risultati delle attività restituite devono essere serializzabili dalla piattaforma.</span><span class="sxs-lookup"><span data-stu-id="658ad-163">Method invocations and their responses ultimately result in network requests across the cluster, so the arguments and the result types of the tasks that they return must be serializable by the platform.</span></span> <span data-ttu-id="658ad-164">In particolare, devono essere [contratto dati serializzabili](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="658ad-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="the-actor-proxy"></a><span data-ttu-id="658ad-165">Proxy dell'attore</span><span class="sxs-lookup"><span data-stu-id="658ad-165">The actor proxy</span></span>
<span data-ttu-id="658ad-166">L'API client Reliable Actors consente la comunicazione tra un'istanza di attore e un client di attore.</span><span class="sxs-lookup"><span data-stu-id="658ad-166">The Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="658ad-167">Per comunicare con un attore, un client crea un oggetto proxy di attore che implementa l'interfaccia dell'attore.</span><span class="sxs-lookup"><span data-stu-id="658ad-167">To communicate with an actor, a client creates an actor proxy object that implements the actor interface.</span></span> <span data-ttu-id="658ad-168">Il client interagisce con l'attore richiamando metodi sull'oggetto proxy.</span><span class="sxs-lookup"><span data-stu-id="658ad-168">The client interacts with the actor by invoking methods on the proxy object.</span></span> <span data-ttu-id="658ad-169">Il proxy dell'attore può essere usato per la comunicazione tra client e attore e tra attore e attore.</span><span class="sxs-lookup"><span data-stu-id="658ad-169">The actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on the actor. If an actor with the given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on the actor. If an actor with the given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="658ad-170">Osservare come le due porzioni di informazioni usate per creare l'oggetto proxy dell'attore siano l'ID dell'attore e il nome dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="658ad-170">Note that the two pieces of information used to create the actor proxy object are the actor ID and the application name.</span></span> <span data-ttu-id="658ad-171">L'ID attore identifica in modo univoco l'attore, mentre il nome dell'applicazione identifica l' [applicazione Service Fabric](service-fabric-reliable-actors-platform.md#application-model) in cui è distribuito l'attore.</span><span class="sxs-lookup"><span data-stu-id="658ad-171">The actor ID uniquely identifies the actor, while the application name identifies the [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where the actor is deployed.</span></span>

<span data-ttu-id="658ad-172">La classe `ActorProxy`(C#) / `ActorProxyBase`(Java) sul lato client esegue la risoluzione necessaria per individuare l'attore in base al relativo ID e aprire un canale di comunicazione con esso.</span><span class="sxs-lookup"><span data-stu-id="658ad-172">The `ActorProxy`(C#) / `ActorProxyBase`(Java) class on the client side performs the necessary resolution to locate the actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="658ad-173">In caso di errore di comunicazione e failover, la classe tenta di individuare nuovamente l'attore.</span><span class="sxs-lookup"><span data-stu-id="658ad-173">It also retries to locate the actor in the cases of communication failures and failovers.</span></span> <span data-ttu-id="658ad-174">Il recapito dei messaggi, di conseguenza, presenta le caratteristiche seguenti:</span><span class="sxs-lookup"><span data-stu-id="658ad-174">As a result, message delivery has the following characteristics:</span></span>

* <span data-ttu-id="658ad-175">Il recapito del messaggio è il massimo sforzo.</span><span class="sxs-lookup"><span data-stu-id="658ad-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="658ad-176">Gli attori possono ricevere messaggi duplicati dallo stesso client.</span><span class="sxs-lookup"><span data-stu-id="658ad-176">Actors may receive duplicate messages from the same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="658ad-177">Concorrenza</span><span class="sxs-lookup"><span data-stu-id="658ad-177">Concurrency</span></span>
<span data-ttu-id="658ad-178">Il runtime di Reliable Actors rappresenta un modello semplice di accesso a turno per accedere ai metodi degli attori.</span><span class="sxs-lookup"><span data-stu-id="658ad-178">The Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="658ad-179">Ciò significa che, in qualsiasi momento, all'interno del codice oggetto dell'attore non può essere attivo più di un thread.</span><span class="sxs-lookup"><span data-stu-id="658ad-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="658ad-180">L'accesso a turno semplifica notevolmente i sistemi simultanei, poiché non occorrono meccanismi di sincronizzazione per l'accesso ai dati.</span><span class="sxs-lookup"><span data-stu-id="658ad-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="658ad-181">I sistemi devono inoltre essere progettati tenendo in particolare considerazione la natura di accesso a thread singolo di ogni istanza dell'attore.</span><span class="sxs-lookup"><span data-stu-id="658ad-181">It also means systems must be designed with special considerations for the single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="658ad-182">Un'istanza di un solo attore non può elaborare più di una richiesta alla volta.</span><span class="sxs-lookup"><span data-stu-id="658ad-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="658ad-183">Se si prevede di gestire richieste simultanee, un'istanza di un attore può causare un collo di bottiglia della velocità effettiva.</span><span class="sxs-lookup"><span data-stu-id="658ad-183">An actor instance can cause a throughput bottleneck if it is expected to handle concurrent requests.</span></span>
* <span data-ttu-id="658ad-184">Gli attori possono bloccarsi a vicenda se esiste una richiesta circolare tra due attori mentre viene eseguita una richiesta esterna a uno degli attori.</span><span class="sxs-lookup"><span data-stu-id="658ad-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made to one of the actors simultaneously.</span></span> <span data-ttu-id="658ad-185">Il runtime dell'attore causa automaticamente il timeout delle chiamate dell'attore e genera un'eccezione al chiamante per interrompere le possibili situazioni di deadlock.</span><span class="sxs-lookup"><span data-stu-id="658ad-185">The actor runtime will automatically time out on actor calls and throw an exception to the caller to interrupt possible deadlock situations.</span></span>

![Comunicazioni di Reliable Actors][3]

#### <a name="turn-based-access"></a><span data-ttu-id="658ad-187">Accesso basato su turni</span><span class="sxs-lookup"><span data-stu-id="658ad-187">Turn-based access</span></span>
<span data-ttu-id="658ad-188">Un turno consiste nell'esecuzione completa di un metodo di un attore in risposta a una richiesta eseguita da altri attori o client oppure nell'esecuzione completa di un callback di [timer/promemoria](service-fabric-reliable-actors-timers-reminders.md) .</span><span class="sxs-lookup"><span data-stu-id="658ad-188">A turn consists of the complete execution of an actor method in response to a request from other actors or clients, or the complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="658ad-189">Anche se questi metodi e callback sono asincroni, il runtime di Actors non ne esegue l'interfoliazione.</span><span class="sxs-lookup"><span data-stu-id="658ad-189">Even though these methods and callbacks are asynchronous, the Actors runtime does not interleave them.</span></span> <span data-ttu-id="658ad-190">Un turno deve essere interamente completato prima che sia consentito un nuovo turno.</span><span class="sxs-lookup"><span data-stu-id="658ad-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="658ad-191">In altre parole, un metodo di un attore o un callback di timer/promemoria in esecuzione deve essere interamente completato prima che sia consentita una nuova chiamata a un metodo o a un callback.</span><span class="sxs-lookup"><span data-stu-id="658ad-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call to a method or callback is allowed.</span></span> <span data-ttu-id="658ad-192">Un metodo o un callback è considerato completato se è stata restituita l'esecuzione e se l'attività restituita dal metodo o dal callback è stata completata.</span><span class="sxs-lookup"><span data-stu-id="658ad-192">A method or callback is considered to have finished if the execution has returned from the method or callback and the task returned by the method or callback has finished.</span></span> <span data-ttu-id="658ad-193">È opportuno sottolineare che la concorrenza basata su turni viene rispettata anche su metodi, timer e callback diversi.</span><span class="sxs-lookup"><span data-stu-id="658ad-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="658ad-194">Per applicare la concorrenza basata su turni, il runtime di Actors acquisisce un blocco per ogni attore all'inizio di un turno e lo rilascia alla fine del turno.</span><span class="sxs-lookup"><span data-stu-id="658ad-194">The Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at the beginning of a turn and releasing the lock at the end of the turn.</span></span> <span data-ttu-id="658ad-195">Pertanto, la concorrenza basata su turni viene applicata a livello di singolo attore e non per più attori.</span><span class="sxs-lookup"><span data-stu-id="658ad-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="658ad-196">I metodi e i callback di timer/promemoria degli attori possono essere eseguiti simultaneamente per conto di diversi attori.</span><span class="sxs-lookup"><span data-stu-id="658ad-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="658ad-197">L'esempio seguente illustra questi concetti.</span><span class="sxs-lookup"><span data-stu-id="658ad-197">The following example illustrates the above concepts.</span></span> <span data-ttu-id="658ad-198">Si consideri un tipo di attore che implementa due metodi asincroni, ad esempio *Method1* e *Method2*, un timer e un promemoria.</span><span class="sxs-lookup"><span data-stu-id="658ad-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="658ad-199">Il diagramma seguente illustra un esempio di sequenza temporale per l'esecuzione di questi metodi e callback per conto di due attori, *ActorId1* e *ActorId2*, appartenenti a questo tipo.</span><span class="sxs-lookup"><span data-stu-id="658ad-199">The diagram below shows an example of a timeline for the execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong to this actor type.</span></span>

![Accesso e concorrenza basata su turni del runtime di Reliable Actors][1]

<span data-ttu-id="658ad-201">Il diagramma adotta queste convenzioni:</span><span class="sxs-lookup"><span data-stu-id="658ad-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="658ad-202">Ogni linea verticale mostra il flusso logico di esecuzione di un metodo o di un callback per conto di un attore specifico.</span><span class="sxs-lookup"><span data-stu-id="658ad-202">Each vertical line shows the logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="658ad-203">Gli eventi contrassegnati su ogni linea verticale sono riportati in ordine cronologico, con gli eventi più recenti elencati sotto quelli meno recenti.</span><span class="sxs-lookup"><span data-stu-id="658ad-203">The events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="658ad-204">Per le sequenze temporali vengono usati colori diversi, corrispondenti a diversi attori.</span><span class="sxs-lookup"><span data-stu-id="658ad-204">Different colors are used for timelines corresponding to different actors.</span></span>
* <span data-ttu-id="658ad-205">L'evidenziazione viene usata per indicare la durata in cui il blocco per attore è attivato per conto di un metodo o di un callback.</span><span class="sxs-lookup"><span data-stu-id="658ad-205">Highlighting is used to indicate the duration for which the per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="658ad-206">Alcuni elementi importanti da considerare:</span><span class="sxs-lookup"><span data-stu-id="658ad-206">Some important points to consider:</span></span>

* <span data-ttu-id="658ad-207">Mentre *Method1* è in esecuzione per conto di *ActorId2* in risposta alla richiesta client *xyz789*, arriva un'altra richiesta client *abc123* per l'esecuzione di *Method1* da parte di *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="658ad-207">While *Method1* is executing on behalf of *ActorId2* in response to client request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* to be executed by *ActorId2*.</span></span> <span data-ttu-id="658ad-208">La seconda esecuzione di *Method1* tuttavia non inizia finché non è terminata l'esecuzione precedente.</span><span class="sxs-lookup"><span data-stu-id="658ad-208">However, the second execution of *Method1* does not begin until the prior execution has finished.</span></span> <span data-ttu-id="658ad-209">Analogamente, un promemoria registrato da *ActorId2* viene attivato mentre *Method1* è in esecuzione in risposta alla richiesta client *xyz789*.</span><span class="sxs-lookup"><span data-stu-id="658ad-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response to client request *xyz789*.</span></span> <span data-ttu-id="658ad-210">Il callback di promemoria viene eseguito solo dopo che entrambe le esecuzioni di *Method1* sono state completate.</span><span class="sxs-lookup"><span data-stu-id="658ad-210">The reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="658ad-211">Tutto ciò è regolato dalla concorrenza basata su turni applicata per *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="658ad-211">All of this is due to turn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="658ad-212">Questa concorrenza basata sui turni viene applicata analogamente anche per *ActorId1*, come dimostrato dall'esecuzione di *Method1*, *Method2* e del callback del timer per conto di *ActorId1* eseguito in modalità seriale.</span><span class="sxs-lookup"><span data-stu-id="658ad-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by the execution of *Method1*, *Method2*, and the timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="658ad-213">L'esecuzione di *Method1* per conto di *ActorId1* si sovrappone all'esecuzione per conto di *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="658ad-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="658ad-214">Questo accade perché la concorrenza basata su turni viene applicata solo all'interno di un attore e non tra più attori.</span><span class="sxs-lookup"><span data-stu-id="658ad-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="658ad-215">In alcune esecuzioni di metodo o callback, l'oggetto `Task`(C#) / `CompletableFuture`(Java) restituito dal metodo o dal callback viene completato solo dopo la restituzione del metodo.</span><span class="sxs-lookup"><span data-stu-id="658ad-215">In some of the method/callback executions, the `Task`(C#) / `CompletableFuture`(Java) returned by the method/callback finishes after the method returns.</span></span> <span data-ttu-id="658ad-216">In altre esecuzioni, l'operazione asincrona risulta già completata al momento della restituzione del metodo o del callback.</span><span class="sxs-lookup"><span data-stu-id="658ad-216">In some others, the asynchronous operation has already finished by the time the method/callback returns.</span></span> <span data-ttu-id="658ad-217">In entrambi i casi, il blocco per attore viene rilasciato soltanto dopo la restituzione del metodo o del callback e il completamento dell'operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="658ad-217">In both cases, the per-actor lock is released only after both the method/callback returns and the asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="658ad-218">Rientranza</span><span class="sxs-lookup"><span data-stu-id="658ad-218">Reentrancy</span></span>
<span data-ttu-id="658ad-219">Per impostazione predefinita, il runtime di Actors consente la reentrancy.</span><span class="sxs-lookup"><span data-stu-id="658ad-219">The Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="658ad-220">In altre parole, se un metodo dell'*Actor A* chiama un metodo sull'*Actor B*, che a sua volta chiama un altro metodo sull'*Actor A*, il metodo può essere eseguito.</span><span class="sxs-lookup"><span data-stu-id="658ad-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed to run.</span></span> <span data-ttu-id="658ad-221">perché fa parte dello stesso contesto logico della catena di chiamate.</span><span class="sxs-lookup"><span data-stu-id="658ad-221">This is because it is part of the same logical call-chain context.</span></span> <span data-ttu-id="658ad-222">Tutte le chiamate di timer e promemoria iniziano con il nuovo contesto logico di chiamate.</span><span class="sxs-lookup"><span data-stu-id="658ad-222">All timer and reminder calls start with the new logical call context.</span></span> <span data-ttu-id="658ad-223">Per altre informazioni, vedere [Rientranza di Reliable Actors](service-fabric-reliable-actors-reentrancy.md).</span><span class="sxs-lookup"><span data-stu-id="658ad-223">See the [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="658ad-224">Ambito delle garanzie di concorrenza</span><span class="sxs-lookup"><span data-stu-id="658ad-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="658ad-225">Il runtime di Actors fornisce queste garanzie di concorrenza nelle situazioni in cui controlla le chiamate di questi metodi,</span><span class="sxs-lookup"><span data-stu-id="658ad-225">The Actors runtime provides these concurrency guarantees in situations where it controls the invocation of these methods.</span></span> <span data-ttu-id="658ad-226">ad esempio per le chiamate di metodi eseguite in risposta a una richiesta client e per i callback di promemoria e timer.</span><span class="sxs-lookup"><span data-stu-id="658ad-226">For example, it provides these guarantees for the method invocations that are done in response to a client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="658ad-227">Tuttavia, se il codice dell'attore richiama direttamente questi metodi al di fuori dei meccanismi forniti dal runtime di Actors, il runtime non può offrire alcuna garanzia di concorrenza.</span><span class="sxs-lookup"><span data-stu-id="658ad-227">However, if the actor code directly invokes these methods outside of the mechanisms provided by the Actors runtime, then the runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="658ad-228">Ad esempio, se il metodo viene richiamato nel contesto di un'attività non associata all'attività restituita dai metodi dell'attore</span><span class="sxs-lookup"><span data-stu-id="658ad-228">For example, if the method is invoked in the context of some task that is not associated with the task returned by the actor methods, then the runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="658ad-229">oppure se viene richiamato da un thread che l'attore crea in modo autonomo, il runtime non può fornire garanzie di concorrenza.</span><span class="sxs-lookup"><span data-stu-id="658ad-229">If the method is invoked from a thread that the actor creates on its own, then the runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="658ad-230">Per eseguire operazioni in background, pertanto, gli attori devono usare specifici [timer e promemoria](service-fabric-reliable-actors-timers-reminders.md) che rispettano la concorrenza basata su turni.</span><span class="sxs-lookup"><span data-stu-id="658ad-230">Therefore, to perform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="658ad-231">Passaggi successivi</span><span class="sxs-lookup"><span data-stu-id="658ad-231">Next steps</span></span>
* <span data-ttu-id="658ad-232">Per iniziare, creare il primo servizio Reliable Actors:</span><span class="sxs-lookup"><span data-stu-id="658ad-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="658ad-233">Introduzione a Reliable Actors in .NET</span><span class="sxs-lookup"><span data-stu-id="658ad-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="658ad-234">Introduzione a Reliable Actors in Java</span><span class="sxs-lookup"><span data-stu-id="658ad-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
