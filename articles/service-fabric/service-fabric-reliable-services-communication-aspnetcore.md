---
title: la comunicazione con ASP.NET Core hello aaaService | Documenti Microsoft
description: Informazioni su come toouse ASP.NET Core in servizi affidabili e senza stato.
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 8aa4668d-cbb6-4225-bd2d-ab5925a868f2
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: required
ms.date: 05/02/2017
ms.author: vturecek
ms.openlocfilehash: 6e6a83ab04390150292f63de5d9b51d290284e50
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 10/06/2017
---
# <a name="aspnet-core-in-service-fabric-reliable-services"></a><span data-ttu-id="77acf-103">ASP.NET Core in Reliable Services di Service Fabric</span><span class="sxs-lookup"><span data-stu-id="77acf-103">ASP.NET Core in Service Fabric Reliable Services</span></span>

<span data-ttu-id="77acf-104">ASP.NET Core è un nuovo framework open source e multipiattaforma per la compilazione di applicazioni Internet moderne basate sul cloud, ad esempio app Web, app per IoT e back-end per dispositivi mobili.</span><span class="sxs-lookup"><span data-stu-id="77acf-104">ASP.NET Core is a new open-source and cross-platform framework for building modern cloud-based Internet-connected applications, such as web apps, IoT apps, and mobile backends.</span></span> 

<span data-ttu-id="77acf-105">Questo articolo è toohosting una guida approfondita di servizi di ASP.NET Core in Service Fabric servizi affidabili utilizzando hello **Microsoft.ServiceFabric.AspNetCore.** * set di pacchetti NuGet.</span><span class="sxs-lookup"><span data-stu-id="77acf-105">This article is an in-depth guide toohosting ASP.NET Core services in Service Fabric Reliable Services using hello **Microsoft.ServiceFabric.AspNetCore.*** set of NuGet packages.</span></span>

<span data-ttu-id="77acf-106">Per un'esercitazione introduttiva su ASP.NET Core in Service Fabric e istruzioni per la configurazione dell'ambiente di sviluppo, vedere [Compilare un front-end di servizio Web per l'applicazione tramite ASP.NET Core](service-fabric-add-a-web-frontend.md).</span><span class="sxs-lookup"><span data-stu-id="77acf-106">For an introductory tutorial on ASP.NET Core in Service Fabric and instructions on getting your development environment set up, see [Building a web front-end for your application using ASP.NET Core](service-fabric-add-a-web-frontend.md).</span></span>

<span data-ttu-id="77acf-107">rest Hello di questo articolo presuppone una certa familiarità con ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="77acf-107">hello rest of this article assumes you are already familiar with ASP.NET Core.</span></span> <span data-ttu-id="77acf-108">Se non è consigliabile esaminare hello [nozioni fondamentali su ASP.NET Core](https://docs.microsoft.com/aspnet/core/fundamentals/index).</span><span class="sxs-lookup"><span data-stu-id="77acf-108">If not, we recommend reading through hello [ASP.NET Core fundamentals](https://docs.microsoft.com/aspnet/core/fundamentals/index).</span></span>

## <a name="aspnet-core-in-hello-service-fabric-environment"></a><span data-ttu-id="77acf-109">ASP.NET Core nell'ambiente di Service Fabric hello</span><span class="sxs-lookup"><span data-stu-id="77acf-109">ASP.NET Core in hello Service Fabric environment</span></span>

<span data-ttu-id="77acf-110">Mentre le applicazioni ASP.NET Core può essere eseguito su .NET Core o su hello su che completa di .NET Framework, servizi di Service Fabric attualmente può essere eseguito solo hello completa di .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="77acf-110">While ASP.NET Core apps can run on .NET Core or on hello full .NET Framework, Service Fabric services currently can only run on hello full .NET Framework.</span></span> <span data-ttu-id="77acf-111">Ciò significa che quando si compila un servizio di Service Fabric di ASP.NET Core, è comunque necessario assegnare hello completa di .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="77acf-111">This means when you build an ASP.NET  Core Service Fabric service, you must still target hello full .NET Framework.</span></span>

<span data-ttu-id="77acf-112">ASP.NET Core può essere usato in due modi diversi in Service Fabric:</span><span class="sxs-lookup"><span data-stu-id="77acf-112">ASP.NET Core can be used in two different ways in Service Fabric:</span></span>
 - <span data-ttu-id="77acf-113">**Ospitato come eseguibile guest**.</span><span class="sxs-lookup"><span data-stu-id="77acf-113">**Hosted as a guest executable**.</span></span> <span data-ttu-id="77acf-114">Si tratta principalmente usato toorun ASP.NET Core applicazioni esistenti in Service Fabric senza apportare modifiche al codice.</span><span class="sxs-lookup"><span data-stu-id="77acf-114">This is primarily used toorun existing ASP.NET Core applications on Service Fabric with no code changes.</span></span>
 - <span data-ttu-id="77acf-115">**Eseguito in un servizio Reliable Services**.</span><span class="sxs-lookup"><span data-stu-id="77acf-115">**Run inside a Reliable Service**.</span></span> <span data-ttu-id="77acf-116">Ciò consente una migliore integrazione con il runtime di Service Fabric hello e consente ai servizi con stato ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="77acf-116">This allows better integration with hello Service Fabric runtime and allows stateful ASP.NET Core services.</span></span>

<span data-ttu-id="77acf-117">rest Hello di questo articolo viene illustrato come toouse ASP.NET Core all'interno di un servizio affidabile usando hello componenti di integrazione ASP.NET Core forniti con hello Service Fabric SDK.</span><span class="sxs-lookup"><span data-stu-id="77acf-117">hello rest of this article explains how toouse ASP.NET Core inside a Reliable Service using hello ASP.NET Core integration components that ship with hello Service Fabric SDK.</span></span> 

## <a name="service-fabric-service-hosting"></a><span data-ttu-id="77acf-118">Hosting di servizi di Service Fabric</span><span class="sxs-lookup"><span data-stu-id="77acf-118">Service Fabric service hosting</span></span>

<span data-ttu-id="77acf-119">In Service Fabric, una o più istanze e/o repliche del servizio vengono eseguite in un *processo host del servizio*, un file eseguibile che esegue il codice del servizio.</span><span class="sxs-lookup"><span data-stu-id="77acf-119">In Service Fabric, one or more instances and/or replicas of your service run in a *service host process*, an executable file that runs your service code.</span></span> <span data-ttu-id="77acf-120">Come l'autore di un servizio, il proprietario processo host del servizio di hello e Service Fabric attiva e si esegue il monitoraggio per l'utente.</span><span class="sxs-lookup"><span data-stu-id="77acf-120">You, as a service author, own hello service host process and Service Fabric activates and monitors it for you.</span></span>

<span data-ttu-id="77acf-121">ASP.NET tradizionale (backup tooMVC 5) è fortemente accoppiata tooIIS tramite System.Web.dll.</span><span class="sxs-lookup"><span data-stu-id="77acf-121">Traditional ASP.NET (up tooMVC 5) is tightly coupled tooIIS through System.Web.dll.</span></span> <span data-ttu-id="77acf-122">ASP.NET Core fornisce una separazione tra server web hello e l'applicazione web.</span><span class="sxs-lookup"><span data-stu-id="77acf-122">ASP.NET Core provides a separation between hello web server and your web application.</span></span> <span data-ttu-id="77acf-123">In questo modo portabile tra i server web diverso toobe di applicazioni web e si consente inoltre di web server toobe *self-hosted*, ovvero è possibile avviare un server web in un processo personalizzato, come processo anziché tooa appartenente a web dedicato software server, come IIS.</span><span class="sxs-lookup"><span data-stu-id="77acf-123">This allows web applications toobe portable between different web servers and also allows web servers toobe *self-hosted*, which means you can start a web server in your own process, as opposed tooa process that is owned by dedicated web server software such as IIS.</span></span> 

<span data-ttu-id="77acf-124">In ordine toocombine un servizio di Service Fabric e ASP.NET, come un eseguibile guest o in un servizio affidabile, è necessario essere in grado di toostart ASP.NET all'interno del processo host del servizio.</span><span class="sxs-lookup"><span data-stu-id="77acf-124">In order toocombine a Service Fabric service and ASP.NET, either as a guest executable or in a Reliable Service, you must be able toostart ASP.NET inside your service host process.</span></span> <span data-ttu-id="77acf-125">ASP.NET Core self-hosting consente toodo questo.</span><span class="sxs-lookup"><span data-stu-id="77acf-125">ASP.NET Core self-hosting allows you toodo this.</span></span>

## <a name="hosting-aspnet-core-in-a-reliable-service"></a><span data-ttu-id="77acf-126">Hosting di ASP.NET Core in un servizio Reliable Services</span><span class="sxs-lookup"><span data-stu-id="77acf-126">Hosting ASP.NET Core in a Reliable Service</span></span>
<span data-ttu-id="77acf-127">In genere, le applicazioni ASP.NET Core indipendenti creano un WebHost nel punto di ingresso di un'applicazione, ad esempio hello `static void Main()` metodo `Program.cs`.</span><span class="sxs-lookup"><span data-stu-id="77acf-127">Typically, self-hosted ASP.NET Core applications create a WebHost in an application's entry point, such as hello `static void Main()` method in `Program.cs`.</span></span> <span data-ttu-id="77acf-128">In questo caso, hello ciclo di vita di hello WebHost è associato toohello ciclo di vita del processo di hello.</span><span class="sxs-lookup"><span data-stu-id="77acf-128">In this case, hello lifecycle of hello WebHost is bound toohello lifecycle of hello process.</span></span>

![Hosting di ASP.NET Core in un processo][0]

<span data-ttu-id="77acf-130">Tuttavia, il punto di ingresso applicazione hello non hello posto giusto toocreate un WebHost in un servizio affidabile, poiché viene utilizzato solo il punto di ingresso applicazione hello tooregister un servizio di tipo con il runtime di Service Fabric hello, in modo che è possibile creare istanze del servizio tipo.</span><span class="sxs-lookup"><span data-stu-id="77acf-130">However, hello application entry point is not hello right place toocreate a WebHost in a Reliable Service, because hello application entry point is only used tooregister a service type with hello Service Fabric runtime, so that it may create instances of that service type.</span></span> <span data-ttu-id="77acf-131">Hello WebHost deve essere creato in un servizio affidabile se stesso.</span><span class="sxs-lookup"><span data-stu-id="77acf-131">hello WebHost should be created in a Reliable Service itself.</span></span> <span data-ttu-id="77acf-132">Nel processo host del servizio di hello, le istanze del servizio e/o repliche possono essere eseguita per più cicli di vita.</span><span class="sxs-lookup"><span data-stu-id="77acf-132">Within hello service host process, service instances and/or replicas can go through multiple lifecycles.</span></span> 

<span data-ttu-id="77acf-133">Un'istanza di Reliable Services è rappresentata dalla classe del servizio derivante da `StatelessService` o `StatefulService`.</span><span class="sxs-lookup"><span data-stu-id="77acf-133">A Reliable Service instance is represented by your service class deriving from `StatelessService` or `StatefulService`.</span></span> <span data-ttu-id="77acf-134">stack di comunicazione Hello per un servizio è contenuto in un `ICommunicationListener` implementazione nella classe del servizio.</span><span class="sxs-lookup"><span data-stu-id="77acf-134">hello communication stack for a service is contained in an `ICommunicationListener` implementation in your service class.</span></span> <span data-ttu-id="77acf-135">Hello `Microsoft.ServiceFabric.Services.AspNetCore.*` pacchetti NuGet contengono le implementazioni di `ICommunicationListener` che avvia e gestire hello ASP.NET Core WebHost per Kestrel o WebListener in un servizio affidabile.</span><span class="sxs-lookup"><span data-stu-id="77acf-135">hello `Microsoft.ServiceFabric.Services.AspNetCore.*` NuGet packages contain implementations of `ICommunicationListener` that start and manage hello ASP.NET Core WebHost for either Kestrel or WebListener in a Reliable Service.</span></span>

![Hosting di ASP.NET Core in un servizio Reliable Services][1]

## <a name="aspnet-core-icommunicationlisteners"></a><span data-ttu-id="77acf-137">ICommunicationListeners ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="77acf-137">ASP.NET Core ICommunicationListeners</span></span>
<span data-ttu-id="77acf-138">Hello `ICommunicationListener` implementazioni per Kestrel e WebListener in hello `Microsoft.ServiceFabric.Services.AspNetCore.*` pacchetti NuGet sono modelli di utilizzo simili ma eseguire i server web tooeach specifico di azioni leggermente diverse.</span><span class="sxs-lookup"><span data-stu-id="77acf-138">hello `ICommunicationListener` implementations for Kestrel and WebListener in hello  `Microsoft.ServiceFabric.Services.AspNetCore.*` NuGet packages have similar use patterns but perform slightly different actions specific tooeach web server.</span></span> 

<span data-ttu-id="77acf-139">Entrambi i listener di comunicazione forniscono un costruttore che accetta hello gli argomenti seguenti:</span><span class="sxs-lookup"><span data-stu-id="77acf-139">Both communication listeners provide a constructor that takes hello following arguments:</span></span>
 - <span data-ttu-id="77acf-140">**`ServiceContext serviceContext`**: hello `ServiceContext` oggetto contenente informazioni sul servizio hello.</span><span class="sxs-lookup"><span data-stu-id="77acf-140">**`ServiceContext serviceContext`**: hello `ServiceContext` object that contains information about hello running service.</span></span>
 - <span data-ttu-id="77acf-141">**`string endpointName`**: nome hello un `Endpoint` configurazione in ServiceManifest.xml.</span><span class="sxs-lookup"><span data-stu-id="77acf-141">**`string endpointName`**: hello name of an `Endpoint` configuration in ServiceManifest.xml.</span></span> <span data-ttu-id="77acf-142">Si tratta principalmente in cui il listener di comunicazione hello due diversi: WebListener **richiede** un `Endpoint` configurazione, mentre non Kestrel.</span><span class="sxs-lookup"><span data-stu-id="77acf-142">This is primarily where hello two communication listeners differ: WebListener **requires** an `Endpoint` configuration, while Kestrel does not.</span></span>
 - <span data-ttu-id="77acf-143">**`Func<string, AspNetCoreCommunicationListener, IWebHost> build`**: espressione lambda implementata in cui viene creato e restituito un elemento `IWebHost`.</span><span class="sxs-lookup"><span data-stu-id="77acf-143">**`Func<string, AspNetCoreCommunicationListener, IWebHost> build`**: a lambda that you implement in which you create and return an `IWebHost`.</span></span> <span data-ttu-id="77acf-144">In questo modo è tooconfigure `IWebHost` hello normalmente i in un'applicazione ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="77acf-144">This allows you tooconfigure `IWebHost` hello way you normally would in an ASP.NET Core application.</span></span> <span data-ttu-id="77acf-145">lambda Hello fornisce un URL che viene generato per in base a integrazione di Service Fabric hello opzioni di utilizzo e hello `Endpoint` permette di configurazione.</span><span class="sxs-lookup"><span data-stu-id="77acf-145">hello lambda provides a URL which is generated for you depending on hello Service Fabric integration options you use and hello `Endpoint` configuration you provide.</span></span> <span data-ttu-id="77acf-146">Che URL può quindi essere modificato o se è stato utilizzato come-toostart hello web server.</span><span class="sxs-lookup"><span data-stu-id="77acf-146">That URL can then be modified or used as-is toostart hello web server.</span></span>

## <a name="service-fabric-integration-middleware"></a><span data-ttu-id="77acf-147">Middleware di integrazione di Service Fabric</span><span class="sxs-lookup"><span data-stu-id="77acf-147">Service Fabric integration middleware</span></span>
<span data-ttu-id="77acf-148">Hello `Microsoft.ServiceFabric.Services.AspNetCore` pacchetto NuGet include hello `UseServiceFabricIntegration` metodo di estensione su `IWebHostBuilder` che aggiunge middleware che supporta Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="77acf-148">hello `Microsoft.ServiceFabric.Services.AspNetCore` NuGet package includes hello `UseServiceFabricIntegration` extension method on `IWebHostBuilder` that adds Service Fabric-aware middleware.</span></span> <span data-ttu-id="77acf-149">Consente di configurare questo middleware hello Kestrel o WebListener `ICommunicationListener` tooregister hello Service Fabric Naming Service e quindi la convalida di un URL di servizio univoco con servizio corretto toohello connessione dei client di tooensure di richieste client.</span><span class="sxs-lookup"><span data-stu-id="77acf-149">This middleware configures hello Kestrel or WebListener `ICommunicationListener` tooregister a unique service URL with hello Service Fabric Naming Service and then validates client requests tooensure clients are connecting toohello right service.</span></span> <span data-ttu-id="77acf-150">Ciò è necessario in un ambiente host condiviso, ad esempio Service Fabric, in cui è possono eseguire su hello stesso fisico o macchina virtuale ma non utilizzano nomi host univoco, ai client di tooprevent erroneamente connessione servizio errato toohello più applicazioni web.</span><span class="sxs-lookup"><span data-stu-id="77acf-150">This is necessary in a shared-host environment such as Service Fabric, where multiple web applications can run on hello same physical or virtual machine but do not use unique host names, tooprevent clients from mistakenly connecting toohello wrong service.</span></span> <span data-ttu-id="77acf-151">Questo scenario viene descritto più dettagliatamente nella sezione successiva hello.</span><span class="sxs-lookup"><span data-stu-id="77acf-151">This scenario is described in more detail in hello next section.</span></span>

### <a name="a-case-of-mistaken-identity"></a><span data-ttu-id="77acf-152">Un caso di identità errata</span><span class="sxs-lookup"><span data-stu-id="77acf-152">A case of mistaken identity</span></span>
<span data-ttu-id="77acf-153">Le repliche del servizio, indipendentemente dal protocollo, sono in ascolto in una combinazione IP:porta univoca.</span><span class="sxs-lookup"><span data-stu-id="77acf-153">Service replicas, regardless of protocol, listen on a unique IP:port combination.</span></span> <span data-ttu-id="77acf-154">Una volta avviata una replica del servizio in ascolto su un endpoint creato, viene segnalato che toohello indirizzo endpoint servizio Naming Service Fabric in cui può essere individuata dai client o da altri servizi.</span><span class="sxs-lookup"><span data-stu-id="77acf-154">Once a service replica has started listening on an IP:port endpoint, it reports that endpoint address toohello Service Fabric Naming Service where it can be discovered by clients or other services.</span></span> <span data-ttu-id="77acf-155">Se i servizi di porte assegnate dinamicamente applicazione, una replica del servizio possono utilizzare coincidenza hello stesso endpoint IP: Port di un altro servizio che è stato in precedenza in hello stesso fisico o macchina virtuale.</span><span class="sxs-lookup"><span data-stu-id="77acf-155">If services use dynamically-assigned application ports, a service replica may coincidentally use hello same IP:port endpoint of another service that was previously on hello same physical or virtual machine.</span></span> <span data-ttu-id="77acf-156">Ciò può provocare un client toomistakely connettersi toohello di servizio non valido.</span><span class="sxs-lookup"><span data-stu-id="77acf-156">This can cause a client toomistakely connect toohello wrong service.</span></span> <span data-ttu-id="77acf-157">Questa situazione può verificarsi se si verifica hello seguente sequenza di eventi:</span><span class="sxs-lookup"><span data-stu-id="77acf-157">This can happen if hello following sequence of events occur:</span></span>

 1. <span data-ttu-id="77acf-158">Il servizio A è in ascolto in 10.0.0.1:30000 su HTTP.</span><span class="sxs-lookup"><span data-stu-id="77acf-158">Service A listens on 10.0.0.1:30000 over HTTP.</span></span> 
 2. <span data-ttu-id="77acf-159">Il client risolve il servizio A e ottiene l'indirizzo 10.0.0.1:30000</span><span class="sxs-lookup"><span data-stu-id="77acf-159">Client resolves Service A and gets address 10.0.0.1:30000</span></span>
 3. <span data-ttu-id="77acf-160">Un nodo diverso di spostamenti tooa del servizio.</span><span class="sxs-lookup"><span data-stu-id="77acf-160">Service A moves tooa different node.</span></span>
 4. <span data-ttu-id="77acf-161">Servizio B viene applicato al 10.0.0.1 e coincidenza utilizza hello stessa porta 30000.</span><span class="sxs-lookup"><span data-stu-id="77acf-161">Service B is placed on 10.0.0.1 and coincidentally uses hello same port 30000.</span></span>
 5. <span data-ttu-id="77acf-162">Client tenta tooconnect tooservice A con 10.0.0.1:30000 indirizzi memorizzati nella cache.</span><span class="sxs-lookup"><span data-stu-id="77acf-162">Client attempts tooconnect tooservice A with cached address 10.0.0.1:30000.</span></span>
 6. <span data-ttu-id="77acf-163">Client è ora sia connesso correttamente connesso tooservice B possa toohello di servizio non valido.</span><span class="sxs-lookup"><span data-stu-id="77acf-163">Client is now successfully connected tooservice B not realizing it is connected toohello wrong service.</span></span>

<span data-ttu-id="77acf-164">Ciò può causare errori in momenti casuali che possono essere difficile toodiagnose.</span><span class="sxs-lookup"><span data-stu-id="77acf-164">This can cause bugs at random times that can be difficult toodiagnose.</span></span> 

### <a name="using-unique-service-urls"></a><span data-ttu-id="77acf-165">Uso di URL di servizio univoci</span><span class="sxs-lookup"><span data-stu-id="77acf-165">Using unique service URLs</span></span>
<span data-ttu-id="77acf-166">tooprevent, servizi può registrare un toohello endpoint servizio di denominazione con un identificatore univoco e quindi convalidare tale identificatore univoco durante le richieste client.</span><span class="sxs-lookup"><span data-stu-id="77acf-166">tooprevent this, services can post an endpoint toohello Naming Service with a unique identifier, and then validate that unique identifier during client requests.</span></span> <span data-ttu-id="77acf-167">Si tratta di un'azione cooperativa tra servizi in un ambiente attendibile di tenant non ostili.</span><span class="sxs-lookup"><span data-stu-id="77acf-167">This is a cooperative action between services in a non-hostile-tenant trusted environment.</span></span> <span data-ttu-id="77acf-168">Non offre l'autenticazione sicura dei servizi in un ambiente di tenant ostili.</span><span class="sxs-lookup"><span data-stu-id="77acf-168">This does not provide secure service authentication in a hostile-tenant environment.</span></span>

<span data-ttu-id="77acf-169">In un ambiente attendibile, hello middleware che viene aggiunto per hello `UseServiceFabricIntegration` metodo aggiunge automaticamente un indirizzo di toohello identificatore univoco che viene registrato toohello servizio di denominazione e tale identificatore per ogni richiesta di convalida.</span><span class="sxs-lookup"><span data-stu-id="77acf-169">In a trusted environment, hello middleware that's added by hello `UseServiceFabricIntegration` method automatically appends a unique identifier toohello address that is posted toohello Naming Service and validates that identifier on each request.</span></span> <span data-ttu-id="77acf-170">Se non corrisponde a identificatore hello, hello middleware restituisce immediatamente una risposta HTTP 410 Gone.</span><span class="sxs-lookup"><span data-stu-id="77acf-170">If hello identifier does not match, hello middleware immediately returns an HTTP 410 Gone response.</span></span>

<span data-ttu-id="77acf-171">I servizi che usano una porta assegnata dinamicamente devono usare questo middleware.</span><span class="sxs-lookup"><span data-stu-id="77acf-171">Services that use a dynamically-assigned port should make use of this middleware.</span></span>

<span data-ttu-id="77acf-172">I servizi che usano una porta fissa univoca non hanno questo problema in un ambiente collaborativo.</span><span class="sxs-lookup"><span data-stu-id="77acf-172">Services that use a fixed unique port do not have this problem in a cooperative environment.</span></span> <span data-ttu-id="77acf-173">Una porta fissa univoca viene in genere utilizzata per i servizi esterno che è necessaria una porta ben nota per tooconnect applicazioni client per.</span><span class="sxs-lookup"><span data-stu-id="77acf-173">A fixed unique port is typically used for externally-facing services that need a well-known port for client applications tooconnect to.</span></span> <span data-ttu-id="77acf-174">La maggior parte delle applicazioni Web per Internet, ad esempio, usa la porta 80 o 443 per connessioni tramite Web browser.</span><span class="sxs-lookup"><span data-stu-id="77acf-174">For example, most Internet-facing web applications will use port 80 or 443 for web browser connections.</span></span> <span data-ttu-id="77acf-175">Identificatore univoco di hello in questo caso, non deve essere abilitata.</span><span class="sxs-lookup"><span data-stu-id="77acf-175">In this case, hello unique identifier should not be enabled.</span></span>

<span data-ttu-id="77acf-176">Hello diagramma seguente mostra il flusso di richiesta hello con middleware hello abilitato:</span><span class="sxs-lookup"><span data-stu-id="77acf-176">hello following diagram shows hello request flow with hello middleware enabled:</span></span>

![Integrazione ASP.NET Core di Service Fabric][2]

<span data-ttu-id="77acf-178">Kestrel sia WebListener `ICommunicationListener` implementazioni usano questo meccanismo in hello esattamente allo stesso modo.</span><span class="sxs-lookup"><span data-stu-id="77acf-178">Both Kestrel and WebListener `ICommunicationListener` implementations use this mechanism in exactly hello same way.</span></span> <span data-ttu-id="77acf-179">Sebbene WebListener internamente in grado di distinguere le richieste in base ai percorsi di URL univoci utilizzando hello sottostante *http.sys* funzionalità, la funzionalità di condivisione delle porte *non* utilizzato da hello WebListener `ICommunicationListener` implementazione perché che causano codici di stato errore HTTP 503 e HTTP 404 nello scenario di hello descritto in precedenza.</span><span class="sxs-lookup"><span data-stu-id="77acf-179">Although WebListener can internally differentiate requests based on unique URL paths using hello underlying *http.sys* port sharing feature, that functionality is *not* used by hello WebListener `ICommunicationListener` implementation because that will result in HTTP 503 and HTTP 404 error status codes in hello scenario described earlier.</span></span> <span data-ttu-id="77acf-180">Che a sua volta rende molto difficile per finalità di hello client toodetermine di errore hello, come HTTP 503 e HTTP 404 sono già utilizzati tooindicate altri errori.</span><span class="sxs-lookup"><span data-stu-id="77acf-180">That in turn makes it very difficult for clients toodetermine hello intent of hello error, as HTTP 503 and HTTP 404 are already commonly used tooindicate other errors.</span></span> <span data-ttu-id="77acf-181">Di conseguenza, Kestrel e WebListener `ICommunicationListener` implementazioni standardizzare middleware hello fornito da hello `UseServiceFabricIntegration` metodo di estensione in modo che i client devono solo un endpoint del servizio tooperform risolvere azione su risposte HTTP 410.</span><span class="sxs-lookup"><span data-stu-id="77acf-181">Thus, both Kestrel and WebListener `ICommunicationListener` implementations standardize on hello middleware provided by hello `UseServiceFabricIntegration` extension method so that clients only need tooperform a service endpoint re-resolve action on HTTP 410 responses.</span></span>

## <a name="weblistener-in-reliable-services"></a><span data-ttu-id="77acf-182">WebListener in Reliable Services</span><span class="sxs-lookup"><span data-stu-id="77acf-182">WebListener in Reliable Services</span></span>
<span data-ttu-id="77acf-183">WebListener può essere utilizzato in un servizio affidabile importando hello **Microsoft.ServiceFabric.AspNetCore.WebListener** pacchetto NuGet.</span><span class="sxs-lookup"><span data-stu-id="77acf-183">WebListener can be used in a Reliable Service by importing hello **Microsoft.ServiceFabric.AspNetCore.WebListener** NuGet package.</span></span> <span data-ttu-id="77acf-184">Questo pacchetto contiene `WebListenerCommunicationListener`, un'implementazione di `ICommunicationListener`, che consente un WebHost Core ASP.NET all'interno di un servizio affidabile toocreate utilizzando WebListener come server web hello.</span><span class="sxs-lookup"><span data-stu-id="77acf-184">This package contains `WebListenerCommunicationListener`, an implementation of `ICommunicationListener`, that allows you toocreate an ASP.NET Core WebHost inside a Reliable Service using WebListener as hello web server.</span></span>

<span data-ttu-id="77acf-185">WebListener si basa su hello [API Server HTTP di Windows](https://msdn.microsoft.com/library/windows/desktop/aa364510(v=vs.85).aspx).</span><span class="sxs-lookup"><span data-stu-id="77acf-185">WebListener is built on hello [Windows HTTP Server API](https://msdn.microsoft.com/library/windows/desktop/aa364510(v=vs.85).aspx).</span></span> <span data-ttu-id="77acf-186">Questo metodo utilizza hello *http.sys* driver kernel utilizzato da IIS tooprocess HTTP richieste e loro tooprocesses eseguire applicazioni web di route.</span><span class="sxs-lookup"><span data-stu-id="77acf-186">This uses hello *http.sys* kernel driver used by IIS tooprocess HTTP requests and route them tooprocesses running web applications.</span></span> <span data-ttu-id="77acf-187">Ciò consente a più processi in hello stessa macchina virtuale o fisica toohost applicazioni web su hello stessa porta, identificata dal nome host o percorso URL univoco.</span><span class="sxs-lookup"><span data-stu-id="77acf-187">This allows multiple processes on hello same physical or virtual machine toohost web applications on hello same port, disambiguated by either a unique URL path or hostname.</span></span> <span data-ttu-id="77acf-188">Tali caratteristiche risultano utili in Service Fabric per ospitare più siti Web in hello dello stesso cluster.</span><span class="sxs-lookup"><span data-stu-id="77acf-188">These features are useful in Service Fabric for hosting multiple websites in hello same cluster.</span></span>

<span data-ttu-id="77acf-189">Hello diagramma seguente illustra come WebListener utilizza hello *http.sys* driver kernel di Windows per la condivisione delle porte:</span><span class="sxs-lookup"><span data-stu-id="77acf-189">hello following diagram illustrates how WebListener uses hello *http.sys* kernel driver on Windows for port sharing:</span></span>

![http.sys][3]

### <a name="weblistener-in-a-stateless-service"></a><span data-ttu-id="77acf-191">WebListener in un servizio senza stato</span><span class="sxs-lookup"><span data-stu-id="77acf-191">WebListener in a stateless service</span></span>
<span data-ttu-id="77acf-192">toouse `WebListener` in un servizio senza stato, eseguire l'override hello `CreateServiceInstanceListeners` metodo e restituire un `WebListenerCommunicationListener` istanza:</span><span class="sxs-lookup"><span data-stu-id="77acf-192">toouse `WebListener` in a stateless service, override hello `CreateServiceInstanceListeners` method and return a `WebListenerCommunicationListener` instance:</span></span>

```csharp
protected override IEnumerable<ServiceInstanceListener> CreateServiceInstanceListeners()
{
    return new ServiceInstanceListener[]
    {
        new ServiceInstanceListener(serviceContext =>
            new WebListenerCommunicationListener(serviceContext, "ServiceEndpoint", (url, listener) =>
                new WebHostBuilder()
                    .UseWebListener()
                    .ConfigureServices(
                        services => services
                            .AddSingleton<StatelessServiceContext>(serviceContext))
                    .UseContentRoot(Directory.GetCurrentDirectory())
                    .UseServiceFabricIntegration(listener, ServiceFabricIntegrationOptions.None)
                    .UseStartup<Startup>()
                    .UseUrls(url)
                    .Build()))
    };
}
```

### <a name="weblistener-in-a-stateful-service"></a><span data-ttu-id="77acf-193">WebListener in un servizio con stato</span><span class="sxs-lookup"><span data-stu-id="77acf-193">WebListener in a stateful service</span></span>

<span data-ttu-id="77acf-194">`WebListenerCommunicationListener`non è attualmente progettato per l'utilizzo nei servizi con stati scadenza toocomplications con hello sottostante *http.sys* funzionalità di condivisione delle porte.</span><span class="sxs-lookup"><span data-stu-id="77acf-194">`WebListenerCommunicationListener` is currently not designed for use in stateful services due toocomplications with hello underlying *http.sys* port sharing feature.</span></span> <span data-ttu-id="77acf-195">Per ulteriori informazioni, vedere l'argomento seguente sezione sull'allocazione delle porte dinamiche con WebListener hello.</span><span class="sxs-lookup"><span data-stu-id="77acf-195">For more information, see hello following section on dynamic port allocation with WebListener.</span></span> <span data-ttu-id="77acf-196">Per i servizi con stati, Kestrel è hello consigliato di server web.</span><span class="sxs-lookup"><span data-stu-id="77acf-196">For stateful services, Kestrel is hello recommended web server.</span></span>

### <a name="endpoint-configuration"></a><span data-ttu-id="77acf-197">Configurazione dell'endpoint</span><span class="sxs-lookup"><span data-stu-id="77acf-197">Endpoint configuration</span></span>

<span data-ttu-id="77acf-198">Un `Endpoint` configurazione è necessaria per server web che utilizzano API Server HTTP di Windows, tra cui WebListener hello.</span><span class="sxs-lookup"><span data-stu-id="77acf-198">An `Endpoint` configuration is required for web servers that use hello Windows HTTP Server API, including WebListener.</span></span> <span data-ttu-id="77acf-199">Server Web che utilizzano API Server HTTP di Windows hello prima di tutto necessario riservare l'URL con *http.sys* (questa operazione viene in genere eseguita con hello [netsh](https://msdn.microsoft.com/library/windows/desktop/cc307236(v=vs.85).aspx) strumento).</span><span class="sxs-lookup"><span data-stu-id="77acf-199">Web servers that use hello Windows HTTP Server API must first reserve their URL with *http.sys* (this is normally accomplished with hello [netsh](https://msdn.microsoft.com/library/windows/desktop/cc307236(v=vs.85).aspx) tool).</span></span> <span data-ttu-id="77acf-200">Questa azione richiede privilegi elevati che i servizi non hanno per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="77acf-200">This action requires elevated privileges that your services by default do not have.</span></span> <span data-ttu-id="77acf-201">Hello "http" o "https" Opzioni di hello `Protocol` proprietà di hello `Endpoint` configurazione *ServiceManifest.xml* vengono utilizzati in particolare tooinstruct hello Service Fabric runtime tooregister un URL con *http.sys* per conto dell'utente utilizzando hello [ *carattere jolly complesso* ](https://msdn.microsoft.com/library/windows/desktop/aa364698(v=vs.85).aspx) prefisso dell'URL.</span><span class="sxs-lookup"><span data-stu-id="77acf-201">hello "http" or "https" options for hello `Protocol` property of hello `Endpoint` configuration in *ServiceManifest.xml* are used specifically tooinstruct hello Service Fabric runtime tooregister a URL with *http.sys* on your behalf using hello [*strong wildcard*](https://msdn.microsoft.com/library/windows/desktop/aa364698(v=vs.85).aspx) URL prefix.</span></span>

<span data-ttu-id="77acf-202">Ad esempio, tooreserve `http://+:80` per un servizio, hello configurazione seguente deve essere utilizzata in ServiceManifest.xml:</span><span class="sxs-lookup"><span data-stu-id="77acf-202">For example, tooreserve `http://+:80` for a service, hello following configuration should be used in ServiceManifest.xml:</span></span>

```xml
<ServiceManifest ... >
    ...
    <Resources>
        <Endpoints>
            <Endpoint Name="ServiceEndpoint" Protocol="http" Port="80" />
        </Endpoints>
    </Resources>

</ServiceManifest>
```

<span data-ttu-id="77acf-203">E il nome dell'endpoint hello deve essere passato toohello `WebListenerCommunicationListener` costruttore:</span><span class="sxs-lookup"><span data-stu-id="77acf-203">And hello endpoint name must be passed toohello `WebListenerCommunicationListener` constructor:</span></span>

```csharp
 new WebListenerCommunicationListener(serviceContext, "ServiceEndpoint", (url, listener) =>
 {
     return new WebHostBuilder()
         .UseWebListener()
         .UseServiceFabricIntegration(listener, ServiceFabricIntegrationOptions.None)
         .UseUrls(url)
         .Build();
 })
```

#### <a name="use-weblistener-with-a-static-port"></a><span data-ttu-id="77acf-204">Usare WebListener con una porta statica</span><span class="sxs-lookup"><span data-stu-id="77acf-204">Use WebListener with a static port</span></span>
<span data-ttu-id="77acf-205">toouse una porta statica con WebListener, specificare il numero di porta hello in hello `Endpoint` configurazione:</span><span class="sxs-lookup"><span data-stu-id="77acf-205">toouse a static port with WebListener, provide hello port number in hello `Endpoint` configuration:</span></span>

```xml
  <Resources>
    <Endpoints>
      <Endpoint Protocol="http" Name="ServiceEndpoint" Port="80" />
    </Endpoints>
  </Resources>
```

#### <a name="use-weblistener-with-a-dynamic-port"></a><span data-ttu-id="77acf-206">Usare WebListener con una porta dinamica</span><span class="sxs-lookup"><span data-stu-id="77acf-206">Use WebListener with a dynamic port</span></span>
<span data-ttu-id="77acf-207">una porta assegnata dinamicamente con WebListener, toouse omettere hello `Port` proprietà hello `Endpoint` configurazione:</span><span class="sxs-lookup"><span data-stu-id="77acf-207">toouse a dynamically assigned port with WebListener, omit hello `Port` property in hello `Endpoint` configuration:</span></span>

```xml
  <Resources>
    <Endpoints>
      <Endpoint Protocol="http" Name="ServiceEndpoint" />
    </Endpoints>
  </Resources>
```

<span data-ttu-id="77acf-208">Si noti che una porta dinamica allocata da una configurazione `Endpoint` fornisce una sola porta *per ogni processo host*.</span><span class="sxs-lookup"><span data-stu-id="77acf-208">Note that a dynamic port allocated by an `Endpoint` configuration only provides one port *per host process*.</span></span> <span data-ttu-id="77acf-209">Hello corrente Service Fabric, modello di hosting consente più servizio istanze e/o repliche toobe ospitati in hello stessa procedura adottata, vale a dire che ciascuna di esse condivideranno la stessa porta quando allocata tramite hello hello `Endpoint` configurazione.</span><span class="sxs-lookup"><span data-stu-id="77acf-209">hello current Service Fabric hosting model allows multiple service instances and/or replicas toobe hosted in hello same process, meaning that each one will share hello same port when allocated through hello `Endpoint` configuration.</span></span> <span data-ttu-id="77acf-210">Più istanze di WebListener possono condividere una porta utilizzando hello sottostante *http.sys* funzionalità, ma che la condivisione delle porte non sono supportata da `WebListenerCommunicationListener` a causa di problemi toohello introduce per le richieste client.</span><span class="sxs-lookup"><span data-stu-id="77acf-210">Multiple WebListener instances can share a port using hello underlying *http.sys* port sharing feature, but that is not supported by `WebListenerCommunicationListener` due toohello complications it introduces for client requests.</span></span> <span data-ttu-id="77acf-211">Per informazioni sull'utilizzo di porte dinamiche, Kestrel è hello consigliato di server web.</span><span class="sxs-lookup"><span data-stu-id="77acf-211">For dynamic port usage, Kestrel is hello recommended web server.</span></span>

## <a name="kestrel-in-reliable-services"></a><span data-ttu-id="77acf-212">Kestrel in Reliable Services</span><span class="sxs-lookup"><span data-stu-id="77acf-212">Kestrel in Reliable Services</span></span>
<span data-ttu-id="77acf-213">Kestrel può essere utilizzato in un servizio affidabile importando hello **Microsoft.ServiceFabric.AspNetCore.Kestrel** pacchetto NuGet.</span><span class="sxs-lookup"><span data-stu-id="77acf-213">Kestrel can be used in a Reliable Service by importing hello **Microsoft.ServiceFabric.AspNetCore.Kestrel** NuGet package.</span></span> <span data-ttu-id="77acf-214">Questo pacchetto contiene `KestrelCommunicationListener`, un'implementazione di `ICommunicationListener`, che consente un WebHost Core ASP.NET all'interno di un servizio affidabile toocreate utilizzando Kestrel come server web hello.</span><span class="sxs-lookup"><span data-stu-id="77acf-214">This package contains `KestrelCommunicationListener`, an implementation of `ICommunicationListener`, that allows you toocreate an ASP.NET Core WebHost inside a Reliable Service using Kestrel as hello web server.</span></span>

<span data-ttu-id="77acf-215">Kestrel è che un server Web multipiattaforma per ASP.NET Core basato su libuv, una libreria I/O asincrona multipiattaforma.</span><span class="sxs-lookup"><span data-stu-id="77acf-215">Kestrel is a cross-platform web server for ASP.NET Core based on libuv, a cross-platform asynchronous I/O library.</span></span> <span data-ttu-id="77acf-216">A differenza di WebListener, Kestrel non usa una gestione centralizzata dell'endpoint come *http.sys*.</span><span class="sxs-lookup"><span data-stu-id="77acf-216">Unlike WebListener, Kestrel does not use a centralized endpoint manager such as *http.sys*.</span></span> <span data-ttu-id="77acf-217">A differenza di WebListener, Kestrel non supporta la condivisione delle porte tra più processi.</span><span class="sxs-lookup"><span data-stu-id="77acf-217">And unlike WebListener, Kestrel does not support port sharing between multiple processes.</span></span> <span data-ttu-id="77acf-218">Ogni istanza di Kestrel deve usare una porta univoca.</span><span class="sxs-lookup"><span data-stu-id="77acf-218">Each instance of Kestrel must use a unique port.</span></span>

![kestrel][4]

### <a name="kestrel-in-a-stateless-service"></a><span data-ttu-id="77acf-220">Kestrel in un servizio senza stato</span><span class="sxs-lookup"><span data-stu-id="77acf-220">Kestrel in a stateless service</span></span>
<span data-ttu-id="77acf-221">toouse `Kestrel` in un servizio senza stato, eseguire l'override hello `CreateServiceInstanceListeners` metodo e restituire un `KestrelCommunicationListener` istanza:</span><span class="sxs-lookup"><span data-stu-id="77acf-221">toouse `Kestrel` in a stateless service, override hello `CreateServiceInstanceListeners` method and return a `KestrelCommunicationListener` instance:</span></span>

```csharp
protected override IEnumerable<ServiceInstanceListener> CreateServiceInstanceListeners()
{
    return new ServiceInstanceListener[]
    {
        new ServiceInstanceListener(serviceContext =>
            new KestrelCommunicationListener(serviceContext, "ServiceEndpoint", (url, listener) =>
                new WebHostBuilder()
                    .UseKestrel()
                    .ConfigureServices(
                        services => services
                            .AddSingleton<StatelessServiceContext>(serviceContext))
                    .UseContentRoot(Directory.GetCurrentDirectory())
                    .UseServiceFabricIntegration(listener, ServiceFabricIntegrationOptions.UseUniqueServiceUrl)
                    .UseStartup<Startup>()
                    .UseUrls(url)
                    .Build();
            ))
    };
}
```

### <a name="kestrel-in-a-stateful-service"></a><span data-ttu-id="77acf-222">Kestrel in un servizio con stato</span><span class="sxs-lookup"><span data-stu-id="77acf-222">Kestrel in a stateful service</span></span>
<span data-ttu-id="77acf-223">toouse `Kestrel` in un servizio con stato, eseguire l'override hello `CreateServiceReplicaListeners` metodo e restituire un `KestrelCommunicationListener` istanza:</span><span class="sxs-lookup"><span data-stu-id="77acf-223">toouse `Kestrel` in a stateful service, override hello `CreateServiceReplicaListeners` method and return a `KestrelCommunicationListener` instance:</span></span>

```csharp
protected override IEnumerable<ServiceReplicaListener> CreateServiceReplicaListeners()
{
    return new ServiceReplicaListener[]
    {
        new ServiceReplicaListener(serviceContext =>
            new KestrelCommunicationListener(serviceContext, (url, listener) =>
                new WebHostBuilder()
                    .UseKestrel()
                    .ConfigureServices(
                         services => services
                             .AddSingleton<StatefulServiceContext>(serviceContext)
                             .AddSingleton<IReliableStateManager>(this.StateManager))
                    .UseContentRoot(Directory.GetCurrentDirectory())
                    .UseServiceFabricIntegration(listener, ServiceFabricIntegrationOptions.UseUniqueServiceUrl)
                    .UseStartup<Startup>()
                    .UseUrls(url)
                    .Build();
            ))
    };
}
```

<span data-ttu-id="77acf-224">In questo esempio, un'istanza singleton del `IReliableStateManager` toohello WebHost contenitore dell'inserimento di dipendenza è disponibile.</span><span class="sxs-lookup"><span data-stu-id="77acf-224">In this example, a singleton instance of `IReliableStateManager` is provided toohello WebHost dependency injection container.</span></span> <span data-ttu-id="77acf-225">Questo non è strettamente necessario, ma consente toouse `IReliableStateManager` e affidabile raccolte nei metodi di azione di controller MVC.</span><span class="sxs-lookup"><span data-stu-id="77acf-225">This is not strictly necessary, but it allows you toouse `IReliableStateManager` and Reliable Collections in your MVC controller action methods.</span></span>

<span data-ttu-id="77acf-226">Si noti che un `Endpoint` nome di configurazione **non** fornito troppo`KestrelCommunicationListener` in un servizio con stato.</span><span class="sxs-lookup"><span data-stu-id="77acf-226">Note that an `Endpoint` configuration name is **not** provided too`KestrelCommunicationListener` in a stateful service.</span></span> <span data-ttu-id="77acf-227">Ciò è illustrato più dettagliatamente nella seguente sezione hello.</span><span class="sxs-lookup"><span data-stu-id="77acf-227">This is explained in more detail in hello following section.</span></span>

### <a name="endpoint-configuration"></a><span data-ttu-id="77acf-228">Configurazione dell'endpoint</span><span class="sxs-lookup"><span data-stu-id="77acf-228">Endpoint configuration</span></span>
<span data-ttu-id="77acf-229">Un `Endpoint` configurazione non è necessario toouse Kestrel.</span><span class="sxs-lookup"><span data-stu-id="77acf-229">An `Endpoint` configuration is not required toouse Kestrel.</span></span> 

<span data-ttu-id="77acf-230">Kestrel è un server web autonoma semplice. a differenza di WebListener (o HttpListener), non è necessario un `Endpoint` configurazione *ServiceManifest.xml* perché non è necessario toostarting prima registrazione di URL.</span><span class="sxs-lookup"><span data-stu-id="77acf-230">Kestrel is a simple stand-alone web server; unlike WebListener (or HttpListener), it does not need an `Endpoint` configuration in *ServiceManifest.xml* because it does not require URL registration prior toostarting.</span></span> 

#### <a name="use-kestrel-with-a-static-port"></a><span data-ttu-id="77acf-231">Usare Kestrel con una porta statica</span><span class="sxs-lookup"><span data-stu-id="77acf-231">Use Kestrel with a static port</span></span>
<span data-ttu-id="77acf-232">È possibile configurare una porta statica in hello `Endpoint` ServiceManifest.xml la configurazione per l'utilizzo con Kestrel.</span><span class="sxs-lookup"><span data-stu-id="77acf-232">A static port can be configured in hello `Endpoint` configuration of ServiceManifest.xml for use with Kestrel.</span></span> <span data-ttu-id="77acf-233">Anche se non è strettamente necessaria, questa operazione offre due vantaggi potenziali:</span><span class="sxs-lookup"><span data-stu-id="77acf-233">Although this is not strictly necessary, it provides two potential benefits:</span></span>
 1. <span data-ttu-id="77acf-234">Se la porta hello non è compreso nell'intervallo di porte applicazione hello, viene aperta tramite firewall del sistema operativo hello dall'infrastruttura del servizio.</span><span class="sxs-lookup"><span data-stu-id="77acf-234">If hello port does not fall in hello application port range, it is opened through hello OS firewall by Service Fabric.</span></span>
 2. <span data-ttu-id="77acf-235">Hello tooyou URL fornito tramite `KestrelCommunicationListener` utilizzerà questa porta.</span><span class="sxs-lookup"><span data-stu-id="77acf-235">hello URL provided tooyou through `KestrelCommunicationListener` will use this port.</span></span>

```xml
  <Resources>
    <Endpoints>
      <Endpoint Protocol="http" Name="ServiceEndpoint" Port="80" />
    </Endpoints>
  </Resources>
```

<span data-ttu-id="77acf-236">Se un `Endpoint` è configurato, il nome deve essere passato in hello `KestrelCommunicationListener` costruttore:</span><span class="sxs-lookup"><span data-stu-id="77acf-236">If an `Endpoint` is configured, its name must be passed into hello `KestrelCommunicationListener` constructor:</span></span> 

```csharp
new KestrelCommunicationListener(serviceContext, "ServiceEndpoint", (url, listener) => ...
```

<span data-ttu-id="77acf-237">Se un `Endpoint` configurazione non viene utilizzata, omettere il nome di hello in hello `KestrelCommunicationListener` costruttore.</span><span class="sxs-lookup"><span data-stu-id="77acf-237">If an `Endpoint` configuration is not used, omit hello name in hello `KestrelCommunicationListener` constructor.</span></span> <span data-ttu-id="77acf-238">In questo caso verrà usata una porta dinamica.</span><span class="sxs-lookup"><span data-stu-id="77acf-238">In this case, a dynamic port will be used.</span></span> <span data-ttu-id="77acf-239">Vedere hello sezione successiva per ulteriori informazioni.</span><span class="sxs-lookup"><span data-stu-id="77acf-239">See hello next section for more information.</span></span>

#### <a name="use-kestrel-with-a-dynamic-port"></a><span data-ttu-id="77acf-240">Usare Kestrel con una porta dinamica</span><span class="sxs-lookup"><span data-stu-id="77acf-240">Use Kestrel with a dynamic port</span></span>
<span data-ttu-id="77acf-241">Kestrel non è possibile utilizzare l'assegnazione automatica porta hello da hello `Endpoint` configurazione in ServiceManifest.xml, perché l'assegnazione automatica porta da un `Endpoint` configurazione assegna una porta univoca per ogni *processo host* , e un singolo processo host può contenere più istanze di Kestrel.</span><span class="sxs-lookup"><span data-stu-id="77acf-241">Kestrel cannot use hello automatic port assignment from hello `Endpoint` configuration in ServiceManifest.xml, because automatic port assignment from an `Endpoint` configuration assigns a unique port per *host process*, and a single host process can contain multiple Kestrel instances.</span></span> <span data-ttu-id="77acf-242">Poiché Kestrel non supporta la condivisione delle porte, questa modalità di assegnazione non funziona perché ogni istanza di Kestrel deve essere aperta in una porta univoca.</span><span class="sxs-lookup"><span data-stu-id="77acf-242">Since Kestrel does not support port sharing, this does not work as each Kestrel instance must be opened on a unique port.</span></span>

<span data-ttu-id="77acf-243">assegnazione di porte dinamiche toouse con Kestrel, omettere hello `Endpoint` configurazione in ServiceManifest.xml interamente e che non superano un toohello nome endpoint `KestrelCommunicationListener` costruttore:</span><span class="sxs-lookup"><span data-stu-id="77acf-243">toouse dynamic port assignment with Kestrel, simply omit hello `Endpoint` configuration in ServiceManifest.xml entirely, and do not pass an endpoint name toohello `KestrelCommunicationListener` constructor:</span></span>

```csharp
new KestrelCommunicationListener(serviceContext, (url, listener) => ...
```

<span data-ttu-id="77acf-244">In questa configurazione, `KestrelCommunicationListener` selezionerà automaticamente una porta inutilizzata dall'intervallo di porte applicazione hello.</span><span class="sxs-lookup"><span data-stu-id="77acf-244">In this configuration, `KestrelCommunicationListener` will automatically select an unused port from hello application port range.</span></span>

## <a name="scenarios-and-configurations"></a><span data-ttu-id="77acf-245">Scenari e configurazioni</span><span class="sxs-lookup"><span data-stu-id="77acf-245">Scenarios and configurations</span></span>
<span data-ttu-id="77acf-246">Questa sezione descrive i seguenti scenari hello e fornisce hello consiglia combinazione di server web, la configurazione della porta, le opzioni di integrazione di Service Fabric e tooachieve varie impostazioni di un servizio che funzionano correttamente:</span><span class="sxs-lookup"><span data-stu-id="77acf-246">This section describes hello following scenarios and provides hello recommended combination of web server, port configuration, Service Fabric integration options, and miscellaneous settings tooachieve a properly functioning service:</span></span>
 - <span data-ttu-id="77acf-247">Servizio ASP.NET Core senza stato esposto all'esterno</span><span class="sxs-lookup"><span data-stu-id="77acf-247">Externally exposed ASP.NET Core stateless service</span></span>
 - <span data-ttu-id="77acf-248">Servizio ASP.NET Core senza stato solo interno</span><span class="sxs-lookup"><span data-stu-id="77acf-248">Internal-only ASP.NET Core stateless service</span></span>
 - <span data-ttu-id="77acf-249">Servizio ASP.NET Core con stato solo interno</span><span class="sxs-lookup"><span data-stu-id="77acf-249">Internal-only ASP.NET Core stateful service</span></span>

<span data-ttu-id="77acf-250">Un **esposta esternamente** è un servizio che espone un endpoint raggiungibile all'esterno del cluster di hello, generalmente tramite un servizio di bilanciamento del carico.</span><span class="sxs-lookup"><span data-stu-id="77acf-250">An **externally exposed** service is one that exposes an endpoint reachable from outside hello cluster, usually through a load balancer.</span></span>

<span data-ttu-id="77acf-251">Un **solo interno** del servizio è uno cui endpoint sia raggiungibile all'interno di cluster hello solo.</span><span class="sxs-lookup"><span data-stu-id="77acf-251">An **internal-only** service is one whose endpoint is only reachable from within hello cluster.</span></span>

> [!NOTE]
> <span data-ttu-id="77acf-252">Servizio con stato endpoint non devono in genere essere esposto toohello Internet.</span><span class="sxs-lookup"><span data-stu-id="77acf-252">Stateful service endpoints generally should not be exposed toohello Internet.</span></span> <span data-ttu-id="77acf-253">Cluster protetti da servizi di bilanciamento del carico che non siano informati di risoluzione del servizio Service Fabric, ad esempio hello bilanciamento del carico di Azure, sarà servizi con stato non è possibile tooexpose perché bilanciamento del carico hello non essere in grado di toolocate e indirizzare il traffico toohello replica del servizio con stato appropriato.</span><span class="sxs-lookup"><span data-stu-id="77acf-253">Clusters that are behind load balancers that are unaware of Service Fabric service resolution, such as hello Azure Load Balancer, will be unable tooexpose stateful services because hello load balancer will not be able toolocate and route traffic toohello appropriate stateful service replica.</span></span> 

### <a name="externally-exposed-aspnet-core-stateless-services"></a><span data-ttu-id="77acf-254">Servizi ASP.NET Core senza stato esposti all'esterno</span><span class="sxs-lookup"><span data-stu-id="77acf-254">Externally exposed ASP.NET Core stateless services</span></span>
<span data-ttu-id="77acf-255">WebListener viene consigliato di server web per i servizi front-end che espone gli endpoint HTTP esterni e con connessione Internet in Windows hello.</span><span class="sxs-lookup"><span data-stu-id="77acf-255">WebListener is hello recommended web server for front-end services that expose external, Internet-facing HTTP endpoints on Windows.</span></span> <span data-ttu-id="77acf-256">Offre una migliore protezione dagli attacchi e supporta funzionalità non supportate da Kestrel, ad esempio l'autenticazione di Windows e la condivisione delle porte.</span><span class="sxs-lookup"><span data-stu-id="77acf-256">It provides better protection against attacks and supports features that Kestrel does not, such as Windows Authentication and port sharing.</span></span> 

<span data-ttu-id="77acf-257">Kestrel non è attualmente supportato come server perimetrale per Internet.</span><span class="sxs-lookup"><span data-stu-id="77acf-257">Kestrel is not supported as an edge (Internet-facing) server at this time.</span></span> <span data-ttu-id="77acf-258">È necessario utilizzare un server proxy inverso, ad esempio IIS o Nginx toohandle traffico da hello rete Internet pubblica.</span><span class="sxs-lookup"><span data-stu-id="77acf-258">A reverse proxy server such as IIS or Nginx must be used toohandle traffic from hello public Internet.</span></span>
 
<span data-ttu-id="77acf-259">Quando toohello esposto Internet, un servizio senza stato deve utilizzare un endpoint noto e stabile che sia raggiungibile tramite un servizio di bilanciamento del carico.</span><span class="sxs-lookup"><span data-stu-id="77acf-259">When exposed toohello Internet, a stateless service should use a well-known and stable endpoint that is reachable through a load balancer.</span></span> <span data-ttu-id="77acf-260">Si tratta hello URL si fornirà toousers dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="77acf-260">This is hello URL you will provide toousers of your application.</span></span> <span data-ttu-id="77acf-261">è consigliabile Hello seguente configurazione:</span><span class="sxs-lookup"><span data-stu-id="77acf-261">hello following configuration is recommended:</span></span>

|  |  | <span data-ttu-id="77acf-262">**Note**</span><span class="sxs-lookup"><span data-stu-id="77acf-262">**Notes**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="77acf-263">Server Web</span><span class="sxs-lookup"><span data-stu-id="77acf-263">Web server</span></span> | <span data-ttu-id="77acf-264">WebListener</span><span class="sxs-lookup"><span data-stu-id="77acf-264">WebListener</span></span> | <span data-ttu-id="77acf-265">Se il servizio di hello è solo tooa esposto rete attendibile, una rete intranet, è possibile utilizzare Kestrel.</span><span class="sxs-lookup"><span data-stu-id="77acf-265">If hello service is only exposed tooa trusted network, such an intranet, Kestrel may be used.</span></span> <span data-ttu-id="77acf-266">In caso contrario, WebListener è hello preferito.</span><span class="sxs-lookup"><span data-stu-id="77acf-266">Otherwise, WebListener is hello preferred option.</span></span> |
| <span data-ttu-id="77acf-267">Configurazione delle porte</span><span class="sxs-lookup"><span data-stu-id="77acf-267">Port configuration</span></span> | <span data-ttu-id="77acf-268">Statica</span><span class="sxs-lookup"><span data-stu-id="77acf-268">static</span></span> | <span data-ttu-id="77acf-269">Una porta statica nota deve essere configurata in hello `Endpoints` configurazione di ServiceManifest.xml, ad esempio 80 per HTTP o 443 per HTTPS.</span><span class="sxs-lookup"><span data-stu-id="77acf-269">A well-known static port should be configured in hello `Endpoints` configuration of ServiceManifest.xml, such as 80 for HTTP or 443 for HTTPS.</span></span> |
| <span data-ttu-id="77acf-270">ServiceFabricIntegrationOptions</span><span class="sxs-lookup"><span data-stu-id="77acf-270">ServiceFabricIntegrationOptions</span></span> | <span data-ttu-id="77acf-271">Nessuno</span><span class="sxs-lookup"><span data-stu-id="77acf-271">None</span></span> | <span data-ttu-id="77acf-272">Hello `ServiceFabricIntegrationOptions.None` opzione deve essere utilizzata quando si configura il middleware di integrazione dell'infrastruttura di servizio in modo che il servizio di hello non toovalidate le richieste in ingresso per un identificatore univoco.</span><span class="sxs-lookup"><span data-stu-id="77acf-272">hello `ServiceFabricIntegrationOptions.None` option should be used when configuring Service Fabric integration middleware so that hello service does not attempt toovalidate incoming requests for a unique identifier.</span></span> <span data-ttu-id="77acf-273">Gli utenti esterni di applicazione non riconoscerà hello informazioni di identificazione univoche utilizzate dal middleware hello.</span><span class="sxs-lookup"><span data-stu-id="77acf-273">External users of your application will not know hello unique identifying information used by hello middleware.</span></span> |
| <span data-ttu-id="77acf-274">Conteggio istanze</span><span class="sxs-lookup"><span data-stu-id="77acf-274">Instance Count</span></span> | <span data-ttu-id="77acf-275">-1</span><span class="sxs-lookup"><span data-stu-id="77acf-275">-1</span></span> | <span data-ttu-id="77acf-276">In casi di utilizzo tipico, il numero di istanze hello impostazione deve essere impostato troppo "-1" in modo che un'istanza è disponibile in tutti i nodi che ricevono il traffico dal bilanciamento del carico.</span><span class="sxs-lookup"><span data-stu-id="77acf-276">In typical use cases, hello instance count setting should be set too"-1" so that an instance is available on all nodes that receive traffic from a load balancer.</span></span> |

<span data-ttu-id="77acf-277">Se più servizi esposti esternamente condividono hello stesso set di nodi, utilizzare un percorso URL univoco ma stabile.</span><span class="sxs-lookup"><span data-stu-id="77acf-277">If multiple externally exposed services share hello same set of nodes, a unique but stable URL path should be used.</span></span> <span data-ttu-id="77acf-278">Questo può essere eseguito modificando hello URL fornito quando si configura IWebHost.</span><span class="sxs-lookup"><span data-stu-id="77acf-278">This can be accomplished by modifying hello URL provided when configuring IWebHost.</span></span> <span data-ttu-id="77acf-279">Si noti come che si applica solo a tooWebListener.</span><span class="sxs-lookup"><span data-stu-id="77acf-279">Note this applies tooWebListener only.</span></span>

 ```csharp
 new WebListenerCommunicationListener(serviceContext, "ServiceEndpoint", (url, listener) =>
 {
     url += "/MyUniqueServicePath";
 
     return new WebHostBuilder()
         .UseWebListener()
         ...
         .UseUrls(url)
         .Build();
 })
 ```

### <a name="internal-only-stateless-aspnet-core-service"></a><span data-ttu-id="77acf-280">Servizio ASP.NET Core senza stato solo interno</span><span class="sxs-lookup"><span data-stu-id="77acf-280">Internal-only stateless ASP.NET Core service</span></span>
<span data-ttu-id="77acf-281">I servizi senza stati che vengono chiamati solo da all'interno di cluster hello devono utilizzare URL univoci e le porte assegnate dinamicamente tooensure cooperazione tra più servizi.</span><span class="sxs-lookup"><span data-stu-id="77acf-281">Stateless services that are only called from within hello cluster should use unique URLs and dynamically assigned ports tooensure cooperation between multiple services.</span></span> <span data-ttu-id="77acf-282">è consigliabile Hello seguente configurazione:</span><span class="sxs-lookup"><span data-stu-id="77acf-282">hello following configuration is recommended:</span></span>

|  |  | <span data-ttu-id="77acf-283">**Note**</span><span class="sxs-lookup"><span data-stu-id="77acf-283">**Notes**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="77acf-284">Server Web</span><span class="sxs-lookup"><span data-stu-id="77acf-284">Web server</span></span> | <span data-ttu-id="77acf-285">Kestrel</span><span class="sxs-lookup"><span data-stu-id="77acf-285">Kestrel</span></span> | <span data-ttu-id="77acf-286">Sebbene WebListener possono essere utilizzati per i servizi senza stati interni, Kestrel è hello consigliato tooallow server tooshare istanze di servizio più un host.</span><span class="sxs-lookup"><span data-stu-id="77acf-286">Although WebListener may be used for internal stateless services, Kestrel is hello recommended server tooallow multiple service instances tooshare a host.</span></span>  |
| <span data-ttu-id="77acf-287">Configurazione delle porte</span><span class="sxs-lookup"><span data-stu-id="77acf-287">Port configuration</span></span> | <span data-ttu-id="77acf-288">assegnate in modo dinamico</span><span class="sxs-lookup"><span data-stu-id="77acf-288">dynamically assigned</span></span> | <span data-ttu-id="77acf-289">Più repliche di un servizio con stato possono condividere un processo host o un sistema operativo host e richiedono quindi porte univoche.</span><span class="sxs-lookup"><span data-stu-id="77acf-289">Multiple replicas of a stateful service may share a host process or host operating system and thus will need unique ports.</span></span> |
| <span data-ttu-id="77acf-290">ServiceFabricIntegrationOptions</span><span class="sxs-lookup"><span data-stu-id="77acf-290">ServiceFabricIntegrationOptions</span></span> | <span data-ttu-id="77acf-291">UseUniqueServiceUrl</span><span class="sxs-lookup"><span data-stu-id="77acf-291">UseUniqueServiceUrl</span></span> | <span data-ttu-id="77acf-292">Assegnazione di porte dinamiche, questa impostazione impedisce problema identità hello erroneamente descritto in precedenza.</span><span class="sxs-lookup"><span data-stu-id="77acf-292">With dynamic port assignment, this setting prevents hello mistaken identity issue described earlier.</span></span> |
| <span data-ttu-id="77acf-293">InstanceCount</span><span class="sxs-lookup"><span data-stu-id="77acf-293">InstanceCount</span></span> | <span data-ttu-id="77acf-294">qualsiasi</span><span class="sxs-lookup"><span data-stu-id="77acf-294">any</span></span> | <span data-ttu-id="77acf-295">numero di istanze di Hello impostazione può essere impostato del servizio di hello tooany valore toooperate necessarie.</span><span class="sxs-lookup"><span data-stu-id="77acf-295">hello instance count setting can be set tooany value necessary toooperate hello service.</span></span> |

### <a name="internal-only-stateful-aspnet-core-service"></a><span data-ttu-id="77acf-296">Servizio ASP.NET Core con stato solo interno</span><span class="sxs-lookup"><span data-stu-id="77acf-296">Internal-only stateful ASP.NET Core service</span></span>
<span data-ttu-id="77acf-297">I servizi con stati che vengono chiamati solo da all'interno di cluster hello devono utilizzare porte assegnate dinamicamente tooensure cooperazione tra più servizi.</span><span class="sxs-lookup"><span data-stu-id="77acf-297">Stateful services that are only called from within hello cluster should use dynamically assigned ports tooensure cooperation between multiple services.</span></span> <span data-ttu-id="77acf-298">è consigliabile Hello seguente configurazione:</span><span class="sxs-lookup"><span data-stu-id="77acf-298">hello following configuration is recommended:</span></span>

|  |  | <span data-ttu-id="77acf-299">**Note**</span><span class="sxs-lookup"><span data-stu-id="77acf-299">**Notes**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="77acf-300">Server Web</span><span class="sxs-lookup"><span data-stu-id="77acf-300">Web server</span></span> | <span data-ttu-id="77acf-301">Kestrel</span><span class="sxs-lookup"><span data-stu-id="77acf-301">Kestrel</span></span> | <span data-ttu-id="77acf-302">Hello `WebListenerCommunicationListener` non deve essere utilizzato dai servizi con stati in cui le repliche condividono un processo host.</span><span class="sxs-lookup"><span data-stu-id="77acf-302">hello `WebListenerCommunicationListener` is not designed for use by stateful services in which replicas share a host process.</span></span> |
| <span data-ttu-id="77acf-303">Configurazione delle porte</span><span class="sxs-lookup"><span data-stu-id="77acf-303">Port configuration</span></span> | <span data-ttu-id="77acf-304">assegnate in modo dinamico</span><span class="sxs-lookup"><span data-stu-id="77acf-304">dynamically assigned</span></span> | <span data-ttu-id="77acf-305">Più repliche di un servizio con stato possono condividere un processo host o un sistema operativo host e richiedono quindi porte univoche.</span><span class="sxs-lookup"><span data-stu-id="77acf-305">Multiple replicas of a stateful service may share a host process or host operating system and thus will need unique ports.</span></span> |
| <span data-ttu-id="77acf-306">ServiceFabricIntegrationOptions</span><span class="sxs-lookup"><span data-stu-id="77acf-306">ServiceFabricIntegrationOptions</span></span> | <span data-ttu-id="77acf-307">UseUniqueServiceUrl</span><span class="sxs-lookup"><span data-stu-id="77acf-307">UseUniqueServiceUrl</span></span> | <span data-ttu-id="77acf-308">Assegnazione di porte dinamiche, questa impostazione impedisce problema identità hello erroneamente descritto in precedenza.</span><span class="sxs-lookup"><span data-stu-id="77acf-308">With dynamic port assignment, this setting prevents hello mistaken identity issue described earlier.</span></span> |

## <a name="next-steps"></a><span data-ttu-id="77acf-309">Passaggi successivi</span><span class="sxs-lookup"><span data-stu-id="77acf-309">Next steps</span></span>
[<span data-ttu-id="77acf-310">Debug dell'applicazione di Service Fabric mediante Visual Studio</span><span class="sxs-lookup"><span data-stu-id="77acf-310">Debug your Service Fabric application by using Visual Studio</span></span>](service-fabric-debugging-your-application.md)

<!--Image references-->
[0]:./media/service-fabric-reliable-services-communication-aspnetcore/webhost-standalone.png
[1]:./media/service-fabric-reliable-services-communication-aspnetcore/webhost-servicefabric.png
[2]:./media/service-fabric-reliable-services-communication-aspnetcore/integration.png
[3]:./media/service-fabric-reliable-services-communication-aspnetcore/httpsys.png
[4]:./media/service-fabric-reliable-services-communication-aspnetcore/kestrel.png
