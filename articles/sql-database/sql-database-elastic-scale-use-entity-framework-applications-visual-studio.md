---
title: Uso della libreria client dei database elastici con Entity Framework | Documentazione Microsoft
description: Usare la libreria client del database elastico e Entity Framework per la codifica di database
services: sql-database
documentationcenter: 
manager: jhubbard
author: torsteng
editor: 
ms.assetid: b9c3065b-cb92-41be-aa7f-deba23e7e159
ms.service: sql-database
ms.custom: scale out apps
ms.workload: sql-database
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 03/06/2017
ms.author: torsteng
ms.openlocfilehash: 2f0bff394c1e11a270cb324be5a1a45e9e531d7f
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/11/2017
---
# <a name="elastic-database-client-library-with-entity-framework"></a><span data-ttu-id="19a35-103">Libreria client dei database elastici con Entity Framework</span><span class="sxs-lookup"><span data-stu-id="19a35-103">Elastic Database client library with Entity Framework</span></span>
<span data-ttu-id="19a35-104">Questo documento illustra le modifiche necessarie in un'applicazione Entity Framework per l'integrazione con le funzionalità degli [strumenti del database elastico](sql-database-elastic-scale-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="19a35-104">This document shows the changes in an Entity Framework application that are needed to integrate with the [Elastic Database tools](sql-database-elastic-scale-introduction.md).</span></span> <span data-ttu-id="19a35-105">Vengono descritti in particolare la [gestione delle mappe partizioni](sql-database-elastic-scale-shard-map-management.md) e il [routing dipendente dai dati](sql-database-elastic-scale-data-dependent-routing.md) con l'approccio **Code First** di Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="19a35-105">The focus is on composing [shard map management](sql-database-elastic-scale-shard-map-management.md) and [data-dependent routing](sql-database-elastic-scale-data-dependent-routing.md) with the Entity Framework **Code First** approach.</span></span> <span data-ttu-id="19a35-106">L'esercitazione [Code First per un nuovo database](http://msdn.microsoft.com/data/jj193542.aspx) per Entity Framework servirà da esempio nell'intero documento.</span><span class="sxs-lookup"><span data-stu-id="19a35-106">The [Code First - New Database](http://msdn.microsoft.com/data/jj193542.aspx) tutorial for EF serves as our running example throughout this document.</span></span> <span data-ttu-id="19a35-107">Il codice di esempio che accompagna questo documento fa parte del set di esempi sugli strumenti dei database elastici negli esempi di codice di Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="19a35-107">The sample code accompanying this document is part of elastic database tools' set of samples in the Visual Studio Code Samples.</span></span>

## <a name="downloading-and-running-the-sample-code"></a><span data-ttu-id="19a35-108">Download ed esecuzione del codice di esempio</span><span class="sxs-lookup"><span data-stu-id="19a35-108">Downloading and Running the Sample Code</span></span>
<span data-ttu-id="19a35-109">Per scaricare il codice per questo articolo:</span><span class="sxs-lookup"><span data-stu-id="19a35-109">To download the code for this article:</span></span>

* <span data-ttu-id="19a35-110">È richiesto Visual Studio 2012 o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="19a35-110">Visual Studio 2012 or later is required.</span></span> 
* <span data-ttu-id="19a35-111">Scaricare l'esempio [Elastic DB Tools for Azure SQL - Entity Framework Integration](https://code.msdn.microsoft.com/windowsapps/Elastic-Scale-with-Azure-bae904ba) (Strumenti del database elastico per SQL di Azure - Integrazione con Entity Framework) da MSDN.</span><span class="sxs-lookup"><span data-stu-id="19a35-111">Download the [Elastic DB Tools for Azure SQL - Entity Framework Integration sample](https://code.msdn.microsoft.com/windowsapps/Elastic-Scale-with-Azure-bae904ba) from MSDN.</span></span> <span data-ttu-id="19a35-112">Decomprimere l'esempio in un percorso a piacere.</span><span class="sxs-lookup"><span data-stu-id="19a35-112">Unzip the sample to a location of your choosing.</span></span>
* <span data-ttu-id="19a35-113">Avviare Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="19a35-113">Start Visual Studio.</span></span> 
* <span data-ttu-id="19a35-114">In Visual Studio selezionare File -> Apri progetto/soluzione.</span><span class="sxs-lookup"><span data-stu-id="19a35-114">In Visual Studio, select File -> Open Project/Solution.</span></span> 
* <span data-ttu-id="19a35-115">Nella finestra di dialogo **Apri progetto** passare all'esempio scaricato e selezionare **EntityFrameworkCodeFirst.sln** per aprirlo.</span><span class="sxs-lookup"><span data-stu-id="19a35-115">In the **Open Project** dialog, navigate to the sample you downloaded and select **EntityFrameworkCodeFirst.sln** to open the sample.</span></span> 

<span data-ttu-id="19a35-116">Per eseguire l'esempio è necessario creare tre database vuoti nel database SQL di Azure:</span><span class="sxs-lookup"><span data-stu-id="19a35-116">To run the sample, you need to create three empty databases in Azure SQL Database:</span></span>

* <span data-ttu-id="19a35-117">Database di gestione delle mappe partizioni</span><span class="sxs-lookup"><span data-stu-id="19a35-117">Shard Map Manager database</span></span>
* <span data-ttu-id="19a35-118">Database partizione 1</span><span class="sxs-lookup"><span data-stu-id="19a35-118">Shard 1 database</span></span>
* <span data-ttu-id="19a35-119">Database partizione 2</span><span class="sxs-lookup"><span data-stu-id="19a35-119">Shard 2 database</span></span>

<span data-ttu-id="19a35-120">Dopo aver creato questi database, riempire i segnaposto nel file **Program.cs** con il nome del server di database SQL di Azure, i nomi dei database e le credenziali per la connessione ai database.</span><span class="sxs-lookup"><span data-stu-id="19a35-120">Once you have created these databases, fill in the place holders in **Program.cs** with your Azure SQL DB server name, the database names and your credentials to connect to the databases.</span></span> <span data-ttu-id="19a35-121">Compilare la soluzione in Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="19a35-121">Build the solution in Visual Studio.</span></span> <span data-ttu-id="19a35-122">Visual Studio scaricherà i pacchetti NuGet necessari per la libreria client dei database elastici, Entity Framework e la gestione degli errori temporanei come parte del processo di compilazione.</span><span class="sxs-lookup"><span data-stu-id="19a35-122">Visual Studio will download the required NuGet packages for the elastic database client library, Entity Framework, and Transient Fault handling as part of the build process.</span></span> <span data-ttu-id="19a35-123">Verificare che per la soluzione sia abilitato il ripristino dei pacchetti NuGet.</span><span class="sxs-lookup"><span data-stu-id="19a35-123">Make sure that restoring NuGet packages is enabled for your solution.</span></span> <span data-ttu-id="19a35-124">Per abilitare questa impostazione, fare clic con il pulsante destro del mouse sul file di soluzione in Esplora soluzioni di Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="19a35-124">You can enable this setting by right-clicking on the solution file in the Visual Studio Solution Explorer.</span></span> 

## <a name="entity-framework-workflows"></a><span data-ttu-id="19a35-125">Flussi di lavoro di Entity Framework</span><span class="sxs-lookup"><span data-stu-id="19a35-125">Entity Framework workflows</span></span>
<span data-ttu-id="19a35-126">Gli sviluppatori Entity Framework si basano su uno dei quattro seguenti flussi di lavoro per compilare le applicazioni e garantire la persistenza degli oggetti applicazione:</span><span class="sxs-lookup"><span data-stu-id="19a35-126">Entity Framework developers rely on one of the following four workflows to build applications and to ensure persistence for application objects:</span></span> 

* <span data-ttu-id="19a35-127">**Code First (nuovo database)**: lo sviluppatore Entity Framework crea il modello nel codice dell'applicazione ed Entity Framework genera il database a partire dal codice.</span><span class="sxs-lookup"><span data-stu-id="19a35-127">**Code First (New Database)**: The EF developer creates the model in the application code and then EF generates the database from it.</span></span> 
* <span data-ttu-id="19a35-128">**Code First (database esistente)**: lo sviluppatore consente a Entity Framework di generare il codice dell'applicazione per il modello da un database esistente.</span><span class="sxs-lookup"><span data-stu-id="19a35-128">**Code First (Existing Database)**: The developer lets EF generate the application code for the model from an existing database.</span></span>
* <span data-ttu-id="19a35-129">**Model First**: lo sviluppatore crea il modello in Entity Framework Designer e quindi Entity Framework crea il database a partire dal modello.</span><span class="sxs-lookup"><span data-stu-id="19a35-129">**Model First**: The developer creates the model in the EF designer and then EF creates the database from the model.</span></span>
* <span data-ttu-id="19a35-130">**Database First**: lo sviluppatore usa gli strumenti di Entity Framework per dedurre il modello da un database esistente.</span><span class="sxs-lookup"><span data-stu-id="19a35-130">**Database First**: The developer uses EF tooling to infer the model from an existing database.</span></span> 

<span data-ttu-id="19a35-131">Tutti questi approcci si basano sulla classe DbContext per gestire in modo trasparente le connessioni di database e lo schema del database per un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="19a35-131">All these approaches rely on the DbContext class to transparently manage database connections and database schema for an application.</span></span> <span data-ttu-id="19a35-132">Come illustrato in dettaglio più avanti nel documento, costruttori diversi della classe base DbContext offrono livelli di controllo diversi sulla creazione delle connessioni, il bootstrap del database e la creazione dello schema.</span><span class="sxs-lookup"><span data-stu-id="19a35-132">As we will discuss in more detail later in the document, different constructors on the DbContext base class allow for different levels of control over connection creation, database bootstrapping and schema creation.</span></span> <span data-ttu-id="19a35-133">Le difficoltà sorgono principalmente dal fatto che la gestione delle connessioni di database fornita da Entity Framework si sovrappone alle funzionalità di gestione connessioni delle interfacce di routing dipendente dai dati fornite dalla libreria client dei database elastici.</span><span class="sxs-lookup"><span data-stu-id="19a35-133">Challenges arise primarily from the fact that the database connection management provided by EF intersects with the connection management capabilities of the data dependent routing interfaces provided by the elastic database client library.</span></span> 

## <a name="elastic-database-tools-assumptions"></a><span data-ttu-id="19a35-134">Presupposti degli strumenti dei database elastici</span><span class="sxs-lookup"><span data-stu-id="19a35-134">Elastic database tools assumptions</span></span>
<span data-ttu-id="19a35-135">Per le definizioni dei termini, vedere il [glossario degli strumenti del database elastico](sql-database-elastic-scale-glossary.md).</span><span class="sxs-lookup"><span data-stu-id="19a35-135">For term definitions, see [Elastic Database tools glossary](sql-database-elastic-scale-glossary.md).</span></span>

<span data-ttu-id="19a35-136">La libreria client dei database elastici consente di definire partizioni dei dati applicativi denominate shardlet.</span><span class="sxs-lookup"><span data-stu-id="19a35-136">With elastic database client library, you define partitions of your application data called shardlets.</span></span> <span data-ttu-id="19a35-137">Gli shardlet sono identificati da una chiave di partizionamento orizzontale e sono mappati a database specifici.</span><span class="sxs-lookup"><span data-stu-id="19a35-137">Shardlets are identified by a sharding key and are mapped to specific databases.</span></span> <span data-ttu-id="19a35-138">Un'applicazione può disporre di tutti i database necessari e distribuire gli shardlet per fornire capacità o prestazioni sufficienti in base ai requisiti aziendali correnti.</span><span class="sxs-lookup"><span data-stu-id="19a35-138">An application may have as many databases as needed and distribute the shardlets to provide enough capacity or performance given current business requirements.</span></span> <span data-ttu-id="19a35-139">Il mapping dei valori delle chiavi di partizionamento orizzontale ai database è archiviato in una mappa partizioni fornita dalle API client dei database elastici.</span><span class="sxs-lookup"><span data-stu-id="19a35-139">The mapping of sharding key values to the databases is stored by a shard map provided by the elastic database client APIs.</span></span> <span data-ttu-id="19a35-140">Questa funzionalità è denominata **Gestione mappe partizioni**.</span><span class="sxs-lookup"><span data-stu-id="19a35-140">We call this capability **Shard Map Management**, or SMM for short.</span></span> <span data-ttu-id="19a35-141">La mappa partizioni funge anche da gestore delle connessioni di database per le richieste che contengono una chiave di partizionamento orizzontale.</span><span class="sxs-lookup"><span data-stu-id="19a35-141">The shard map also serves as the broker of database connections for requests that carry a sharding key.</span></span> <span data-ttu-id="19a35-142">Questa funzionalità viene definita **routing dipendente dai dati**.</span><span class="sxs-lookup"><span data-stu-id="19a35-142">We refer to this capability as **data-dependent routing**.</span></span> 

<span data-ttu-id="19a35-143">Il gestore delle mappe partizioni protegge gli utenti da visualizzazioni incoerenti nei dati degli shardlet potenzialmente provocate dall'esecuzione simultanea di operazioni di gestione degli shardlet, ad esempio la rilocazione di dati da una partizione all'altra.</span><span class="sxs-lookup"><span data-stu-id="19a35-143">The shard map manager protects users from inconsistent views into shardlet data that can occur when concurrent shardlet management operations (such as relocating data from one shard to another) are happening.</span></span> <span data-ttu-id="19a35-144">A tale scopo, le mappe di partizionamento gestite dalla libreria client gestiscono le connessioni al database per un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="19a35-144">To do so, the shard maps managed by the client library broker the database connections for an application.</span></span> <span data-ttu-id="19a35-145">In questo modo la funzionalità mappa partizioni può terminare automaticamente una connessione di database quando le operazioni di gestione delle partizioni potrebbero influire sullo shardlet per cui è stata creata la connessione.</span><span class="sxs-lookup"><span data-stu-id="19a35-145">This allows the shard map functionality to automatically kill a database connection when shard management operations could impact the shardlet that the connection has been created for.</span></span> <span data-ttu-id="19a35-146">Questo approccio richiede l'integrazione con alcune funzionalità di Entity Framework, ad esempio la creazione di nuove connessioni a partire da una connessione esistente per verificare l'esistenza del database.</span><span class="sxs-lookup"><span data-stu-id="19a35-146">This approach needs to integrate with some of EF’s functionality, such as creating new connections from an existing one to check for database existence.</span></span> <span data-ttu-id="19a35-147">In generale, è stato osservato che i costruttori DbContext standard funzionano in modo affidabile solo per le connessioni di database chiuse che possono essere clonate in sicurezza per le operazioni di Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="19a35-147">In general, our observation has been that the standard DbContext constructors only work reliably for closed database connections that can safely be cloned for EF work.</span></span> <span data-ttu-id="19a35-148">Il principio di progettazione dei database elastici prevede invece solo la gestione delle connessioni aperte.</span><span class="sxs-lookup"><span data-stu-id="19a35-148">The design principle of elastic database instead is to only broker opened connections.</span></span> <span data-ttu-id="19a35-149">Si potrebbe pensare che chiudere una connessione gestita dalla libreria client prima di passarla al costruttore DbContext di Entity Framework consenta di risolvere il problema.</span><span class="sxs-lookup"><span data-stu-id="19a35-149">One might think that closing a connection brokered by the client library before handing it over to the EF DbContext may solve this issue.</span></span> <span data-ttu-id="19a35-150">Tuttavia, chiudendo la connessione e affidandone la riapertura a Entity Framework, si rinuncia alla convalida e ai controlli di coerenza eseguiti dalla libreria.</span><span class="sxs-lookup"><span data-stu-id="19a35-150">However, by closing the connection and relying on EF to re-open it, one foregoes the validation and consistency checks performed by the library.</span></span> <span data-ttu-id="19a35-151">La funzionalità per le migrazioni di Entity Framework, tuttavia, usa queste connessioni per gestire lo schema del database sottostante in modo trasparente per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="19a35-151">The migrations functionality in EF, however, uses these connections to manage the underlying database schema in a way that is transparent to the application.</span></span> <span data-ttu-id="19a35-152">La soluzione ideale sarebbe mantenere e combinare tutte le funzionalità della libreria client dei database elastici ed Entity Framework nella stessa applicazione.</span><span class="sxs-lookup"><span data-stu-id="19a35-152">Ideally, we would like to retain and combine all these capabilities from both the elastic database client library and EF in the same application.</span></span> <span data-ttu-id="19a35-153">La seguente sezione illustra queste proprietà e i requisiti in maggiore dettaglio.</span><span class="sxs-lookup"><span data-stu-id="19a35-153">The following section discusses these properties and requirements in more detail.</span></span> 

## <a name="requirements"></a><span data-ttu-id="19a35-154">Requisiti</span><span class="sxs-lookup"><span data-stu-id="19a35-154">Requirements</span></span>
<span data-ttu-id="19a35-155">Quando si usano sia le API della libreria client dei database elastici che di Entity Framework, si vogliono conservare le seguenti proprietà:</span><span class="sxs-lookup"><span data-stu-id="19a35-155">When working with both the elastic database client library and Entity Framework APIs, we want to retain the following properties:</span></span> 

* <span data-ttu-id="19a35-156">**Scalabilità orizzontale**: per aggiungere o rimuovere database dal livello dati dell'applicazione partizionata a seconda delle necessità, per soddisfare le esigenze di capacità dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="19a35-156">**Scale-out**: To add or remove databases from the data tier of the sharded application as necessary for the capacity demands of the application.</span></span> <span data-ttu-id="19a35-157">Ciò significa controllo sulla creazione e sull'eliminazione dei database e uso delle API del gestore delle mappe partizioni del database elastico per gestire i database e i mapping degli shardlet.</span><span class="sxs-lookup"><span data-stu-id="19a35-157">This means control over the the creation and deletion of databases and using the elastic database shard map manager APIs to manage databases, and mappings of shardlets.</span></span> 
* <span data-ttu-id="19a35-158">**Coerenza**: l'applicazione usa il partizionamento orizzontale e si serve delle funzionalità di routing dipendente dai dati della libreria client.</span><span class="sxs-lookup"><span data-stu-id="19a35-158">**Consistency**: The application employs sharding, and uses the data dependent routing capabilities of the client library.</span></span> <span data-ttu-id="19a35-159">Per evitare il danneggiamento dei dati o la restituzione di risultati di query errati, le connessioni vengono gestite tramite il gestore delle mappe partizioni.</span><span class="sxs-lookup"><span data-stu-id="19a35-159">To avoid corruption or wrong query results, connections are brokered through the shard map manager.</span></span> <span data-ttu-id="19a35-160">In questo modo vengono mantenute anche la convalida e la coerenza.</span><span class="sxs-lookup"><span data-stu-id="19a35-160">This also retains validation and consistency.</span></span>
* <span data-ttu-id="19a35-161">**Code First**: per mantenere la praticità del paradigma Code First di Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="19a35-161">**Code First**: To retain the convenience of EF’s code first paradigm.</span></span> <span data-ttu-id="19a35-162">In Code First, le classi nell'applicazione vengono mappate in modo trasparente alle strutture di database sottostanti.</span><span class="sxs-lookup"><span data-stu-id="19a35-162">In Code First, classes in the application are mapped transparently to the underlying database structures.</span></span> <span data-ttu-id="19a35-163">Il codice dell'applicazione interagisce con DbSet che mascherano la maggior parte degli aspetti coinvolti nell'elaborazione di database sottostante.</span><span class="sxs-lookup"><span data-stu-id="19a35-163">The application code interacts with DbSets that mask most aspects involved in the underlying database processing.</span></span>
* <span data-ttu-id="19a35-164">**Schema**: Entity Framework gestisce la creazione iniziale dello schema del database e la successiva evoluzione dello schema mediante migrazioni.</span><span class="sxs-lookup"><span data-stu-id="19a35-164">**Schema**: Entity Framework handles initial database schema creation and subsequent schema evolution through migrations.</span></span> <span data-ttu-id="19a35-165">Conservando queste funzionalità, adattare l'applicazione in base all'evoluzione dei dati è molto semplice.</span><span class="sxs-lookup"><span data-stu-id="19a35-165">By retaining these capabilities, adapting your app is easy as the data evolves.</span></span> 

<span data-ttu-id="19a35-166">Le seguenti informazioni aggiuntive illustrano come soddisfare questi requisiti per le applicazioni Code First usando gli strumenti dei database elastici.</span><span class="sxs-lookup"><span data-stu-id="19a35-166">The following guidance instructs how to satisfy these requirements for Code First applications using elastic database tools.</span></span> 

## <a name="data-dependent-routing-using-ef-dbcontext"></a><span data-ttu-id="19a35-167">Routing dipendente dai dati con DbContext di Entity Framework</span><span class="sxs-lookup"><span data-stu-id="19a35-167">Data dependent routing using EF DbContext</span></span>
<span data-ttu-id="19a35-168">Le connessioni di database con Entity Framework vengono in genere gestite tramite sottoclassi di **DbContext**.</span><span class="sxs-lookup"><span data-stu-id="19a35-168">Database connections with Entity Framework are typically managed through subclasses of **DbContext**.</span></span> <span data-ttu-id="19a35-169">Creare le sottoclassi derivandole da **DbContext**.</span><span class="sxs-lookup"><span data-stu-id="19a35-169">Create these subclasses by deriving from **DbContext**.</span></span> <span data-ttu-id="19a35-170">Questa è la posizione in cui si definiscono i **DbSet** che implementano le raccolte supportate da database di oggetti CLR per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="19a35-170">This is where you define your **DbSets** that implement the database-backed collections of CLR objects for your application.</span></span> <span data-ttu-id="19a35-171">Nel contesto del routing dipendente dai dati è possibile identificare diverse proprietà utili che non sono necessariamente rilevanti per altri scenari di applicazioni Code First di Entity Framework:</span><span class="sxs-lookup"><span data-stu-id="19a35-171">In the context of data dependent routing, we can identify several helpful properties that do not necessarily hold for other EF code first application scenarios:</span></span> 

* <span data-ttu-id="19a35-172">Il database esiste già ed è stato registrato nella mappa partizioni del database elastico.</span><span class="sxs-lookup"><span data-stu-id="19a35-172">The database already exists and has been registered in the elastic database shard map.</span></span> 
* <span data-ttu-id="19a35-173">Lo schema dell'applicazione è già stato distribuito al database (come illustrato di seguito).</span><span class="sxs-lookup"><span data-stu-id="19a35-173">The schema of the application has already been deployed to the database (explained below).</span></span> 
* <span data-ttu-id="19a35-174">Le connessioni di routing dipendente dai dati al database vengono gestite dalla mappa partizioni.</span><span class="sxs-lookup"><span data-stu-id="19a35-174">Data-dependent routing connections to the database are brokered by the shard map.</span></span> 

<span data-ttu-id="19a35-175">Per integrare i **DbContext** con il routing dipendente dai dati per la scalabilità orizzontale:</span><span class="sxs-lookup"><span data-stu-id="19a35-175">To integrate **DbContexts** with data-dependent routing for scale-out:</span></span>

1. <span data-ttu-id="19a35-176">Creare connessioni di database fisiche mediante le interfacce client del database elastico del gestore delle mappe partizioni</span><span class="sxs-lookup"><span data-stu-id="19a35-176">Create physical database connections through the elastic database client interfaces of the shard map manager,</span></span> 
2. <span data-ttu-id="19a35-177">Eseguire il wrapping della connessione con la sottoclasse **DbContext**</span><span class="sxs-lookup"><span data-stu-id="19a35-177">Wrap the connection with the **DbContext** subclass</span></span>
3. <span data-ttu-id="19a35-178">Passare la connessione alle classi base **DbContext** per assicurare che venga eseguita anche tutta l'elaborazione sul lato Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="19a35-178">Pass the connection down into the **DbContext** base classes to ensure all the processing on the EF side happens as well.</span></span> 

<span data-ttu-id="19a35-179">Il seguente esempio di codice illustra questo approccio.</span><span class="sxs-lookup"><span data-stu-id="19a35-179">The following code example illustrates this approach.</span></span> <span data-ttu-id="19a35-180">Il codice è disponibile anche nel progetto di Visual Studio associato.</span><span class="sxs-lookup"><span data-stu-id="19a35-180">(This code is also in the accompanying Visual Studio project)</span></span>

    public class ElasticScaleContext<T> : DbContext
    {
    public DbSet<Blog> Blogs { get; set; }
    …

        // C'tor for data dependent routing. This call will open a validated connection 
        // routed to the proper shard by the shard map manager. 
        // Note that the base class c'tor call will fail for an open connection
        // if migrations need to be done and SQL credentials are used. This is the reason for the 
        // separation of c'tors into the data-dependent routing case (this c'tor) and the internal c'tor for new shards.
        public ElasticScaleContext(ShardMap shardMap, T shardingKey, string connectionStr)
            : base(CreateDDRConnection(shardMap, shardingKey, connectionStr), 
            true /* contextOwnsConnection */)
        {
        }

        // Only static methods are allowed in calls into base class c'tors.
        private static DbConnection CreateDDRConnection(
        ShardMap shardMap, 
        T shardingKey, 
        string connectionStr)
        {
            // No initialization
            Database.SetInitializer<ElasticScaleContext<T>>(null);

            // Ask shard map to broker a validated connection for the given key
            SqlConnection conn = shardMap.OpenConnectionForKey<T>
                                (shardingKey, connectionStr, ConnectionOptions.Validate);
            return conn;
        }    

## <a name="main-points"></a><span data-ttu-id="19a35-181">Punti principali</span><span class="sxs-lookup"><span data-stu-id="19a35-181">Main points</span></span>
* <span data-ttu-id="19a35-182">Un nuovo costruttore sostituisce il costruttore predefinito nella sottoclasse DbContext</span><span class="sxs-lookup"><span data-stu-id="19a35-182">A new constructor replaces the default constructor in the DbContext subclass</span></span> 
* <span data-ttu-id="19a35-183">Il nuovo costruttore accetta gli argomenti necessari per il routing dipendente dai dati mediante la libreria client dei database elastici:</span><span class="sxs-lookup"><span data-stu-id="19a35-183">The new constructor takes the arguments that are required for data dependent routing through elastic database client library:</span></span>
  
  * <span data-ttu-id="19a35-184">la mappa partizioni per l'accesso alle interfacce di routing dipendente dai dati</span><span class="sxs-lookup"><span data-stu-id="19a35-184">the shard map to access the data-dependent routing interfaces,</span></span>
  * <span data-ttu-id="19a35-185">la chiave di partizionamento orizzontale per l'identificazione dello shardlet</span><span class="sxs-lookup"><span data-stu-id="19a35-185">the sharding key to identify the shardlet,</span></span>
  * <span data-ttu-id="19a35-186">una stringa di connessione con le credenziali per la connessione di routing dipendente dai dati alla partizione.</span><span class="sxs-lookup"><span data-stu-id="19a35-186">a connection string with the credentials for the data-dependent routing connection to the shard.</span></span> 
* <span data-ttu-id="19a35-187">La chiamata al costruttore di classe base accetta una deviazione in un metodo statico che esegue tutti i passaggi necessari per il routing dipendente dai dati.</span><span class="sxs-lookup"><span data-stu-id="19a35-187">The call to the base class constructor takes a detour into a static method that performs all the steps necessary for data-dependent routing.</span></span> 
  
  * <span data-ttu-id="19a35-188">Usa la chiamata OpenConnectionForKey delle interfacce client dei database elastici sulla mappa partizioni per stabilire una connessione aperta.</span><span class="sxs-lookup"><span data-stu-id="19a35-188">It uses the OpenConnectionForKey call of the elastic database client interfaces on the shard map to establish an open connection.</span></span>
  * <span data-ttu-id="19a35-189">La mappa partizioni crea la connessione aperta alla partizione che contiene lo shardlet per la chiave di partizionamento orizzontale specificata.</span><span class="sxs-lookup"><span data-stu-id="19a35-189">The shard map creates the open connection to the shard that holds the shardlet for the given sharding key.</span></span>
  * <span data-ttu-id="19a35-190">Tale connessione aperta viene nuovamente passata al costruttore di classe base di DbContext per indicare che Entity Framework deve usare quella anziché crearne automaticamente una nuova.</span><span class="sxs-lookup"><span data-stu-id="19a35-190">This open connection is passed back to the base class constructor of DbContext to indicate that this connection is to be used by EF instead of letting EF create a new connection automatically.</span></span> <span data-ttu-id="19a35-191">In questo modo, la connessione è stata contrassegnata dall’API client dei database elastici al fine di garantire coerenza durante le operazioni di gestione della mappa partizioni.</span><span class="sxs-lookup"><span data-stu-id="19a35-191">This way the connection has been tagged by the elastic database client API so that it can guarantee consistency under shard map management operations.</span></span>

<span data-ttu-id="19a35-192">Nel proprio codice usare il nuovo costruttore per la sottoclasse DbContext anziché il costruttore predefinito.</span><span class="sxs-lookup"><span data-stu-id="19a35-192">Use the new constructor for your DbContext subclass instead of the default constructor in your code.</span></span> <span data-ttu-id="19a35-193">Di seguito è fornito un esempio:</span><span class="sxs-lookup"><span data-stu-id="19a35-193">Here is an example:</span></span> 

    // Create and save a new blog.

    Console.Write("Enter a name for a new blog: "); 
    var name = Console.ReadLine(); 

    using (var db = new ElasticScaleContext<int>( 
                            sharding.ShardMap,  
                            tenantId1,  
                            connStrBldr.ConnectionString)) 
    { 
        var blog = new Blog { Name = name }; 
        db.Blogs.Add(blog); 
        db.SaveChanges(); 

        // Display all Blogs for tenant 1 
        var query = from b in db.Blogs 
                    orderby b.Name 
                    select b; 
     … 
    }

<span data-ttu-id="19a35-194">Il nuovo costruttore apre la connessione alla partizione che contiene i dati per lo shardlet identificato dal valore di **tenantid1**.</span><span class="sxs-lookup"><span data-stu-id="19a35-194">The new constructor opens the connection to the shard that holds the data for the shardlet identified by the value of **tenantid1**.</span></span> <span data-ttu-id="19a35-195">Il codice nel blocco **using** resta invariato per accedere al **DbSet** per i blog usando Entity Framework sulla partizione per **tenantid1**.</span><span class="sxs-lookup"><span data-stu-id="19a35-195">The code in the **using** block stays unchanged to access the **DbSet** for blogs using EF on the shard for **tenantid1**.</span></span> <span data-ttu-id="19a35-196">Questo modifica la semantica per il codice nel blocco using in modo tale che tutte le operazioni di database abbiano come ambito la partizione in cui è conservato **tenantid1** .</span><span class="sxs-lookup"><span data-stu-id="19a35-196">This changes semantics for the code in the using block such that all database operations are now scoped to the one shard where **tenantid1** is kept.</span></span> <span data-ttu-id="19a35-197">Ad esempio, una query LINQ sul **DbSet** dei blog restituirebbe solo i blog archiviati nella partizione corrente, ma non quelli archiviati in altre partizioni.</span><span class="sxs-lookup"><span data-stu-id="19a35-197">For instance, a LINQ query over the blogs **DbSet** would only return blogs stored on the current shard, but not the ones stored on other shards.</span></span>  

#### <a name="transient-faults-handling"></a><span data-ttu-id="19a35-198">Gestione degli errori temporanei</span><span class="sxs-lookup"><span data-stu-id="19a35-198">Transient faults handling</span></span>
<span data-ttu-id="19a35-199">Il team Microsoft Patterns & Practices ha pubblicato un articolo sul [blocco applicazione per la gestione degli errori temporanei](https://msdn.microsoft.com/library/dn440719.aspx).</span><span class="sxs-lookup"><span data-stu-id="19a35-199">The Microsoft Patterns & Practices team published the [The Transient Fault Handling Application Block](https://msdn.microsoft.com/library/dn440719.aspx).</span></span> <span data-ttu-id="19a35-200">La libreria viene usata con la libreria client della scalabilità elastica in combinazione con Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="19a35-200">The library is used with elastic scale client library in combination with EF.</span></span> <span data-ttu-id="19a35-201">È però necessario assicurarsi che qualsiasi eccezione temporanea venga restituita in una posizione in cui ci si può accertare che dopo un errore temporaneo venga usato il nuovo costruttore, in modo che qualsiasi nuovo tentativo di connessione venga effettuato usando i costruttori modificati.</span><span class="sxs-lookup"><span data-stu-id="19a35-201">However, ensure that any transient exception returns to a place where we can ensure that the new constructor is being used after a transient fault so that any new connection attempt is made using the constructors we have tweaked.</span></span> <span data-ttu-id="19a35-202">In caso contrario, la connessione alla partizione corretta non è garantita, né esistono garanzie che la connessione venga mantenuta in caso di modifica della mappa partizioni.</span><span class="sxs-lookup"><span data-stu-id="19a35-202">Otherwise, a connection to the correct shard is not guaranteed, and there are no assurances the connection is maintained as changes to the shard map occur.</span></span> 

<span data-ttu-id="19a35-203">L'esempio di codice seguente illustra il possibile uso di un criterio di ripetizione SQL sui nuovi costruttori della sottoclasse **DbContext** :</span><span class="sxs-lookup"><span data-stu-id="19a35-203">The following code sample illustrates how a SQL retry policy can be used around the new **DbContext** subclass constructors:</span></span> 

    SqlDatabaseUtils.SqlRetryPolicy.ExecuteAction(() => 
    { 
        using (var db = new ElasticScaleContext<int>( 
                                sharding.ShardMap,  
                                tenantId1,  
                                connStrBldr.ConnectionString)) 
            { 
                    var blog = new Blog { Name = name }; 
                    db.Blogs.Add(blog); 
                    db.SaveChanges(); 
            … 
            } 
        }); 

<span data-ttu-id="19a35-204">**SqlDatabaseUtils.SqlRetryPolicy** nel codice precedente viene definito come **SqlDatabaseTransientErrorDetectionStrategy** con un numero di tentativi pari a 10 e un tempo di attesa tra i tentativi pari a 5 secondi.</span><span class="sxs-lookup"><span data-stu-id="19a35-204">**SqlDatabaseUtils.SqlRetryPolicy** in the code above is defined as a **SqlDatabaseTransientErrorDetectionStrategy** with a retry count of 10, and 5 seconds wait time between retries.</span></span> <span data-ttu-id="19a35-205">Questo approccio corrisponde alle informazioni aggiuntive per le transazioni di Entity Framework e avviate dall'utente; vedere l'argomento relativo alle limitazioni per le strategie di esecuzione con ripetizione dei tentativi (vedere [Entity Framework 6 e versioni successive)](http://msdn.microsoft.com/data/dn307226).</span><span class="sxs-lookup"><span data-stu-id="19a35-205">This approach is similar to the guidance for EF and user-initiated transactions (see [Limitations with Retrying Execution Strategies (EF6 onwards)](http://msdn.microsoft.com/data/dn307226).</span></span> <span data-ttu-id="19a35-206">Entrambe le situazioni richiedono che il programma applicativo controlli l'ambito in cui viene restituita l'eccezione temporanea: per riaprire la transazione o (come mostrato) ricreare il contesto dal costruttore corretto che usa la libreria client dei database elastici.</span><span class="sxs-lookup"><span data-stu-id="19a35-206">Both situations require that the application program controls the scope to which the transient exception returns: to either reopen the transaction, or (as shown) recreate the context from the proper constructor that uses the elastic database client library.</span></span>

<span data-ttu-id="19a35-207">La necessità di controllare la posizione a cui si viene riportati dalle eccezioni temporanee all'interno dell'ambito preclude anche l'uso dell'oggetto **SqlAzureExecutionStrategy** in dotazione con Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="19a35-207">The need to control where transient exceptions take us back in scope also precludes the use of the built-in **SqlAzureExecutionStrategy** that comes with EF.</span></span> <span data-ttu-id="19a35-208">**SqlAzureExecutionStrategy** riaprirebbe una connessione, ma non userebbe **OpenConnectionForKey**, di conseguenza verrebbe ignorata qualsiasi forma di convalida eseguita come parte della chiamata **OpenConnectionForKey**.</span><span class="sxs-lookup"><span data-stu-id="19a35-208">**SqlAzureExecutionStrategy** would reopen a connection but not use **OpenConnectionForKey** and therefore bypass all the validation that is performed as part of the **OpenConnectionForKey** call.</span></span> <span data-ttu-id="19a35-209">L'esempio di codice usa invece l'oggetto **DefaultExecutionStrategy** , anch'esso incluso in Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="19a35-209">Instead, the code sample uses the built-in **DefaultExecutionStrategy** that also comes with EF.</span></span> <span data-ttu-id="19a35-210">A differenza di **SqlAzureExecutionStrategy**, funziona correttamente con i criteri di ripetizione derivanti dalla gestione degli errori temporanei.</span><span class="sxs-lookup"><span data-stu-id="19a35-210">As opposed to **SqlAzureExecutionStrategy**, it works correctly in combination with the retry policy from Transient Fault Handling.</span></span> <span data-ttu-id="19a35-211">I criteri di esecuzione vengono impostati nella classe **ElasticScaleDbConfiguration** .</span><span class="sxs-lookup"><span data-stu-id="19a35-211">The execution policy is set in the **ElasticScaleDbConfiguration** class.</span></span> <span data-ttu-id="19a35-212">Si noti che si è deciso di non usare **DefaultSqlExecutionStrategy** perché suggerisce l'uso di **SqlAzureExecutionStrategy** in caso di eccezioni temporanee, situazione che causerebbe un comportamento errato, come spiegato in precedenza.</span><span class="sxs-lookup"><span data-stu-id="19a35-212">Note that we decided not to use **DefaultSqlExecutionStrategy** since it suggests to use **SqlAzureExecutionStrategy** if transient exceptions occur - which would lead to wrong behavior as discussed.</span></span> <span data-ttu-id="19a35-213">Per altre informazioni sui diversi criteri di ripetizione ed Entity Framework, vedere l'articolo relativo alla [resilienza delle connessioni in Entity Framework](http://msdn.microsoft.com/data/dn456835.aspx).</span><span class="sxs-lookup"><span data-stu-id="19a35-213">For more information on the different retry policies and EF, see [Connection Resiliency in EF](http://msdn.microsoft.com/data/dn456835.aspx).</span></span>     

#### <a name="constructor-rewrites"></a><span data-ttu-id="19a35-214">Riscritture dei costruttori</span><span class="sxs-lookup"><span data-stu-id="19a35-214">Constructor rewrites</span></span>
<span data-ttu-id="19a35-215">Gli esempi di codice precedenti illustrano le riscritture del costruttore predefinito necessarie perché l'applicazione possa usare il routing dipendente dai dati con Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="19a35-215">The code examples above illustrate the default constructor re-writes required for your application in order to use  data dependent routing with the Entity Framework.</span></span> <span data-ttu-id="19a35-216">La seguente tabella generalizza questo approccio per altri costruttori.</span><span class="sxs-lookup"><span data-stu-id="19a35-216">The following table generalizes this approach to other constructors.</span></span> 

| <span data-ttu-id="19a35-217">Costruttore corrente</span><span class="sxs-lookup"><span data-stu-id="19a35-217">Current Constructor</span></span> | <span data-ttu-id="19a35-218">Costruttore riscritto per i dati</span><span class="sxs-lookup"><span data-stu-id="19a35-218">Rewritten Constructor for data</span></span> | <span data-ttu-id="19a35-219">Costruttore base</span><span class="sxs-lookup"><span data-stu-id="19a35-219">Base Constructor</span></span> | <span data-ttu-id="19a35-220">Note</span><span class="sxs-lookup"><span data-stu-id="19a35-220">Notes</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="19a35-221">MyContext()</span><span class="sxs-lookup"><span data-stu-id="19a35-221">MyContext()</span></span> |<span data-ttu-id="19a35-222">ElasticScaleContext(ShardMap, TKey)</span><span class="sxs-lookup"><span data-stu-id="19a35-222">ElasticScaleContext(ShardMap, TKey)</span></span> |<span data-ttu-id="19a35-223">DbContext(DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="19a35-223">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="19a35-224">La connessione deve essere una funzione della mappa partizioni e della chiave di routing dipendente dai dati.</span><span class="sxs-lookup"><span data-stu-id="19a35-224">The connection needs to be a function of the shard map and the data-dependent routing key.</span></span> <span data-ttu-id="19a35-225">È necessario ignorare la creazione automatica della connessione da parte di Entity Framework e gestire la connessione mediante la mappa partizioni.</span><span class="sxs-lookup"><span data-stu-id="19a35-225">You need to by-pass automatic connection creation by EF and instead use the shard map to broker the connection.</span></span> |
| <span data-ttu-id="19a35-226">MyContext(string)</span><span class="sxs-lookup"><span data-stu-id="19a35-226">MyContext(string)</span></span> |<span data-ttu-id="19a35-227">ElasticScaleContext(ShardMap, TKey)</span><span class="sxs-lookup"><span data-stu-id="19a35-227">ElasticScaleContext(ShardMap, TKey)</span></span> |<span data-ttu-id="19a35-228">DbContext(DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="19a35-228">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="19a35-229">La connessione è una funzione della mappa partizioni e della chiave di routing dipendente dai dati.</span><span class="sxs-lookup"><span data-stu-id="19a35-229">The connection is a function of the shard map and the data-dependent routing key.</span></span> <span data-ttu-id="19a35-230">Non è possibile usare una stringa di connessione o un nome di database fisso, in quanto ignoreranno la convalida da parte della mappa partizioni.</span><span class="sxs-lookup"><span data-stu-id="19a35-230">A fixed database name or connection string will not work as they by-pass validation by the shard map.</span></span> |
| <span data-ttu-id="19a35-231">MyContext(DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="19a35-231">MyContext(DbCompiledModel)</span></span> |<span data-ttu-id="19a35-232">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="19a35-232">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span></span> |<span data-ttu-id="19a35-233">DbContext(DbConnection, DbCompiledModel, bool)</span><span class="sxs-lookup"><span data-stu-id="19a35-233">DbContext(DbConnection, DbCompiledModel, bool)</span></span> |<span data-ttu-id="19a35-234">Verrà creata la connessione per la mappa partizioni e per la chiave di partizionamento specificate con il modello fornito.</span><span class="sxs-lookup"><span data-stu-id="19a35-234">The connection will get created for the given shard map and sharding key with the model provided.</span></span> <span data-ttu-id="19a35-235">Il modello compilato verrà passato al costruttore base.</span><span class="sxs-lookup"><span data-stu-id="19a35-235">The compiled model will be passed on to the base c’tor.</span></span> |
| <span data-ttu-id="19a35-236">MyContext(DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="19a35-236">MyContext(DbConnection, bool)</span></span> |<span data-ttu-id="19a35-237">ElasticScaleContext(ShardMap, TKey, bool)</span><span class="sxs-lookup"><span data-stu-id="19a35-237">ElasticScaleContext(ShardMap, TKey, bool)</span></span> |<span data-ttu-id="19a35-238">DbContext(DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="19a35-238">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="19a35-239">La connessione deve essere dedotta dalla mappa partizioni e dalla chiave.</span><span class="sxs-lookup"><span data-stu-id="19a35-239">The connection needs to be inferred from the shard map and the key.</span></span> <span data-ttu-id="19a35-240">Non può essere fornita come input (a meno che l'input non usi già la mappa partizioni e la chiave).</span><span class="sxs-lookup"><span data-stu-id="19a35-240">It cannot be provided as an input (unless that input was already using the shard map and the key).</span></span> <span data-ttu-id="19a35-241">Il valore booleano verrà passato.</span><span class="sxs-lookup"><span data-stu-id="19a35-241">The Boolean will be passed on.</span></span> |
| <span data-ttu-id="19a35-242">MyContext(string, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="19a35-242">MyContext(string, DbCompiledModel)</span></span> |<span data-ttu-id="19a35-243">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="19a35-243">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span></span> |<span data-ttu-id="19a35-244">DbContext(DbConnection, DbCompiledModel, bool)</span><span class="sxs-lookup"><span data-stu-id="19a35-244">DbContext(DbConnection, DbCompiledModel, bool)</span></span> |<span data-ttu-id="19a35-245">La connessione deve essere dedotta dalla mappa partizioni e dalla chiave.</span><span class="sxs-lookup"><span data-stu-id="19a35-245">The connection needs to be inferred from the shard map and the key.</span></span> <span data-ttu-id="19a35-246">Non può essere fornita come input (a meno che l'input non usi la mappa partizioni e la chiave).</span><span class="sxs-lookup"><span data-stu-id="19a35-246">It cannot be provided as an input (unless that input was using the shard map and the key).</span></span> <span data-ttu-id="19a35-247">Il modello compilato verrà passato.</span><span class="sxs-lookup"><span data-stu-id="19a35-247">The compiled model will be passed on.</span></span> |
| <span data-ttu-id="19a35-248">MyContext(ObjectContext, bool)</span><span class="sxs-lookup"><span data-stu-id="19a35-248">MyContext(ObjectContext, bool)</span></span> |<span data-ttu-id="19a35-249">ElasticScaleContext(ShardMap, TKey, ObjectContext, bool)</span><span class="sxs-lookup"><span data-stu-id="19a35-249">ElasticScaleContext(ShardMap, TKey, ObjectContext, bool)</span></span> |<span data-ttu-id="19a35-250">DbContext(ObjectContext, bool)</span><span class="sxs-lookup"><span data-stu-id="19a35-250">DbContext(ObjectContext, bool)</span></span> |<span data-ttu-id="19a35-251">Il nuovo costruttore deve garantire che qualsiasi connessione in ObjectContext passato come input venga reinstradata a una connessione gestita da Scalabilità elastica.</span><span class="sxs-lookup"><span data-stu-id="19a35-251">The new constructor needs to ensure that any connection in the ObjectContext passed as an input is re-routed to a connection managed by Elastic Scale.</span></span> <span data-ttu-id="19a35-252">La descrizione dettagliata di ObjectContext esula dall'ambito di questo documento.</span><span class="sxs-lookup"><span data-stu-id="19a35-252">A detailed discussion of ObjectContexts is beyond the scope of this document.</span></span> |
| <span data-ttu-id="19a35-253">MyContext(DbConnection, DbCompiledModel,bool)</span><span class="sxs-lookup"><span data-stu-id="19a35-253">MyContext(DbConnection, DbCompiledModel,bool)</span></span> |<span data-ttu-id="19a35-254">ElasticScaleContext(ShardMap, TKey, DbCompiledModel, bool)</span><span class="sxs-lookup"><span data-stu-id="19a35-254">ElasticScaleContext(ShardMap, TKey, DbCompiledModel, bool)</span></span> |<span data-ttu-id="19a35-255">DbContext(DbConnection, DbCompiledModel, bool);</span><span class="sxs-lookup"><span data-stu-id="19a35-255">DbContext(DbConnection, DbCompiledModel, bool);</span></span> |<span data-ttu-id="19a35-256">La connessione deve essere dedotta dalla mappa partizioni e dalla chiave.</span><span class="sxs-lookup"><span data-stu-id="19a35-256">The connection needs to be inferred from the shard map and the key.</span></span> <span data-ttu-id="19a35-257">Non può essere fornita come input (a meno che l'input non usi già la mappa partizioni e la chiave).</span><span class="sxs-lookup"><span data-stu-id="19a35-257">The connection cannot be provided as an input (unless that input was already using the shard map and the key).</span></span> <span data-ttu-id="19a35-258">Il modello e il valore booleano verranno passati al costruttore di classe base.</span><span class="sxs-lookup"><span data-stu-id="19a35-258">Model and Boolean are passed on to the base class constructor.</span></span> |

## <a name="shard-schema-deployment-through-ef-migrations"></a><span data-ttu-id="19a35-259">Distribuzione dello schema partizione tramite migrazioni di Entity Framework</span><span class="sxs-lookup"><span data-stu-id="19a35-259">Shard schema deployment through EF migrations</span></span>
<span data-ttu-id="19a35-260">La gestione automatica dello schema è una funzionalità disponibile in Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="19a35-260">Automatic schema management is a convenience provided by the Entity Framework.</span></span> <span data-ttu-id="19a35-261">Nel contesto di applicazioni che utilizzano gli strumenti dei database elastici è desiderabile mantenere questa funzionalità per il provisioning automatico dello schema alle nuove partizioni quando si aggiungono database all'applicazione partizionata.</span><span class="sxs-lookup"><span data-stu-id="19a35-261">In the context of applications using elastic database tools, we want to retain this capability to automatically provision the schema to newly created shards when databases are added to the sharded application.</span></span> <span data-ttu-id="19a35-262">Il caso di utilizzo principale è l'aumento della capacità al livello dati per le applicazioni partizionate mediante Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="19a35-262">The primary use case is to increase capacity at the data tier for sharded applications using EF.</span></span> <span data-ttu-id="19a35-263">L'uso delle le funzionalità di Entity Framework per la gestione dello schema riduce le attività di amministrazione di database necessarie per un'applicazione partizionata basata su Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="19a35-263">Relying on EF’s capabilities for schema management reduces the database administration effort with a sharded application built on EF.</span></span> 

<span data-ttu-id="19a35-264">La distribuzione dello schema tramite migrazioni di Entity Framework funziona al meglio con le **connessioni non aperte**.</span><span class="sxs-lookup"><span data-stu-id="19a35-264">Schema deployment through EF migrations works best on **unopened connections**.</span></span> <span data-ttu-id="19a35-265">Si tratta di uno scenario diverso rispetto al routing dipendente dai dati, che usa la connessione aperta fornita dall’API client dei database elastici.</span><span class="sxs-lookup"><span data-stu-id="19a35-265">This is in contrast to the scenario for data dependent routing that relies on the opened connection provided by the elastic database client API.</span></span> <span data-ttu-id="19a35-266">Un’altra differenza è il requisito di coerenza: sebbene sia opportuno garantire la coerenza per tutte le connessioni di routing dipendente dai dati per la protezione dalle modifiche simultanee alla mappa partizioni, questo non rappresenta un problema nel caso della distribuzione iniziale dello schema in un nuovo database non ancora registrato nella mappa partizioni e non ancora allocato per contenere shardlet.</span><span class="sxs-lookup"><span data-stu-id="19a35-266">Another difference is the consistency requirement: While desirable to ensure consistency for all data-dependent routing connections to protect against concurrent shard map manipulation, it is not a concern with initial schema deployment to a new database that has not yet been registered in the shard map, and not yet been allocated to hold shardlets.</span></span> <span data-ttu-id="19a35-267">Per questi scenari è pertanto possibile usare le normali connessioni di database anziché il routing dipendente dai dati.</span><span class="sxs-lookup"><span data-stu-id="19a35-267">We can therefore rely on regular database connections for this scenarios, as opposed to data-dependent routing.</span></span>  

<span data-ttu-id="19a35-268">Questo conduce a un approccio in cui la distribuzione dello schema tramite migrazioni di Entity Framework è strettamente legata alla registrazione del nuovo database come partizione nella mappa partizioni dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="19a35-268">This leads to an approach where schema deployment through EF migrations is tightly coupled with the registration of the new database as a shard in the application’s shard map.</span></span> <span data-ttu-id="19a35-269">L'approccio è basato sui seguenti prerequisiti:</span><span class="sxs-lookup"><span data-stu-id="19a35-269">This relies on the following prerequisites:</span></span> 

* <span data-ttu-id="19a35-270">Il database è già stato creato.</span><span class="sxs-lookup"><span data-stu-id="19a35-270">The database has already been created.</span></span> 
* <span data-ttu-id="19a35-271">Il database è vuoto, non contiene schemi utente o dati utente.</span><span class="sxs-lookup"><span data-stu-id="19a35-271">The database is empty - it holds no user schema and no user data.</span></span>
* <span data-ttu-id="19a35-272">Il database non è ancora accessibile alle API client dei database elastici per il routing dipendente dai dati.</span><span class="sxs-lookup"><span data-stu-id="19a35-272">The database cannot yet be accessed through the elastic database client APIs for data-dependent routing.</span></span> 

<span data-ttu-id="19a35-273">Se questi prerequisiti sono soddisfatti, è possibile creare una normale connessione **SqlConnection** non aperta per avviare le migrazioni di Entity Framework per la distribuzione dello schema.</span><span class="sxs-lookup"><span data-stu-id="19a35-273">With these prerequisites in place, we can create a regular un-opened **SqlConnection** to kick off EF migrations for schema deployment.</span></span> <span data-ttu-id="19a35-274">Il seguente esempio di codice illustra questo approccio.</span><span class="sxs-lookup"><span data-stu-id="19a35-274">The following code sample illustrates this approach.</span></span> 

        // Enter a new shard - i.e. an empty database - to the shard map, allocate a first tenant to it  
        // and kick off EF intialization of the database to deploy schema 

        public void RegisterNewShard(string server, string database, string connStr, int key) 
        { 

            Shard shard = this.ShardMap.CreateShard(new ShardLocation(server, database)); 

            SqlConnectionStringBuilder connStrBldr = new SqlConnectionStringBuilder(connStr); 
            connStrBldr.DataSource = server; 
            connStrBldr.InitialCatalog = database; 

            // Go into a DbContext to trigger migrations and schema deployment for the new shard. 
            // This requires an un-opened connection. 
            using (var db = new ElasticScaleContext<int>(connStrBldr.ConnectionString)) 
            { 
                // Run a query to engage EF migrations 
                (from b in db.Blogs 
                    select b).Count(); 
            } 

            // Register the mapping of the tenant to the shard in the shard map. 
            // After this step, data-dependent routing on the shard map can be used 

            this.ShardMap.CreatePointMapping(key, shard); 
        } 


<span data-ttu-id="19a35-275">Questo esempio illustra il metodo **RegisterNewShard** , che registra la partizione nella mappa partizioni, distribuisce lo schema tramite migrazioni di Entity Framework e archivia il mapping di una chiave di partizionamento orizzontale nella partizione.</span><span class="sxs-lookup"><span data-stu-id="19a35-275">This sample shows the method **RegisterNewShard** that registers the shard in the shard map, deploys the schema through EF migrations, and stores a mapping of a sharding key to the shard.</span></span> <span data-ttu-id="19a35-276">Si basa su un costruttore della sottoclasse **DbContext** (**ElasticScaleContext** nell'esempio) che accetta come input una stringa di connessione SQL.</span><span class="sxs-lookup"><span data-stu-id="19a35-276">It relies on a constructor of the **DbContext** subclass (**ElasticScaleContext** in the sample) that takes a SQL connection string as input.</span></span> <span data-ttu-id="19a35-277">Il codice di questo costruttore è semplice, come illustrato nel seguente esempio:</span><span class="sxs-lookup"><span data-stu-id="19a35-277">The code of this constructor is straight-forward, as the following example shows:</span></span> 

        // C'tor to deploy schema and migrations to a new shard 
        protected internal ElasticScaleContext(string connectionString) 
            : base(SetInitializerForConnection(connectionString)) 
        { 
        } 

        // Only static methods are allowed in calls into base class c'tors 
        private static string SetInitializerForConnection(string connnectionString) 
        { 
            // We want existence checks so that the schema can get deployed 
            Database.SetInitializer<ElasticScaleContext<T>>( 
        new CreateDatabaseIfNotExists<ElasticScaleContext<T>>()); 

            return connnectionString; 
        } 

<span data-ttu-id="19a35-278">Si sarebbe potuta usare la versione del costruttore ereditata dalla classe base,</span><span class="sxs-lookup"><span data-stu-id="19a35-278">One might have used the version of the constructor inherited from the base class.</span></span> <span data-ttu-id="19a35-279">ma il codice deve garantire che per la connessione venga usato l'inizializzatore predefinito di Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="19a35-279">But the code needs to ensure that the default initializer for EF is used when connecting.</span></span> <span data-ttu-id="19a35-280">Da qui la breve deviazione nel metodo statico prima della chiamata al costruttore di classe base con la stringa di connessione.</span><span class="sxs-lookup"><span data-stu-id="19a35-280">Hence the short detour into the static method before calling into the base class constructor with the connection string.</span></span> <span data-ttu-id="19a35-281">Notare che la registrazione delle partizioni deve essere eseguita in un dominio applicativo o in un processo diverso, per garantire l'assenza di conflitti con le impostazioni dell'inizializzatore per Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="19a35-281">Note that the registration of shards should run in a different app domain or process to ensure that the initializer settings for EF do not conflict.</span></span> 

## <a name="limitations"></a><span data-ttu-id="19a35-282">Limitazioni</span><span class="sxs-lookup"><span data-stu-id="19a35-282">Limitations</span></span>
<span data-ttu-id="19a35-283">Gli approcci descritti in questo documento implicano due limitazioni:</span><span class="sxs-lookup"><span data-stu-id="19a35-283">The approaches outlined in this document entail a couple of limitations:</span></span> 

* <span data-ttu-id="19a35-284">Prima di usare la libreria client del database elastico, è necessario eseguire la migrazione delle applicazioni Entity Framework che usano **LocalDb** a un normale database di SQL Server.</span><span class="sxs-lookup"><span data-stu-id="19a35-284">EF applications that use **LocalDb** first need to migrate to a regular SQL Server database before using elastic database client library.</span></span> <span data-ttu-id="19a35-285">Con **LocalDb**non è possibile scalare orizzontalmente un'applicazione mediante il partizionamento orizzontale con la scalabilità elastica.</span><span class="sxs-lookup"><span data-stu-id="19a35-285">Scaling out an application through sharding with Elastic Scale is not possible with **LocalDb**.</span></span> <span data-ttu-id="19a35-286">Per lo sviluppo è comunque possibile usare **LocalDb**.</span><span class="sxs-lookup"><span data-stu-id="19a35-286">Note that development can still use **LocalDb**.</span></span> 
* <span data-ttu-id="19a35-287">Le modifiche all'applicazione che implicano modifiche dello schema del database devono passare attraverso le migrazioni di Entity Framework su tutte le partizioni.</span><span class="sxs-lookup"><span data-stu-id="19a35-287">Any changes to the application that imply database schema changes need to go through EF migrations on all shards.</span></span> <span data-ttu-id="19a35-288">Il codice di esempio per questo documento non illustra come eseguire questa operazione.</span><span class="sxs-lookup"><span data-stu-id="19a35-288">The sample code for this document does not demonstrate how to do this.</span></span> <span data-ttu-id="19a35-289">Provare a usare Update-Database con un parametro ConnectionString per eseguire l'iterazione su tutte le partizioni oppure estrarre lo script T-SQL per la migrazione in sospeso usando Update-Database con l'opzione –Script e applicare lo script T-SQL alle partizioni.</span><span class="sxs-lookup"><span data-stu-id="19a35-289">Consider using Update-Database with a ConnectionString parameter to iterate over all shards; or extract the T-SQL script for the pending migration using Update-Database with the -Script option and apply the T-SQL script to your shards.</span></span>  
* <span data-ttu-id="19a35-290">Data una richiesta, si presuppone che tutta la relativa elaborazione di database sia contenuta in una singola partizione identificata dalla chiave di partizionamento orizzontale fornita dalla richiesta.</span><span class="sxs-lookup"><span data-stu-id="19a35-290">Given a request, it is assumed that all of its database processing is contained within a single shard as identified by the sharding key provided by the request.</span></span> <span data-ttu-id="19a35-291">Questo presupposto, tuttavia, non è sempre valido,</span><span class="sxs-lookup"><span data-stu-id="19a35-291">However, this assumption does not always hold true.</span></span> <span data-ttu-id="19a35-292">ad esempio quando non è possibile rendere disponibile una chiave di partizionamento orizzontale.</span><span class="sxs-lookup"><span data-stu-id="19a35-292">For example, when it is not possible to make a sharding key available.</span></span> <span data-ttu-id="19a35-293">A questo scopo, la libreria client fornisce la classe **MultiShardQuery** che implementa un'astrazione delle connessioni per l'esecuzione di query su più partizioni.</span><span class="sxs-lookup"><span data-stu-id="19a35-293">To address this, the client library provides the **MultiShardQuery** class that implements a connection abstraction for querying over several shards.</span></span> <span data-ttu-id="19a35-294">L'uso di **MultiShardQuery** in combinazione con Entity Framework esula dall'ambito di questo documento</span><span class="sxs-lookup"><span data-stu-id="19a35-294">Learning to use the **MultiShardQuery** in combination with EF is beyond the scope of this document</span></span>

## <a name="conclusion"></a><span data-ttu-id="19a35-295">Conclusione</span><span class="sxs-lookup"><span data-stu-id="19a35-295">Conclusion</span></span>
<span data-ttu-id="19a35-296">Seguendo le procedure descritte in questo documento, le applicazioni Entity Framework possono usufruire della funzionalità di routing dipendente dai dati della libreria client dei database elastici mediante il refactoring dei costruttori delle sottoclassi **DbContext** usate nelle applicazioni stesse.</span><span class="sxs-lookup"><span data-stu-id="19a35-296">Through the steps outlined in this document, EF applications can use the elastic database client library's capability for data dependent routing by refactoring constructors of the **DbContext** subclasses used in the EF application.</span></span> <span data-ttu-id="19a35-297">Questo limita il numero di modifiche necessarie nelle posizioni in cui sono già presenti classi **DbContext**.</span><span class="sxs-lookup"><span data-stu-id="19a35-297">This limits the  changes required to those places where **DbContext** classes already exist.</span></span> <span data-ttu-id="19a35-298">Inoltre, le applicazioni Entity Framework possono continuare a usufruire della distribuzione automatica dello schema combinando le operazioni che richiamano le migrazioni Entity Framework con la registrazione di nuove partizioni e mapping nella mappa partizioni.</span><span class="sxs-lookup"><span data-stu-id="19a35-298">In addition, EF applications can continue to benefit from automatic schema deployment by combining the steps that invoke the necessary EF migrations with the registration of new shards and mappings in the shard map.</span></span> 

[!INCLUDE [elastic-scale-include](../../includes/elastic-scale-include.md)]

<!--Image references-->
[1]: ./media/sql-database-elastic-scale-use-entity-framework-applications-visual-studio/sample.png
