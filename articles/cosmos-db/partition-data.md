---
title: Partizionamento e aumento del numero di istanze in Azure Cosmos DB | Microsoft Docs
description: Informazioni sul funzionamento del partizionamento in Azure Cosmos DB, sulla configurazione del partizionamento e delle chiavi di partizione e su come scegliere la chiave di partizione corretta per l'applicazione.
services: cosmos-db
author: arramac
manager: jhubbard
editor: monicar
documentationcenter: 
ms.assetid: cac9a8cd-b5a3-4827-8505-d40bb61b2416
ms.service: cosmos-db
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 05/10/2017
ms.author: arramac
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: e2d2847276e553d7511241ff323c3e00aad8e5c9
ms.sourcegitcommit: 02e69c4a9d17645633357fe3d46677c2ff22c85a
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/03/2017
---
# <a name="how-to-partition-and-scale-in-azure-cosmos-db"></a><span data-ttu-id="8507a-103">Come eseguire il partizionamento e il ridimensionamento in Azure Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="8507a-103">How to partition and scale in Azure Cosmos DB</span></span>

<span data-ttu-id="8507a-104">[Microsoft Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/) è un servizio di database multimodello con distribuzione globale progettato per ottenere prestazioni rapide e prevedibili e per eseguire facilmente il ridimensionamento in base alla crescita dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="8507a-104">[Microsoft Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/) is a global distributed, multi-model database service designed to help you achieve fast, predictable performance and scale seamlessly along with your application as it grows.</span></span> <span data-ttu-id="8507a-105">Questo articolo offre una panoramica del funzionamento del partizionamento in Azure Cosmos DB e descrive come configurare contenitori di Azure Cosmos DB per ridimensionare le applicazioni in modo efficace.</span><span class="sxs-lookup"><span data-stu-id="8507a-105">This article provides an overview of how partitioning works for all the data models in Azure Cosmos DB, and describes how you can configure Azure Cosmos DB containers to effectively scale your applications.</span></span>

<span data-ttu-id="8507a-106">Il partizionamento e le chiavi di partizione sono illustrati anche in questo video di Azure Friday con Scott Hanselman e Shireesh Thota, responsabile principale della progettazione di Azure Cosmos DB.</span><span class="sxs-lookup"><span data-stu-id="8507a-106">Partitioning and partition keys are also covered in this Azure Friday video with Scott Hanselman and Azure Cosmos DB Principal Engineering Manager, Shireesh Thota.</span></span>

> [!VIDEO https://channel9.msdn.com/Shows/Azure-Friday/Azure-DocumentDB-Elastic-Scale-Partitioning/player]
> 

## <a name="partitioning-in-azure-cosmos-db"></a><span data-ttu-id="8507a-107">Partizionamento in Azure Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="8507a-107">Partitioning in Azure Cosmos DB</span></span>
<span data-ttu-id="8507a-108">In Azure Cosmos DB è possibile archiviare dati ed eseguire query senza schema con tempi di risposta nell'ordine di millisecondi su qualsiasi scala.</span><span class="sxs-lookup"><span data-stu-id="8507a-108">In Azure Cosmos DB, you can store and query schema-less data with order-of-millisecond response times at any scale.</span></span> <span data-ttu-id="8507a-109">Cosmos DB offre contenitori per l'archiviazione di dati denominati **raccolte (per i documenti), grafici o tabelle**.</span><span class="sxs-lookup"><span data-stu-id="8507a-109">Cosmos DB provides containers for storing data called **collections (for document), graphs, or tables**.</span></span> <span data-ttu-id="8507a-110">I contenitori sono risorse logiche e possono comprendere una o più partizioni fisiche o server.</span><span class="sxs-lookup"><span data-stu-id="8507a-110">Containers are logical resources and can span one or more physical partitions or servers.</span></span> <span data-ttu-id="8507a-111">Il numero di partizioni è determinato da Cosmos DB in base allo spazio di archiviazione e alla velocità effettiva con provisioning del contenitore.</span><span class="sxs-lookup"><span data-stu-id="8507a-111">The number of partitions is determined by Cosmos DB based on the storage size and the provisioned throughput of the container.</span></span> <span data-ttu-id="8507a-112">Ogni partizione in Cosmos DB ha una quantità fissa di archiviazione supportata da unità SSD associata e viene replicata per la disponibilità elevata.</span><span class="sxs-lookup"><span data-stu-id="8507a-112">Every partition in Cosmos DB has a fixed amount of SSD-backed storage associated with it, and is replicated for high availability.</span></span> <span data-ttu-id="8507a-113">Le partizioni vengono completamente gestite da Azure Cosmos DB e non è necessario scrivere codice complesso o gestire le partizioni.</span><span class="sxs-lookup"><span data-stu-id="8507a-113">Partition management is fully managed by Azure Cosmos DB, and you do not have to write complex code or manage your partitions.</span></span> <span data-ttu-id="8507a-114">I contenitori di Cosmos DB sono illimitati in termini di risorse di archiviazione e di velocità effettiva.</span><span class="sxs-lookup"><span data-stu-id="8507a-114">Cosmos DB containers are unlimited in terms of storage and throughput.</span></span> 

![orizzontale](./media/introduction/azure-cosmos-db-partitioning.png) 

<span data-ttu-id="8507a-116">Il partizionamento è trasparente per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="8507a-116">Partitioning is transparent to your application.</span></span> <span data-ttu-id="8507a-117">Cosmos DB supporta letture e scritture veloci, query, logica transazionale, livelli di coerenza e controllo di accesso con granularità fine tramite metodi/API per una singola risorsa di contenitore.</span><span class="sxs-lookup"><span data-stu-id="8507a-117">Cosmos DB supports fast reads and writes, queries, transactional logic, consistency levels, and fine-grained access control via methods/APIs to a single container resource.</span></span> <span data-ttu-id="8507a-118">Il servizio gestisce la distribuzione dei dati tra le partizioni e il routing delle richieste di query alla partizione corretta.</span><span class="sxs-lookup"><span data-stu-id="8507a-118">The service handles distributing data across partitions and routing query requests to the right partition.</span></span> 

<span data-ttu-id="8507a-119">Per il partizionamento,</span><span class="sxs-lookup"><span data-stu-id="8507a-119">How does partitioning work?</span></span> <span data-ttu-id="8507a-120">ogni elemento deve avere una chiave di partizione e una chiave di riga che lo identificano in modo univoco.</span><span class="sxs-lookup"><span data-stu-id="8507a-120">Each item must have a partition key and a row key, which uniquely identify it.</span></span> <span data-ttu-id="8507a-121">La chiave di partizione funge da partizione logica per i dati e fornisce a Cosmos DB un limite naturale per la distribuzione dei dati tra partizioni.</span><span class="sxs-lookup"><span data-stu-id="8507a-121">Your partition key acts as a logical partition for your data, and provides Cosmos DB with a natural boundary for distributing data across partitions.</span></span> <span data-ttu-id="8507a-122">In sintesi, il partizionamento in Azure Cosmos DB funziona nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="8507a-122">In brief, here is how partitioning works in Azure Cosmos DB:</span></span>

* <span data-ttu-id="8507a-123">Si esegue il provisioning di un contenitore Cosmos DB con velocità effettiva di `T` richieste/s</span><span class="sxs-lookup"><span data-stu-id="8507a-123">You provision a Cosmos DB container with `T` requests/s throughput</span></span>
* <span data-ttu-id="8507a-124">In background Cosmos DB effettua il provisioning delle partizioni necessarie per gestire `T` richieste/s.</span><span class="sxs-lookup"><span data-stu-id="8507a-124">Behind the scenes, Cosmos DB provisions partitions needed to serve `T` requests/s.</span></span> <span data-ttu-id="8507a-125">Se `T` è maggiore della velocità effettiva massima per partizione `t`, Cosmos DB esegue il provisioning di `N` = `T/t` partizioni</span><span class="sxs-lookup"><span data-stu-id="8507a-125">If `T` is higher than the maximum throughput per partition `t`, then Cosmos DB provisions `N` = `T/t` partitions</span></span>
* <span data-ttu-id="8507a-126">Cosmos DB alloca lo spazio degli hash delle chiavi di partizione in modo uniforme tra le `N` partizioni.</span><span class="sxs-lookup"><span data-stu-id="8507a-126">Cosmos DB allocates the key space of partition key hashes evenly across the `N` partitions.</span></span> <span data-ttu-id="8507a-127">Ogni partizione fisica ospita quindi 1-N valori di chiave di partizione (partizioni logiche)</span><span class="sxs-lookup"><span data-stu-id="8507a-127">So, each partition (physical partition) hosts 1-N partition key values (logical partitions)</span></span>
* <span data-ttu-id="8507a-128">Quando una partizione fisica `p` raggiunge il limite di archiviazione, Cosmos DB suddivide `p` in due nuove partizioni `p1` e `p2` e distribuisce i valori corrispondenti a circa la metà di chiavi per ciascuna delle partizioni.</span><span class="sxs-lookup"><span data-stu-id="8507a-128">When a physical partition `p` reaches its storage limit, Cosmos DB seamlessly splits `p` into two new partitions `p1` and `p2` and distributes values corresponding to roughly half the keys to each of the partitions.</span></span> <span data-ttu-id="8507a-129">Questa operazione di suddivisione è invisibile all'applicazione.</span><span class="sxs-lookup"><span data-stu-id="8507a-129">This split operation is invisible to your application.</span></span>
* <span data-ttu-id="8507a-130">Analogamente, quando si esegue il provisioning di una velocità effettiva superiore alla velocità effettiva `t*N`, Cosmos DB suddivide una o più delle partizioni per supportare la velocità effettiva maggiore</span><span class="sxs-lookup"><span data-stu-id="8507a-130">Similarly, when you provision throughput higher than `t*N` throughput, Cosmos DB splits one or more of your partitions to support the higher throughput</span></span>

<span data-ttu-id="8507a-131">La semantica delle chiavi di partizione è leggermente diversa in modo da corrispondere alla semantica di ogni API, come illustrato nella tabella seguente:</span><span class="sxs-lookup"><span data-stu-id="8507a-131">The semantics for partition keys are slightly different to match the semantics of each API, as shown in the following table:</span></span>

| <span data-ttu-id="8507a-132">API</span><span class="sxs-lookup"><span data-stu-id="8507a-132">API</span></span> | <span data-ttu-id="8507a-133">Chiave di partizione</span><span class="sxs-lookup"><span data-stu-id="8507a-133">Partition Key</span></span> | <span data-ttu-id="8507a-134">Chiave di riga</span><span class="sxs-lookup"><span data-stu-id="8507a-134">Row Key</span></span> |
| --- | --- | --- |
| <span data-ttu-id="8507a-135">DocumentDB</span><span class="sxs-lookup"><span data-stu-id="8507a-135">DocumentDB</span></span> | <span data-ttu-id="8507a-136">percorso personalizzato della chiave di partizione</span><span class="sxs-lookup"><span data-stu-id="8507a-136">custom partition key path</span></span> | <span data-ttu-id="8507a-137">`id` fisso</span><span class="sxs-lookup"><span data-stu-id="8507a-137">fixed `id`</span></span> | 
| <span data-ttu-id="8507a-138">MongoDB</span><span class="sxs-lookup"><span data-stu-id="8507a-138">MongoDB</span></span> | <span data-ttu-id="8507a-139">chiave di partizione personalizzata</span><span class="sxs-lookup"><span data-stu-id="8507a-139">custom shard key</span></span>  | <span data-ttu-id="8507a-140">`_id` fisso</span><span class="sxs-lookup"><span data-stu-id="8507a-140">fixed `_id`</span></span> | 
| <span data-ttu-id="8507a-141">Grafico</span><span class="sxs-lookup"><span data-stu-id="8507a-141">Graph</span></span> | <span data-ttu-id="8507a-142">proprietà chiave di partizione personalizzata</span><span class="sxs-lookup"><span data-stu-id="8507a-142">custom partition key property</span></span> | <span data-ttu-id="8507a-143">`id` fisso</span><span class="sxs-lookup"><span data-stu-id="8507a-143">fixed `id`</span></span> | 
| <span data-ttu-id="8507a-144">Tabella</span><span class="sxs-lookup"><span data-stu-id="8507a-144">Table</span></span> | <span data-ttu-id="8507a-145">`PartitionKey` fisso</span><span class="sxs-lookup"><span data-stu-id="8507a-145">fixed `PartitionKey`</span></span> | <span data-ttu-id="8507a-146">`RowKey` fisso</span><span class="sxs-lookup"><span data-stu-id="8507a-146">fixed `RowKey`</span></span> | 

<span data-ttu-id="8507a-147">Cosmos DB usa il partizionamento basato su hash.</span><span class="sxs-lookup"><span data-stu-id="8507a-147">Cosmos DB uses hash-based partitioning.</span></span> <span data-ttu-id="8507a-148">Quando si scrive un elemento, Cosmos DB esegue l'hashing del valore della chiave di partizione e usa il risultato con hash per determinare la partizione in cui archiviare l'elemento.</span><span class="sxs-lookup"><span data-stu-id="8507a-148">When you write an item, Cosmos DB hashes the partition key value and use the hashed result to determine which partition to store the item in.</span></span> <span data-ttu-id="8507a-149">Cosmos DB archivia tutti gli elementi con la stessa chiave di partizione nella stessa partizione fisica.</span><span class="sxs-lookup"><span data-stu-id="8507a-149">Cosmos DB stores all items with the same partition key in the same physical partition.</span></span> <span data-ttu-id="8507a-150">La scelta della chiave di partizione è una decisione importante da prendere in fase di progettazione.</span><span class="sxs-lookup"><span data-stu-id="8507a-150">The choice of the partition key is an important decision that you have to make at design time.</span></span> <span data-ttu-id="8507a-151">È necessario scegliere un nome proprietà che contenga un'ampia gamma di valori e abbia anche modelli di accesso.</span><span class="sxs-lookup"><span data-stu-id="8507a-151">You must pick a property name that has a wide range of values and has even access patterns.</span></span>

> [!NOTE]
> <span data-ttu-id="8507a-152">È consigliabile avere una chiave di partizione con molti valori distinti (100-1000 come minimo).</span><span class="sxs-lookup"><span data-stu-id="8507a-152">It is a best practice to have a partition key with many distinct values (100s-1000s at a minimum).</span></span>
>

<span data-ttu-id="8507a-153">I contenitori di Azure Cosmos DB possono essere creati come "fissi" o "illimitati".</span><span class="sxs-lookup"><span data-stu-id="8507a-153">Azure Cosmos DB containers can be created as "fixed" or "unlimited."</span></span> <span data-ttu-id="8507a-154">I contenitori a dimensione fissa hanno un limite massimo di 10 GB e velocità effettiva di 10.000 UR/s.</span><span class="sxs-lookup"><span data-stu-id="8507a-154">Fixed-size containers have a maximum limit of 10 GB and 10,000 RU/s throughput.</span></span> <span data-ttu-id="8507a-155">Alcune API consentono di omettere la chiave di partizione per i contenitori a dimensione fissa.</span><span class="sxs-lookup"><span data-stu-id="8507a-155">Some APIs allow the partition key to be omitted for fixed-size containers.</span></span> <span data-ttu-id="8507a-156">Per creare un contenitore illimitato è necessario specificare una velocità effettiva minima di 2500 UR/s.</span><span class="sxs-lookup"><span data-stu-id="8507a-156">To create a container as unlimited, you must specify a minimum throughput of 2500 RU/s.</span></span>

## <a name="partitioning-and-provisioned-throughput"></a><span data-ttu-id="8507a-157">Partizionamento e velocità effettiva con provisioning</span><span class="sxs-lookup"><span data-stu-id="8507a-157">Partitioning and provisioned throughput</span></span>
<span data-ttu-id="8507a-158">Cosmos DB è progettato per prestazioni prevedibili.</span><span class="sxs-lookup"><span data-stu-id="8507a-158">Cosmos DB is designed for predictable performance.</span></span> <span data-ttu-id="8507a-159">Quando si crea un contenitore, la velocità effettiva viene riservata in termini di **[unità richiesta](request-units.md) (UR) al secondo, con un potenziale add-on per UR al minuto**.</span><span class="sxs-lookup"><span data-stu-id="8507a-159">When you create a container, you reserve throughput in terms of **[request units](request-units.md) (RU) per second with a potential add-on for RU per minute**.</span></span> <span data-ttu-id="8507a-160">A ogni richiesta viene assegnato un addebito delle unità richiesta proporzionato alla quantità di risorse di sistema, come CPU, memoria e I/O usati dall'operazione.</span><span class="sxs-lookup"><span data-stu-id="8507a-160">Each request is assigned a request unit charge that is proportionate to the amount of system resources like CPU, Memory, and IO consumed by the operation.</span></span> <span data-ttu-id="8507a-161">La lettura di un documento di 1 KB con coerenza di sessione usa un'unità richiesta.</span><span class="sxs-lookup"><span data-stu-id="8507a-161">A read of a 1-KB document with Session consistency consumes one request unit.</span></span> <span data-ttu-id="8507a-162">Un'operazione di lettura corrisponde a 1 RU indipendentemente dal numero di elementi archiviati o dal numero di richieste simultanee in esecuzione contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="8507a-162">A read is 1 RU regardless of the number of items stored or the number of concurrent requests running at the same time.</span></span> <span data-ttu-id="8507a-163">Elementi di dimensioni maggiori richiedono più unità richiesta a seconda delle dimensioni.</span><span class="sxs-lookup"><span data-stu-id="8507a-163">Larger items require higher request units depending on the size.</span></span> <span data-ttu-id="8507a-164">Se si conoscono le dimensioni delle entità e il numero di letture che è necessario supportare per l'applicazione, è possibile eseguire il provisioning della quantità esatta di velocità effettiva necessaria per le esigenze di lettura dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="8507a-164">If you know the size of your entities and the number of reads you need to support for your application, you can provision the exact amount of throughput required for your application's read needs.</span></span> 

> [!NOTE]
> <span data-ttu-id="8507a-165">Per ottenere la velocità effettiva totale del contenitore è necessario scegliere una chiave di partizione che consenta di distribuire in modo uniforme le richieste tra alcuni valori distinti della chiave di partizione.</span><span class="sxs-lookup"><span data-stu-id="8507a-165">To achieve the full throughput of the container, you must choose a partition key that allows you to evenly distribute requests among some distinct partition key values.</span></span>
> 
> 

<a name="designing-for-partitioning"></a>
## <a name="working-with-the-azure-cosmos-db-apis"></a><span data-ttu-id="8507a-166">Uso delle API di Azure Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="8507a-166">Working with the Azure Cosmos DB APIs</span></span>
<span data-ttu-id="8507a-167">È possibile usare il portale di Azure o l'interfaccia della riga di comando di Azure per creare contenitori e ridimensionarli in qualsiasi momento.</span><span class="sxs-lookup"><span data-stu-id="8507a-167">You can use the Azure portal or Azure CLI to create containers and scale them at any time.</span></span> <span data-ttu-id="8507a-168">Questa sezione illustra come creare contenitori e specificare la definizione di velocità effettiva e chiave di partizione in ognuna delle API supportate.</span><span class="sxs-lookup"><span data-stu-id="8507a-168">This section shows how to create containers and specify the throughput and partition key definition in each of the supported APIs.</span></span>

### <a name="documentdb-api"></a><span data-ttu-id="8507a-169">API di DocumentDB</span><span class="sxs-lookup"><span data-stu-id="8507a-169">DocumentDB API</span></span>
<span data-ttu-id="8507a-170">L'esempio seguente illustra come creare un contenitore (raccolta) usando l'API di DocumentDB.</span><span class="sxs-lookup"><span data-stu-id="8507a-170">The following sample shows how to create a container (collection) using the DocumentDB API.</span></span> <span data-ttu-id="8507a-171">Per informazioni più dettagliate, vedere [Partizionamento con l'API di DocumentDB](partition-data.md).</span><span class="sxs-lookup"><span data-stu-id="8507a-171">You can find more details in [Partitioning with DocumentDB API](partition-data.md).</span></span>

```csharp
DocumentClient client = new DocumentClient(new Uri(endpoint), authKey);
await client.CreateDatabaseAsync(new Database { Id = "db" });

DocumentCollection myCollection = new DocumentCollection();
myCollection.Id = "coll";
myCollection.PartitionKey.Paths.Add("/deviceId");

await client.CreateDocumentCollectionAsync(
    UriFactory.CreateDatabaseUri("db"),
    myCollection,
    new RequestOptions { OfferThroughput = 20000 });
```

<span data-ttu-id="8507a-172">È possibile leggere un elemento (documento) tramite il metodo `GET` nell'API REST oppure usando `ReadDocumentAsync` in uno degli SDK.</span><span class="sxs-lookup"><span data-stu-id="8507a-172">You can read an item (document) using the `GET` method in the REST API or using `ReadDocumentAsync` in one of the SDKs.</span></span>

```csharp
// Read document. Needs the partition key and the ID to be specified
DeviceReading document = await client.ReadDocumentAsync<DeviceReading>(
  UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
  new RequestOptions { PartitionKey = new PartitionKey("XMS-0001") });
```

### <a name="mongodb-api"></a><span data-ttu-id="8507a-173">API di MongoDB</span><span class="sxs-lookup"><span data-stu-id="8507a-173">MongoDB API</span></span>
<span data-ttu-id="8507a-174">Con l'API MongoDB è possibile creare una raccolta partizionata usando il proprio strumento, driver o SDK preferito.</span><span class="sxs-lookup"><span data-stu-id="8507a-174">With the MongoDB API, you can create a sharded collection through your favorite tool, driver, or SDK.</span></span> <span data-ttu-id="8507a-175">In questo esempio verrà usato Mongo Shell per la creazione della raccolta.</span><span class="sxs-lookup"><span data-stu-id="8507a-175">In this example, we use the Mongo Shell for the collection creation.</span></span>

<span data-ttu-id="8507a-176">In Mongo Shell:</span><span class="sxs-lookup"><span data-stu-id="8507a-176">In the Mongo Shell:</span></span>

```
db.runCommand( { shardCollection: "admin.people", key: { region: "hashed" } } )
```
    
<span data-ttu-id="8507a-177">Risultati:</span><span class="sxs-lookup"><span data-stu-id="8507a-177">Results:</span></span>

```JSON
{
    "_t" : "ShardCollectionResponse",
    "ok" : 1,
    "collectionsharded" : "admin.people"
}
```

### <a name="table-api"></a><span data-ttu-id="8507a-178">API di tabella</span><span class="sxs-lookup"><span data-stu-id="8507a-178">Table API</span></span>

<span data-ttu-id="8507a-179">Con l'API di tabella si specifica la velocità effettiva per le tabelle nella configurazione appSettings dell'applicazione:</span><span class="sxs-lookup"><span data-stu-id="8507a-179">With the Table API, you specify the throughput for tables in the appSettings configuration for your application:</span></span>

```xml
<configuration>
    <appSettings>
      <!--Table creation options -->
      <add key="TableThroughput" value="700"/>
    </appSettings>
</configuration>
```

<span data-ttu-id="8507a-180">Si crea quindi una tabella usando l'SDK di archiviazione tabelle di Azure.</span><span class="sxs-lookup"><span data-stu-id="8507a-180">Then you create a table using the Azure Table storage SDK.</span></span> <span data-ttu-id="8507a-181">La chiave di partizione viene creata implicitamente come valore `PartitionKey`.</span><span class="sxs-lookup"><span data-stu-id="8507a-181">The partition key is implicitly created as the `PartitionKey` value.</span></span> 

```csharp
CloudTableClient tableClient = storageAccount.CreateCloudTableClient();

CloudTable table = tableClient.GetTableReference("people");
table.CreateIfNotExists();
```

<span data-ttu-id="8507a-182">È possibile recuperare una singola entità tramite il frammento seguente:</span><span class="sxs-lookup"><span data-stu-id="8507a-182">You can retrieve a single entity using the following snippet:</span></span>

```csharp
// Create a retrieve operation that takes a customer entity.
TableOperation retrieveOperation = TableOperation.Retrieve<CustomerEntity>("Smith", "Ben");

// Execute the retrieve operation.
TableResult retrievedResult = table.Execute(retrieveOperation);
```
<span data-ttu-id="8507a-183">Vedere lo [sviluppo con l'API di tabella](tutorial-develop-table-dotnet.md) per altri dettagli.</span><span class="sxs-lookup"><span data-stu-id="8507a-183">See [Developing with the Table API](tutorial-develop-table-dotnet.md) for more details.</span></span>

### <a name="graph-api"></a><span data-ttu-id="8507a-184">API Graph</span><span class="sxs-lookup"><span data-stu-id="8507a-184">Graph API</span></span>

<span data-ttu-id="8507a-185">Con l'API Graph è necessario usare il portale di Azure o l'interfaccia della riga di comando per creare contenitori.</span><span class="sxs-lookup"><span data-stu-id="8507a-185">With the Graph API, you must use the Azure portal or CLI to create containers.</span></span> <span data-ttu-id="8507a-186">Essendo Azure Cosmos DB multimodello, in alternativa è possibile usare uno degli altri modelli per creare e ridimensionare il contenitore di grafici.</span><span class="sxs-lookup"><span data-stu-id="8507a-186">Alternatively, since Azure Cosmos DB is multi-model, you can use one of the other models to create and scale your graph container.</span></span>

<span data-ttu-id="8507a-187">È possibile leggere qualsiasi vertice o arco usando la chiave di partizione e l'ID in Gremlin.</span><span class="sxs-lookup"><span data-stu-id="8507a-187">You can read any vertex or edge using the partition key and id in Gremlin.</span></span> <span data-ttu-id="8507a-188">Per un grafico con area ("USA") come chiave di partizione e "Seattle" come chiave di riga, ad esempio, è possibile trovare un vertice usando la sintassi seguente:</span><span class="sxs-lookup"><span data-stu-id="8507a-188">For example, for a graph with region ("USA") as the partition key, and "Seattle" as the row key, you can find a vertex using the following syntax:</span></span>

```
g.V(['USA', 'Seattle'])
```

<span data-ttu-id="8507a-189">Allo stesso modo è possibile fare riferimento a un arco usando la chiave di partizione e la chiave di riga.</span><span class="sxs-lookup"><span data-stu-id="8507a-189">Same with edges, you can reference an edge using the partition key and row key.</span></span>

```
g.E(['USA', 'I5'])
```

<span data-ttu-id="8507a-190">Vedere il [supporto di Gremlin per Cosmos DB](gremlin-support.md) per altri dettagli.</span><span class="sxs-lookup"><span data-stu-id="8507a-190">See [Gremlin support for Cosmos DB](gremlin-support.md) for more details.</span></span>


<a name="designing-for-partitioning"></a>
## <a name="designing-for-partitioning"></a><span data-ttu-id="8507a-191">Progettazione per il partizionamento</span><span class="sxs-lookup"><span data-stu-id="8507a-191">Designing for partitioning</span></span>
<span data-ttu-id="8507a-192">Per ridimensionare in modo efficace con Azure Cosmos DB è necessario selezionare una chiave di partizione valida quando si crea il contenitore.</span><span class="sxs-lookup"><span data-stu-id="8507a-192">To scale effectively with Azure Cosmos DB, you need to pick a good partition key when you create your container.</span></span> <span data-ttu-id="8507a-193">È necessario considerare due aspetti fondamentali nella scelta di una chiave di partizione:</span><span class="sxs-lookup"><span data-stu-id="8507a-193">There are two key considerations for choosing a partition key:</span></span>

* <span data-ttu-id="8507a-194">**Limite per query e transazioni**: la scelta della chiave di partizione deve bilanciare la necessità di consentire l'uso di transazioni rispetto al requisito di distribuire le entità tra più chiavi di partizione per garantire una soluzione scalabile.</span><span class="sxs-lookup"><span data-stu-id="8507a-194">**Boundary for query and transactions**: Your choice of partition key should balance the need to enable the use of transactions against the requirement to distribute your entities across multiple partition keys to ensure a scalable solution.</span></span> <span data-ttu-id="8507a-195">Da una parte è possibile impostare la stessa chiave di partizione per tutti gli elementi. Questa scelta potrebbe tuttavia limitare la scalabilità della soluzione.</span><span class="sxs-lookup"><span data-stu-id="8507a-195">At one extreme, you could set the same partition key for all your items, but this may limit the scalability of your solution.</span></span> <span data-ttu-id="8507a-196">Dall'altra parte è possibile assegnare a ogni elemento una chiave di partizione univoca. In questo modo, la soluzione risulterebbe altamente scalabile, ma impedirebbe di usare transazioni tra documenti diversi tramite stored procedure e trigger.</span><span class="sxs-lookup"><span data-stu-id="8507a-196">At the other extreme, you could assign a unique partition key for each item, which would be highly scalable but would prevent you from using cross document transactions via stored procedures and triggers.</span></span> <span data-ttu-id="8507a-197">Una chiave di partizione ideale consente di usare query efficienti e dispone di una quantità sufficiente di cardinalità per garantire la scalabilità della soluzione.</span><span class="sxs-lookup"><span data-stu-id="8507a-197">An ideal partition key is one that enables you to use efficient queries and that has sufficient cardinality to ensure your solution is scalable.</span></span> 
* <span data-ttu-id="8507a-198">**Evitare i colli di bottiglia in termini di archiviazione e prestazioni**: è importante scegliere una proprietà che consenta di distribuire le scritture su una serie di valori distinti.</span><span class="sxs-lookup"><span data-stu-id="8507a-198">**No storage and performance bottlenecks**: It is important to pick a property that allows writes to be distributed across various distinct values.</span></span> <span data-ttu-id="8507a-199">Le richieste per la stessa chiave di partizione non possono superare la velocità effettiva di una partizione singola e vengono limitate.</span><span class="sxs-lookup"><span data-stu-id="8507a-199">Requests to the same partition key cannot exceed the throughput of a single partition, and are throttled.</span></span> <span data-ttu-id="8507a-200">È quindi importante scegliere una chiave di partizione che non generi "aree sensibili" all'interno dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="8507a-200">So it is important to pick a partition key that does not result in "hot spots" within your application.</span></span> <span data-ttu-id="8507a-201">Poiché tutti i dati per una singola chiave di partizione devono essere archiviati in una partizione, è anche consigliabile evitare le chiavi di partizione con volumi elevati di dati per lo stesso valore.</span><span class="sxs-lookup"><span data-stu-id="8507a-201">Since all the data for a single partition key must be stored within a partition, it is also recommended to avoid partition keys that have high volumes of data for the same value.</span></span> 

<span data-ttu-id="8507a-202">Verranno ora esaminati alcuni scenari reali con le chiavi di partizione corrette per ognuno:</span><span class="sxs-lookup"><span data-stu-id="8507a-202">Let's look at a few real-world scenarios, and good partition keys for each:</span></span>
* <span data-ttu-id="8507a-203">Se si implementa un back-end del profilo utente, l'ID utente rappresenta la scelta ideale per la chiave di partizione.</span><span class="sxs-lookup"><span data-stu-id="8507a-203">If you’re implementing a user profile backend, then the user ID is a good choice for partition key.</span></span>
* <span data-ttu-id="8507a-204">Se si archiviano dati IoT, ad esempio lo stato del dispositivo, l'ID dispositivo rappresenta la scelta ideale per la chiave di partizione.</span><span class="sxs-lookup"><span data-stu-id="8507a-204">If you’re storing IoT data for example, device state, a device ID is a good choice for partition key.</span></span>
* <span data-ttu-id="8507a-205">Se si usa Azure Cosmos DB per la registrazione di dati di serie temporali, il nome host o l'ID processo rappresenta la scelta ottimale per la chiave di partizione.</span><span class="sxs-lookup"><span data-stu-id="8507a-205">If you’re using Azure Cosmos DB for logging time-series data, then the hostname or process ID is a good choice for partition key.</span></span>
* <span data-ttu-id="8507a-206">Se si dispone di un'architettura multi-tenant, l'ID tenant rappresenta la scelta ideale per la chiave di partizione.</span><span class="sxs-lookup"><span data-stu-id="8507a-206">If you have a multi-tenant architecture, the tenant ID is a good choice for partition key.</span></span>

<span data-ttu-id="8507a-207">In alcuni casi d'uso, come l'IoT e i profili utente, la chiave di partizione può corrispondere all'ID (chiave del documento).</span><span class="sxs-lookup"><span data-stu-id="8507a-207">In some use cases like IoT and user profiles, the partition key might be the same as your id (document key).</span></span> <span data-ttu-id="8507a-208">In altri casi, come ad esempio i dati di serie temporali, la chiave di partizione potrebbe essere diversa rispetto all'id.</span><span class="sxs-lookup"><span data-stu-id="8507a-208">In others like the time series data, you might have a partition key that’s different than the id.</span></span>

### <a name="partitioning-and-loggingtime-series-data"></a><span data-ttu-id="8507a-209">Partizionamento e registrazione di dati di serie temporali</span><span class="sxs-lookup"><span data-stu-id="8507a-209">Partitioning and logging/time-series data</span></span>
<span data-ttu-id="8507a-210">Uno dei casi d'uso più comuni di Cosmos DB è rappresentato da registrazione e telemetria.</span><span class="sxs-lookup"><span data-stu-id="8507a-210">One of the common use cases of Cosmos DB is for logging and telemetry.</span></span> <span data-ttu-id="8507a-211">È importante scegliere una chiave di partizione efficace perché potrebbe essere necessario scrivere/leggere grandi volumi di dati.</span><span class="sxs-lookup"><span data-stu-id="8507a-211">It is important to pick a good partition key since you might need to read/write vast volumes of data.</span></span> <span data-ttu-id="8507a-212">La scelta dipende dalla frequenza di lettura e scrittura e dai tipi di query che si prevede di eseguire.</span><span class="sxs-lookup"><span data-stu-id="8507a-212">The choice depends on your read and write rates and kinds of queries you expect to run.</span></span> <span data-ttu-id="8507a-213">Di seguito sono riportati alcuni suggerimenti su come scegliere una chiave di partizione efficace.</span><span class="sxs-lookup"><span data-stu-id="8507a-213">Here are some tips on how to choose a good partition key.</span></span>

* <span data-ttu-id="8507a-214">Se il caso d'uso prevede una frequenza ridotta di scritture eseguite in un lungo intervallo di tempo e la necessità di eseguire query in base agli intervalli di timestamp e ad altri filtri, si consiglia l'uso di un rollup del timestamp, ad esempio l'uso della data come chiave di partizione.</span><span class="sxs-lookup"><span data-stu-id="8507a-214">If your use case involves a small rate of writes accumulating over a long period of time, and need to query by ranges of timestamps and other filters, then using a rollup of the timestamp, for example,  date as a partition key is a good approach.</span></span> <span data-ttu-id="8507a-215">Ciò consente di eseguire query su tutti i dati per una data da una singola partizione.</span><span class="sxs-lookup"><span data-stu-id="8507a-215">This allows you to query over all the data for a date from a single partition.</span></span> 
* <span data-ttu-id="8507a-216">Se il carico di lavoro prevede molte scritture, scenario più comune, è opportuno usare una chiave di partizione non basata su timestamp in modo che Cosmos DB possa distribuire in modo uniforme le scritture in più partizioni.</span><span class="sxs-lookup"><span data-stu-id="8507a-216">If your workload is written heavy, which is more common, you should use a partition key that’s not based on timestamp so that Cosmos DB can distribute writes evenly across various partitions.</span></span> <span data-ttu-id="8507a-217">In questo caso, un nome host, un ID processo, un ID attività o un'altra proprietà con una cardinalità elevata è una scelta efficace.</span><span class="sxs-lookup"><span data-stu-id="8507a-217">Here a hostname, process ID, activity ID, or another property with high cardinality is a good choice.</span></span> 
* <span data-ttu-id="8507a-218">Il terzo è un approccio ibrido in cui si hanno più contenitori, uno per ogni giorno/mese, e la chiave di partizione è una proprietà granulare, ad esempio un nome host.</span><span class="sxs-lookup"><span data-stu-id="8507a-218">A third approach is a hybrid one where you have multiple containers, one for each day/month and the partition key is a granular property like hostname.</span></span> <span data-ttu-id="8507a-219">Il vantaggio di questo approccio riguarda la possibilità di impostare diverse velocità effettive in base alla finestra temporale, ad esempio il provisioning del contenitore per il mese corrente viene eseguito con una velocità effettiva maggiore perché viene usata per letture e scritture, mentre per i mesi precedenti è possibile ridurre la velocità effettiva perché vengono usati solo per le letture.</span><span class="sxs-lookup"><span data-stu-id="8507a-219">This has the benefit that you can set different throughput based on the time window, for example, the container for the current month is provisioned with higher throughput since it serves reads and writes, whereas previous months with lower throughput since they only serve reads.</span></span>

### <a name="partitioning-and-multi-tenancy"></a><span data-ttu-id="8507a-220">Partizionamento e multi-tenancy</span><span class="sxs-lookup"><span data-stu-id="8507a-220">Partitioning and multi-tenancy</span></span>
<span data-ttu-id="8507a-221">Se si implementa un'applicazione multi-tenant usando Cosmos DB, sono disponibili due modelli comuni: una chiave di partizione per ogni tenant e un contenitore per ogni tenant.</span><span class="sxs-lookup"><span data-stu-id="8507a-221">If you are implementing a multi-tenant application using Cosmos DB, there are two popular patterns – one partition key per tenant, and one container per tenant.</span></span> <span data-ttu-id="8507a-222">Di seguito sono riportati vantaggi e svantaggi di ogni modello:</span><span class="sxs-lookup"><span data-stu-id="8507a-222">Here are the pros and cons for each:</span></span>

* <span data-ttu-id="8507a-223">Una chiave di partizione per ogni tenant: in questo modello, i tenant vengono collocati all'interno di un singolo contenitore.</span><span class="sxs-lookup"><span data-stu-id="8507a-223">One Partition Key per tenant: In this model, tenants are collocated within a single container.</span></span> <span data-ttu-id="8507a-224">Le query e gli inserimenti di elementi all'interno di un tenant possono essere tuttavia eseguiti a fronte di una partizione singola.</span><span class="sxs-lookup"><span data-stu-id="8507a-224">But queries and inserts for items within a single tenant can be performed against a single partition.</span></span> <span data-ttu-id="8507a-225">È anche possibile implementare la logica transazionale su tutti gli elementi all'interno di un tenant.</span><span class="sxs-lookup"><span data-stu-id="8507a-225">You can also implement transactional logic across all items within a tenant.</span></span> <span data-ttu-id="8507a-226">Poiché più tenant condividono un contenitore, è possibile risparmiare i costi di archiviazione e velocità effettiva raggruppando le risorse per i tenant all'interno di un singolo contenitore invece di eseguire il provisioning di capacità aggiuntiva per ogni tenant.</span><span class="sxs-lookup"><span data-stu-id="8507a-226">Since multiple tenants share a container, you can save storage and throughput costs by pooling resources for tenants within a single container rather than provisioning extra headroom for each tenant.</span></span> <span data-ttu-id="8507a-227">Lo svantaggio è che non si ottiene l'isolamento delle prestazioni per ogni tenant.</span><span class="sxs-lookup"><span data-stu-id="8507a-227">The drawback is that you do not have performance isolation per tenant.</span></span> <span data-ttu-id="8507a-228">Gli aumenti di prestazioni/velocità effettiva si applicano all'intero contenitore rispetto agli aumenti previsti per i tenant.</span><span class="sxs-lookup"><span data-stu-id="8507a-228">Performance/throughput increases apply to the entire container vs targeted increases for tenants.</span></span>
* <span data-ttu-id="8507a-229">Un contenitore per ogni tenant: ogni tenant ha un contenitore proprio.</span><span class="sxs-lookup"><span data-stu-id="8507a-229">One Container per tenant: Each tenant has its own container.</span></span> <span data-ttu-id="8507a-230">In questo modello è possibile riservare le prestazioni per ogni tenant.</span><span class="sxs-lookup"><span data-stu-id="8507a-230">In this model, you can reserve performance per tenant.</span></span> <span data-ttu-id="8507a-231">Con il nuovo schema tariffario per il provisioning di Cosmos DB, questo modello è più conveniente per applicazioni multi-tenant con un numero ridotto di tenant.</span><span class="sxs-lookup"><span data-stu-id="8507a-231">With Cosmos DB's new provisioning pricing model, this model is more cost-effective for multi-tenant applications with a few tenants.</span></span>

<span data-ttu-id="8507a-232">È anche possibile usare un approccio combinato/a livelli che colloca tenant di dimensioni ridotte ed esegue la migrazione di tenant di dimensioni maggiori al relativo contenitore.</span><span class="sxs-lookup"><span data-stu-id="8507a-232">You can also use a combination/tiered approach that collocates small tenants and migrates larger tenants to their own container.</span></span>

## <a name="next-steps"></a><span data-ttu-id="8507a-233">Passaggi successivi</span><span class="sxs-lookup"><span data-stu-id="8507a-233">Next steps</span></span>
<span data-ttu-id="8507a-234">In questo articolo è stata illustrata una panoramica di concetti e procedure consigliate per il partizionamento con qualsiasi API di Azure Cosmos DB.</span><span class="sxs-lookup"><span data-stu-id="8507a-234">In this article, we provided an overview for an overview of concepts and best practices for partitioning with any Azure Cosmos DB API.</span></span> 

* <span data-ttu-id="8507a-235">Informazioni sulla [velocità effettiva con provisioning in Azure Cosmos DB](request-units.md)</span><span class="sxs-lookup"><span data-stu-id="8507a-235">Learn about [provisioned throughput in Azure Cosmos DB](request-units.md)</span></span>
* <span data-ttu-id="8507a-236">Informazioni sulla [distribuzione globale in Azure Cosmos DB](distribute-data-globally.md)</span><span class="sxs-lookup"><span data-stu-id="8507a-236">Learn about [global distribution in Azure Cosmos DB](distribute-data-globally.md)</span></span>



