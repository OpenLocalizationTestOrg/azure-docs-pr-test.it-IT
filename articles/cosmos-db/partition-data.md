---
title: "aaaPartitioning e la scalabilità orizzontale nel database di Azure Cosmos | Documenti Microsoft"
description: "Informazioni sul funzionamento della modalità di partizionamento nel database di Azure Cosmos, come tooconfigure partizionamento e le chiavi di partizione e come toopick hello destra chiave di partizione per l'applicazione."
services: cosmos-db
author: arramac
manager: jhubbard
editor: monicar
documentationcenter: 
ms.assetid: cac9a8cd-b5a3-4827-8505-d40bb61b2416
ms.service: cosmos-db
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 05/10/2017
ms.author: arramac
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: 87d56db8c4ccc6b94b1650baff0fcfb3db6d1777
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 10/06/2017
---
# <a name="how-toopartition-and-scale-in-azure-cosmos-db"></a><span data-ttu-id="6fdf2-103">Come toopartition e la scala in Azure Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="6fdf2-103">How toopartition and scale in Azure Cosmos DB</span></span>

<span data-ttu-id="6fdf2-104">[Database di Microsoft Azure Cosmos](https://azure.microsoft.com/services/cosmos-db/) è toohelp di servizio progettato un database distribuito e più modelli globali è ottenere scalabilità e prestazioni rapido e prevedibile facilmente insieme all'applicazione di si sviluppa.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-104">[Microsoft Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/) is a global distributed, multi-model database service designed toohelp you achieve fast, predictable performance and scale seamlessly along with your application as it grows.</span></span> <span data-ttu-id="6fdf2-105">In questo articolo viene fornita una panoramica del partizionamento può essere usato per tutti i dati di hello modelli in Azure Cosmos DB e viene descritto come configurare la scala di Azure Cosmos DB contenitori tooeffectively delle applicazioni.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-105">This article provides an overview of how partitioning works for all hello data models in Azure Cosmos DB, and describes how you can configure Azure Cosmos DB containers tooeffectively scale your applications.</span></span>

<span data-ttu-id="6fdf2-106">Il partizionamento e le chiavi di partizione sono illustrati anche in questo video di Azure Friday con Scott Hanselman e Shireesh Thota, responsabile principale della progettazione di Azure Cosmos DB.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-106">Partitioning and partition keys are also covered in this Azure Friday video with Scott Hanselman and Azure Cosmos DB Principal Engineering Manager, Shireesh Thota.</span></span>

> [!VIDEO https://channel9.msdn.com/Shows/Azure-Friday/Azure-DocumentDB-Elastic-Scale-Partitioning/player]
> 

## <a name="partitioning-in-azure-cosmos-db"></a><span data-ttu-id="6fdf2-107">Partizionamento in Azure Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="6fdf2-107">Partitioning in Azure Cosmos DB</span></span>
<span data-ttu-id="6fdf2-108">In Azure Cosmos DB è possibile archiviare dati ed eseguire query senza schema con tempi di risposta nell'ordine di millisecondi su qualsiasi scala.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-108">In Azure Cosmos DB, you can store and query schema-less data with order-of-millisecond response times at any scale.</span></span> <span data-ttu-id="6fdf2-109">Cosmos DB offre contenitori per l'archiviazione di dati denominati **raccolte (per i documenti), grafici o tabelle**.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-109">Cosmos DB provides containers for storing data called **collections (for document), graphs, or tables**.</span></span> <span data-ttu-id="6fdf2-110">I contenitori sono risorse logiche e possono comprendere una o più partizioni fisiche o server.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-110">Containers are logical resources and can span one or more physical partitions or servers.</span></span> <span data-ttu-id="6fdf2-111">numero di Hello di partizioni è determinato dal DB Cosmos in base alle dimensioni di archiviazione hello e velocità effettiva di provisioning hello del contenitore di hello.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-111">hello number of partitions is determined by Cosmos DB based on hello storage size and hello provisioned throughput of hello container.</span></span> <span data-ttu-id="6fdf2-112">Ogni partizione in Cosmos DB ha una quantità fissa di archiviazione supportata da unità SSD associata e viene replicata per la disponibilità elevata.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-112">Every partition in Cosmos DB has a fixed amount of SSD-backed storage associated with it, and is replicated for high availability.</span></span> <span data-ttu-id="6fdf2-113">Gestione delle partizioni è completamente gestiti da Azure Cosmos DB, e non si dispone di codice complesso toowrite o gestire le partizioni.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-113">Partition management is fully managed by Azure Cosmos DB, and you do not have toowrite complex code or manage your partitions.</span></span> <span data-ttu-id="6fdf2-114">I contenitori di Cosmos DB sono illimitati in termini di risorse di archiviazione e di velocità effettiva.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-114">Cosmos DB containers are unlimited in terms of storage and throughput.</span></span> 

![orizzontale](./media/introduction/azure-cosmos-db-partitioning.png) 

<span data-ttu-id="6fdf2-116">Il partizionamento è trasparente tooyour applicazione.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-116">Partitioning is transparent tooyour application.</span></span> <span data-ttu-id="6fdf2-117">COSMOS DB supporta veloce letture e scritture, query, la logica transazionale, livelli di coerenza e controllo di accesso con granularità fine tramite la risorsa di metodi/API tooa singolo contenitore.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-117">Cosmos DB supports fast reads and writes, queries, transactional logic, consistency levels, and fine-grained access control via methods/APIs tooa single container resource.</span></span> <span data-ttu-id="6fdf2-118">Hello servizio gestisce la distribuzione dei dati tra partizioni e routing partizione corretta toohello le richieste di query.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-118">hello service handles distributing data across partitions and routing query requests toohello right partition.</span></span> 

<span data-ttu-id="6fdf2-119">Per il partizionamento,</span><span class="sxs-lookup"><span data-stu-id="6fdf2-119">How does partitioning work?</span></span> <span data-ttu-id="6fdf2-120">ogni elemento deve avere una chiave di partizione e una chiave di riga che lo identificano in modo univoco.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-120">Each item must have a partition key and a row key, which uniquely identify it.</span></span> <span data-ttu-id="6fdf2-121">La chiave di partizione funge da partizione logica per i dati e fornisce a Cosmos DB un limite naturale per la distribuzione dei dati tra partizioni.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-121">Your partition key acts as a logical partition for your data, and provides Cosmos DB with a natural boundary for distributing data across partitions.</span></span> <span data-ttu-id="6fdf2-122">In sintesi, il partizionamento in Azure Cosmos DB funziona nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="6fdf2-122">In brief, here is how partitioning works in Azure Cosmos DB:</span></span>

* <span data-ttu-id="6fdf2-123">Si esegue il provisioning di un contenitore Cosmos DB con velocità effettiva di `T` richieste/s</span><span class="sxs-lookup"><span data-stu-id="6fdf2-123">You provision a Cosmos DB container with `T` requests/s throughput</span></span>
* <span data-ttu-id="6fdf2-124">Dietro le quinte hello partizioni disposizioni Cosmos DB necessari tooserve `T` richieste/s.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-124">Behind hello scenes, Cosmos DB provisions partitions needed tooserve `T` requests/s.</span></span> <span data-ttu-id="6fdf2-125">Se `T` è superiore alla velocità effettiva massima hello per ogni partizione `t`, quindi esegue il provisioning Cosmos DB `N`  =  `T/t` partizioni</span><span class="sxs-lookup"><span data-stu-id="6fdf2-125">If `T` is higher than hello maximum throughput per partition `t`, then Cosmos DB provisions `N` = `T/t` partitions</span></span>
* <span data-ttu-id="6fdf2-126">COSMOS DB alloca spazio della chiave di partizione hello gli hash delle chiavi in modo uniforme tra hello `N` partizioni.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-126">Cosmos DB allocates hello key space of partition key hashes evenly across hello `N` partitions.</span></span> <span data-ttu-id="6fdf2-127">Ogni partizione fisica ospita quindi 1-N valori di chiave di partizione (partizioni logiche)</span><span class="sxs-lookup"><span data-stu-id="6fdf2-127">So, each partition (physical partition) hosts 1-N partition key values (logical partitions)</span></span>
* <span data-ttu-id="6fdf2-128">Quando una partizione fisica `p` raggiunge il limite di archiviazione, DB Cosmos divide perfettamente `p` in due partizioni nuovo `p1` e `p2` e distribuisce i valori corrispondenti tooroughly metà hello chiavi tooeach di hello partizioni.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-128">When a physical partition `p` reaches its storage limit, Cosmos DB seamlessly splits `p` into two new partitions `p1` and `p2` and distributes values corresponding tooroughly half hello keys tooeach of hello partitions.</span></span> <span data-ttu-id="6fdf2-129">Operazione di divisione è invisibile tooyour applicazione.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-129">This split operation is invisible tooyour application.</span></span>
* <span data-ttu-id="6fdf2-130">Analogamente, quando si esegue il provisioning della velocità effettiva superiore `t*N` velocità effettiva, DB Cosmos suddivide in uno o più le partizioni toosupport hello una velocità effettiva</span><span class="sxs-lookup"><span data-stu-id="6fdf2-130">Similarly, when you provision throughput higher than `t*N` throughput, Cosmos DB splits one or more of your partitions toosupport hello higher throughput</span></span>

<span data-ttu-id="6fdf2-131">semantica di Hello per le chiavi di partizione è semantica hello toomatch leggermente diverse di ogni API, come illustrato nella seguente tabella hello:</span><span class="sxs-lookup"><span data-stu-id="6fdf2-131">hello semantics for partition keys are slightly different toomatch hello semantics of each API, as shown in hello following table:</span></span>

| <span data-ttu-id="6fdf2-132">API</span><span class="sxs-lookup"><span data-stu-id="6fdf2-132">API</span></span> | <span data-ttu-id="6fdf2-133">Chiave di partizione</span><span class="sxs-lookup"><span data-stu-id="6fdf2-133">Partition Key</span></span> | <span data-ttu-id="6fdf2-134">Chiave di riga</span><span class="sxs-lookup"><span data-stu-id="6fdf2-134">Row Key</span></span> |
| --- | --- | --- |
| <span data-ttu-id="6fdf2-135">DocumentDB</span><span class="sxs-lookup"><span data-stu-id="6fdf2-135">DocumentDB</span></span> | <span data-ttu-id="6fdf2-136">percorso personalizzato della chiave di partizione</span><span class="sxs-lookup"><span data-stu-id="6fdf2-136">custom partition key path</span></span> | <span data-ttu-id="6fdf2-137">`id` fisso</span><span class="sxs-lookup"><span data-stu-id="6fdf2-137">fixed `id`</span></span> | 
| <span data-ttu-id="6fdf2-138">MongoDB</span><span class="sxs-lookup"><span data-stu-id="6fdf2-138">MongoDB</span></span> | <span data-ttu-id="6fdf2-139">chiave di partizione personalizzata</span><span class="sxs-lookup"><span data-stu-id="6fdf2-139">custom shard key</span></span>  | <span data-ttu-id="6fdf2-140">`_id` fisso</span><span class="sxs-lookup"><span data-stu-id="6fdf2-140">fixed `_id`</span></span> | 
| <span data-ttu-id="6fdf2-141">Grafico</span><span class="sxs-lookup"><span data-stu-id="6fdf2-141">Graph</span></span> | <span data-ttu-id="6fdf2-142">proprietà chiave di partizione personalizzata</span><span class="sxs-lookup"><span data-stu-id="6fdf2-142">custom partition key property</span></span> | <span data-ttu-id="6fdf2-143">`id` fisso</span><span class="sxs-lookup"><span data-stu-id="6fdf2-143">fixed `id`</span></span> | 
| <span data-ttu-id="6fdf2-144">Tabella</span><span class="sxs-lookup"><span data-stu-id="6fdf2-144">Table</span></span> | <span data-ttu-id="6fdf2-145">`PartitionKey` fisso</span><span class="sxs-lookup"><span data-stu-id="6fdf2-145">fixed `PartitionKey`</span></span> | <span data-ttu-id="6fdf2-146">`RowKey` fisso</span><span class="sxs-lookup"><span data-stu-id="6fdf2-146">fixed `RowKey`</span></span> | 

<span data-ttu-id="6fdf2-147">Cosmos DB usa il partizionamento basato su hash.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-147">Cosmos DB uses hash-based partitioning.</span></span> <span data-ttu-id="6fdf2-148">Quando si scrive un elemento, DB Cosmos hash valore di chiave di partizione hello e utilizzare hello eseguito l'hashing toodetermine risultato partizione toostore hello voce.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-148">When you write an item, Cosmos DB hashes hello partition key value and use hello hashed result toodetermine which partition toostore hello item in.</span></span> <span data-ttu-id="6fdf2-149">Archivi COSMOS DB tutti gli elementi con hello stessa chiave di partizione in hello stessa partizione fisica.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-149">Cosmos DB stores all items with hello same partition key in hello same physical partition.</span></span> <span data-ttu-id="6fdf2-150">scelta di Hello hello della chiave di partizione è una decisione importante avere toomake in fase di progettazione.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-150">hello choice of hello partition key is an important decision that you have toomake at design time.</span></span> <span data-ttu-id="6fdf2-151">È necessario scegliere un nome proprietà che contenga un'ampia gamma di valori e abbia anche modelli di accesso.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-151">You must pick a property name that has a wide range of values and has even access patterns.</span></span>

> [!NOTE]
> <span data-ttu-id="6fdf2-152">È una migliore toohave pratica una chiave di partizione con molti valori distinti (100s-1000s minimo).</span><span class="sxs-lookup"><span data-stu-id="6fdf2-152">It is a best practice toohave a partition key with many distinct values (100s-1000s at a minimum).</span></span>
>

<span data-ttu-id="6fdf2-153">I contenitori di Azure Cosmos DB possono essere creati come "fissi" o "illimitati".</span><span class="sxs-lookup"><span data-stu-id="6fdf2-153">Azure Cosmos DB containers can be created as "fixed" or "unlimited."</span></span> <span data-ttu-id="6fdf2-154">I contenitori a dimensione fissa hanno un limite massimo di 10 GB e velocità effettiva di 10.000 UR/s.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-154">Fixed-size containers have a maximum limit of 10 GB and 10,000 RU/s throughput.</span></span> <span data-ttu-id="6fdf2-155">Alcune API consentono toobe chiave di partizione hello omesso per i contenitori di dimensioni fisse.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-155">Some APIs allow hello partition key toobe omitted for fixed-size containers.</span></span> <span data-ttu-id="6fdf2-156">un contenitore come illimitato toocreate, è necessario specificare una velocità effettiva minima di 2500 UR/sec.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-156">toocreate a container as unlimited, you must specify a minimum throughput of 2500 RU/s.</span></span>

## <a name="partitioning-and-provisioned-throughput"></a><span data-ttu-id="6fdf2-157">Partizionamento e velocità effettiva con provisioning</span><span class="sxs-lookup"><span data-stu-id="6fdf2-157">Partitioning and provisioned throughput</span></span>
<span data-ttu-id="6fdf2-158">Cosmos DB è progettato per prestazioni prevedibili.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-158">Cosmos DB is designed for predictable performance.</span></span> <span data-ttu-id="6fdf2-159">Quando si crea un contenitore, la velocità effettiva viene riservata in termini di **[unità richiesta](request-units.md) (UR) al secondo, con un potenziale add-on per UR al minuto**.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-159">When you create a container, you reserve throughput in terms of **[request units](request-units.md) (RU) per second with a potential add-on for RU per minute**.</span></span> <span data-ttu-id="6fdf2-160">Ogni richiesta viene assegnato un addebito di unità di richiesta che è la quantità proporzionale toohello delle risorse di sistema come CPU, memoria e i/o utilizzata dall'operazione hello.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-160">Each request is assigned a request unit charge that is proportionate toohello amount of system resources like CPU, Memory, and IO consumed by hello operation.</span></span> <span data-ttu-id="6fdf2-161">La lettura di un documento di 1 KB con coerenza di sessione usa un'unità richiesta.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-161">A read of a 1-KB document with Session consistency consumes one request unit.</span></span> <span data-ttu-id="6fdf2-162">Un'operazione di lettura è 1 UR indipendentemente dal numero di hello di elementi archiviati o hello numero di richieste simultanee in esecuzione in hello contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-162">A read is 1 RU regardless of hello number of items stored or hello number of concurrent requests running at hello same time.</span></span> <span data-ttu-id="6fdf2-163">Gli elementi più grandi richiedono maggiore di unità di richiesta in base alle dimensioni hello.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-163">Larger items require higher request units depending on hello size.</span></span> <span data-ttu-id="6fdf2-164">Se si conoscono dimensioni hello le entità e numero di letture di hello toosupport è necessario per l'applicazione, è possibile eseguire il provisioning di quantità esatta di hello di velocità effettiva richiesta per l'applicazione necessita read.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-164">If you know hello size of your entities and hello number of reads you need toosupport for your application, you can provision hello exact amount of throughput required for your application's read needs.</span></span> 

> [!NOTE]
> <span data-ttu-id="6fdf2-165">tooachieve hello piena velocità effettiva del contenitore di hello, è necessario scegliere una chiave di partizione che consente di tooevenly distribuire le richieste tra alcuni valori di chiave di partizione distinta.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-165">tooachieve hello full throughput of hello container, you must choose a partition key that allows you tooevenly distribute requests among some distinct partition key values.</span></span>
> 
> 

<a name="designing-for-partitioning"></a>
## <a name="working-with-hello-azure-cosmos-db-apis"></a><span data-ttu-id="6fdf2-166">Utilizzo di hello Azure Cosmos DB API</span><span class="sxs-lookup"><span data-stu-id="6fdf2-166">Working with hello Azure Cosmos DB APIs</span></span>
<span data-ttu-id="6fdf2-167">È possibile usare hello portale di Azure o i contenitori di toocreate CLI di Azure e li ridimensionare in qualsiasi momento.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-167">You can use hello Azure portal or Azure CLI toocreate containers and scale them at any time.</span></span> <span data-ttu-id="6fdf2-168">Questa sezione viene illustrato come contenitori toocreate e specificare hello velocità effettiva e la partizione di definizione della chiave in ogni hello API supportate.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-168">This section shows how toocreate containers and specify hello throughput and partition key definition in each of hello supported APIs.</span></span>

### <a name="documentdb-api"></a><span data-ttu-id="6fdf2-169">API di DocumentDB</span><span class="sxs-lookup"><span data-stu-id="6fdf2-169">DocumentDB API</span></span>
<span data-ttu-id="6fdf2-170">Hello seguente esempio viene illustrato come un contenitore (raccolta) usando toocreate hello API DocumentDB.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-170">hello following sample shows how toocreate a container (collection) using hello DocumentDB API.</span></span> <span data-ttu-id="6fdf2-171">Per informazioni più dettagliate, vedere [Partizionamento con l'API di DocumentDB](partition-data.md).</span><span class="sxs-lookup"><span data-stu-id="6fdf2-171">You can find more details in [Partitioning with DocumentDB API](partition-data.md).</span></span>

```csharp
DocumentClient client = new DocumentClient(new Uri(endpoint), authKey);
await client.CreateDatabaseAsync(new Database { Id = "db" });

DocumentCollection myCollection = new DocumentCollection();
myCollection.Id = "coll";
myCollection.PartitionKey.Paths.Add("/deviceId");

await client.CreateDocumentCollectionAsync(
    UriFactory.CreateDatabaseUri("db"),
    myCollection,
    new RequestOptions { OfferThroughput = 20000 });
```

<span data-ttu-id="6fdf2-172">È possibile leggere un elemento (documento) utilizzando hello `GET` metodo hello API REST o `ReadDocumentAsync` in uno dei hello SDK.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-172">You can read an item (document) using hello `GET` method in hello REST API or using `ReadDocumentAsync` in one of hello SDKs.</span></span>

```csharp
// Read document. Needs hello partition key and hello ID toobe specified
DeviceReading document = await client.ReadDocumentAsync<DeviceReading>(
  UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
  new RequestOptions { PartitionKey = new PartitionKey("XMS-0001") });
```

### <a name="mongodb-api"></a><span data-ttu-id="6fdf2-173">API di MongoDB</span><span class="sxs-lookup"><span data-stu-id="6fdf2-173">MongoDB API</span></span>
<span data-ttu-id="6fdf2-174">Con hello MongoDB API, è possibile creare una raccolta partizionata tramite il proprio SDK, driver o lo strumento preferito.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-174">With hello MongoDB API, you can create a sharded collection through your favorite tool, driver, or SDK.</span></span> <span data-ttu-id="6fdf2-175">In questo esempio hello Shell di Mongo viene usata per la creazione della raccolta hello.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-175">In this example, we use hello Mongo Shell for hello collection creation.</span></span>

<span data-ttu-id="6fdf2-176">Nella Shell di Mongo hello:</span><span class="sxs-lookup"><span data-stu-id="6fdf2-176">In hello Mongo Shell:</span></span>

```
db.runCommand( { shardCollection: "admin.people", key: { region: "hashed" } } )
```
    
<span data-ttu-id="6fdf2-177">Risultati:</span><span class="sxs-lookup"><span data-stu-id="6fdf2-177">Results:</span></span>

```JSON
{
    "_t" : "ShardCollectionResponse",
    "ok" : 1,
    "collectionsharded" : "admin.people"
}
```

### <a name="table-api"></a><span data-ttu-id="6fdf2-178">API di tabella</span><span class="sxs-lookup"><span data-stu-id="6fdf2-178">Table API</span></span>

<span data-ttu-id="6fdf2-179">Con hello API di tabella, specificare la velocità effettiva hello per le tabelle nella configurazione appSettings hello per l'applicazione:</span><span class="sxs-lookup"><span data-stu-id="6fdf2-179">With hello Table API, you specify hello throughput for tables in hello appSettings configuration for your application:</span></span>

```xml
<configuration>
    <appSettings>
      <!--Table creation options -->
      <add key="TableThroughput" value="700"/>
    </appSettings>
</configuration>
```

<span data-ttu-id="6fdf2-180">Quindi necessario creare una tabella utilizzando l'archiviazione tabelle di Azure hello SDK.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-180">Then you create a table using hello Azure Table storage SDK.</span></span> <span data-ttu-id="6fdf2-181">chiave di partizione Hello viene creata implicitamente come hello `PartitionKey` valore.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-181">hello partition key is implicitly created as hello `PartitionKey` value.</span></span> 

```csharp
CloudTableClient tableClient = storageAccount.CreateCloudTableClient();

CloudTable table = tableClient.GetTableReference("people");
table.CreateIfNotExists();
```

<span data-ttu-id="6fdf2-182">È possibile recuperare una singola entità utilizzando hello frammento di codice seguente:</span><span class="sxs-lookup"><span data-stu-id="6fdf2-182">You can retrieve a single entity using hello following snippet:</span></span>

```csharp
// Create a retrieve operation that takes a customer entity.
TableOperation retrieveOperation = TableOperation.Retrieve<CustomerEntity>("Smith", "Ben");

// Execute hello retrieve operation.
TableResult retrievedResult = table.Execute(retrieveOperation);
```
<span data-ttu-id="6fdf2-183">Vedere [allo sviluppo con hello tabella API](tutorial-develop-table-dotnet.md) per altri dettagli.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-183">See [Developing with hello Table API](tutorial-develop-table-dotnet.md) for more details.</span></span>

### <a name="graph-api"></a><span data-ttu-id="6fdf2-184">API Graph</span><span class="sxs-lookup"><span data-stu-id="6fdf2-184">Graph API</span></span>

<span data-ttu-id="6fdf2-185">Con hello API Graph, è necessario utilizzare hello portale di Azure o contenitori toocreate CLI.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-185">With hello Graph API, you must use hello Azure portal or CLI toocreate containers.</span></span> <span data-ttu-id="6fdf2-186">In alternativa, poiché Azure Cosmos DB è più modelli, è possibile utilizzare uno dei hello toocreate altri modelli e ridimensionare il contenitore grafico.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-186">Alternatively, since Azure Cosmos DB is multi-model, you can use one of hello other models toocreate and scale your graph container.</span></span>

<span data-ttu-id="6fdf2-187">È possibile leggere alcun bordo utilizzando la chiave di partizione hello e id in Gremlin vertice.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-187">You can read any vertex or edge using hello partition key and id in Gremlin.</span></span> <span data-ttu-id="6fdf2-188">Per un grafico con l'area ('USA') come chiave di partizione hello e "Seattle" come chiave di riga hello, ad esempio, è possibile trovare un vertice utilizzando hello la seguente sintassi:</span><span class="sxs-lookup"><span data-stu-id="6fdf2-188">For example, for a graph with region ("USA") as hello partition key, and "Seattle" as hello row key, you can find a vertex using hello following syntax:</span></span>

```
g.V(['USA', 'Seattle'])
```

<span data-ttu-id="6fdf2-189">Stesso con bordi, è possibile fare riferimento un bordo con la chiave di partizione hello e la chiave di riga.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-189">Same with edges, you can reference an edge using hello partition key and row key.</span></span>

```
g.E(['USA', 'I5'])
```

<span data-ttu-id="6fdf2-190">Vedere il [supporto di Gremlin per Cosmos DB](gremlin-support.md) per altri dettagli.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-190">See [Gremlin support for Cosmos DB](gremlin-support.md) for more details.</span></span>


<a name="designing-for-partitioning"></a>
## <a name="designing-for-partitioning"></a><span data-ttu-id="6fdf2-191">Progettazione per il partizionamento</span><span class="sxs-lookup"><span data-stu-id="6fdf2-191">Designing for partitioning</span></span>
<span data-ttu-id="6fdf2-192">tooscale in modo efficace con Azure Cosmos DB, è necessario toopick una buona chiave di partizione quando si crea il contenitore.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-192">tooscale effectively with Azure Cosmos DB, you need toopick a good partition key when you create your container.</span></span> <span data-ttu-id="6fdf2-193">È necessario considerare due aspetti fondamentali nella scelta di una chiave di partizione:</span><span class="sxs-lookup"><span data-stu-id="6fdf2-193">There are two key considerations for choosing a partition key:</span></span>

* <span data-ttu-id="6fdf2-194">**Limite per query e transazioni**: la scelta della chiave di partizione deve bilanciare hello necessità tooenable hello ricorso transazioni su hello requisito toodistribute le entità più tooensure di chiavi di partizione una soluzione scalabile.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-194">**Boundary for query and transactions**: Your choice of partition key should balance hello need tooenable hello use of transactions against hello requirement toodistribute your entities across multiple partition keys tooensure a scalable solution.</span></span> <span data-ttu-id="6fdf2-195">A un'estremità, è possibile impostare hello stessa chiave di partizione per tutti gli elementi, ma ciò potrebbe limitare la scalabilità hello della soluzione.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-195">At one extreme, you could set hello same partition key for all your items, but this may limit hello scalability of your solution.</span></span> <span data-ttu-id="6fdf2-196">In hello altra estremità, è possibile assegnare una chiave di partizione univoca per ogni elemento, che sarebbe altamente scalabile, ma ne impedisce l'utilizzo delle transazioni tra documento tramite stored procedure e trigger.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-196">At hello other extreme, you could assign a unique partition key for each item, which would be highly scalable but would prevent you from using cross document transactions via stored procedures and triggers.</span></span> <span data-ttu-id="6fdf2-197">Una chiave di partizione ideale è che consente di eseguire query efficienti toouse e che disponga di sufficienti cardinalità tooensure la soluzione è scalabile.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-197">An ideal partition key is one that enables you toouse efficient queries and that has sufficient cardinality tooensure your solution is scalable.</span></span> 
* <span data-ttu-id="6fdf2-198">**Non colli di bottiglia delle prestazioni e archiviazione**: è importante una proprietà che consente di toopick scrive toobe distribuiti in diversi valori distinti.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-198">**No storage and performance bottlenecks**: It is important toopick a property that allows writes toobe distributed across various distinct values.</span></span> <span data-ttu-id="6fdf2-199">Richieste toohello stessa chiave di partizione non può superare la velocità effettiva hello di una singola partizione e sono limitate.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-199">Requests toohello same partition key cannot exceed hello throughput of a single partition, and are throttled.</span></span> <span data-ttu-id="6fdf2-200">Pertanto, è importante toopick una chiave di partizione che non produce "sensibili" all'interno dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-200">So it is important toopick a partition key that does not result in "hot spots" within your application.</span></span> <span data-ttu-id="6fdf2-201">Poiché tutti i dati di hello per una chiave singola partizione deve essere archiviata all'interno di una partizione, è inoltre consigliabile tooavoid le chiavi di partizione con volumi elevati di dati per hello stesso valore.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-201">Since all hello data for a single partition key must be stored within a partition, it is also recommended tooavoid partition keys that have high volumes of data for hello same value.</span></span> 

<span data-ttu-id="6fdf2-202">Verranno ora esaminati alcuni scenari reali con le chiavi di partizione corrette per ognuno:</span><span class="sxs-lookup"><span data-stu-id="6fdf2-202">Let's look at a few real-world scenarios, and good partition keys for each:</span></span>
* <span data-ttu-id="6fdf2-203">Se si sta implementando un back-end del profilo utente, l'ID utente hello è una buona scelta per la chiave di partizione.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-203">If you’re implementing a user profile backend, then hello user ID is a good choice for partition key.</span></span>
* <span data-ttu-id="6fdf2-204">Se si archiviano dati IoT, ad esempio lo stato del dispositivo, l'ID dispositivo rappresenta la scelta ideale per la chiave di partizione.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-204">If you’re storing IoT data for example, device state, a device ID is a good choice for partition key.</span></span>
* <span data-ttu-id="6fdf2-205">Se si usa Azure Cosmos DB per la registrazione di dati della serie temporale, quindi hello nome host o l'ID del processo è una buona scelta per la chiave di partizione.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-205">If you’re using Azure Cosmos DB for logging time-series data, then hello hostname or process ID is a good choice for partition key.</span></span>
* <span data-ttu-id="6fdf2-206">Se si dispone di un'architettura multi-tenant, l'ID tenant hello è una buona scelta per la chiave di partizione.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-206">If you have a multi-tenant architecture, hello tenant ID is a good choice for partition key.</span></span>

<span data-ttu-id="6fdf2-207">In alcuni casi come IoT di utilizzo e i profili utente, chiave di partizione hello potrebbe essere hello stesso come id (chiave di documento).</span><span class="sxs-lookup"><span data-stu-id="6fdf2-207">In some use cases like IoT and user profiles, hello partition key might be hello same as your id (document key).</span></span> <span data-ttu-id="6fdf2-208">In altre come dati della serie temporale hello, potrebbe essere una chiave di partizione diverso da id hello.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-208">In others like hello time series data, you might have a partition key that’s different than hello id.</span></span>

### <a name="partitioning-and-loggingtime-series-data"></a><span data-ttu-id="6fdf2-209">Partizionamento e registrazione di dati di serie temporali</span><span class="sxs-lookup"><span data-stu-id="6fdf2-209">Partitioning and logging/time-series data</span></span>
<span data-ttu-id="6fdf2-210">Uno dei casi di utilizzo del database Cosmos comuni hello è per la registrazione e i dati di telemetria.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-210">One of hello common use cases of Cosmos DB is for logging and telemetry.</span></span> <span data-ttu-id="6fdf2-211">È importante toopick una chiave di partizione valido in quanto potrebbe essere necessario volumi di grandi tooread/scrittura di dati.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-211">It is important toopick a good partition key since you might need tooread/write vast volumes of data.</span></span> <span data-ttu-id="6fdf2-212">scelta di Hello dipende dalla lettura e velocità di scrittura e i tipi di query che previsti toorun.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-212">hello choice depends on your read and write rates and kinds of queries you expect toorun.</span></span> <span data-ttu-id="6fdf2-213">Ecco alcuni suggerimenti su come toochoose una chiave di partizione valido.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-213">Here are some tips on how toochoose a good partition key.</span></span>

* <span data-ttu-id="6fdf2-214">Se il caso di utilizzo prevede un tasso di piccole dimensioni scrive totale per un lungo periodo di tempo e necessità tooquery da intervalli di timestamp e altri filtri, utilizzando un rollup di hello timestamp, ad esempio, data una chiave di partizione è un buon approccio.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-214">If your use case involves a small rate of writes accumulating over a long period of time, and need tooquery by ranges of timestamps and other filters, then using a rollup of hello timestamp, for example,  date as a partition key is a good approach.</span></span> <span data-ttu-id="6fdf2-215">In questo modo è tooquery su tutti i dati di hello per una data da una singola partizione.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-215">This allows you tooquery over all hello data for a date from a single partition.</span></span> 
* <span data-ttu-id="6fdf2-216">Se il carico di lavoro prevede molte scritture, scenario più comune, è opportuno usare una chiave di partizione non basata su timestamp in modo che Cosmos DB possa distribuire in modo uniforme le scritture in più partizioni.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-216">If your workload is written heavy, which is more common, you should use a partition key that’s not based on timestamp so that Cosmos DB can distribute writes evenly across various partitions.</span></span> <span data-ttu-id="6fdf2-217">In questo caso, un nome host, un ID processo, un ID attività o un'altra proprietà con una cardinalità elevata è una scelta efficace.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-217">Here a hostname, process ID, activity ID, or another property with high cardinality is a good choice.</span></span> 
* <span data-ttu-id="6fdf2-218">Un terzo approccio è un ibrido uno in cui si dispone di più contenitori, uno per ogni giorno/mese e chiave di partizione hello è una proprietà granulare come nome host.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-218">A third approach is a hybrid one where you have multiple containers, one for each day/month and hello partition key is a granular property like hostname.</span></span> <span data-ttu-id="6fdf2-219">Questa soluzione offre il vantaggio hello che è possibile impostare diversa velocità effettiva basata su finestra temporale hello, ad esempio, contenitore hello per hello mese corrente viene eseguito il provisioning con una velocità effettiva poiché serve le letture e scritture, mentre i mesi precedenti con ridurre la velocità effettiva dopo vengono usati solo letture.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-219">This has hello benefit that you can set different throughput based on hello time window, for example, hello container for hello current month is provisioned with higher throughput since it serves reads and writes, whereas previous months with lower throughput since they only serve reads.</span></span>

### <a name="partitioning-and-multi-tenancy"></a><span data-ttu-id="6fdf2-220">Partizionamento e multi-tenancy</span><span class="sxs-lookup"><span data-stu-id="6fdf2-220">Partitioning and multi-tenancy</span></span>
<span data-ttu-id="6fdf2-221">Se si implementa un'applicazione multi-tenant usando Cosmos DB, sono disponibili due modelli comuni: una chiave di partizione per ogni tenant e un contenitore per ogni tenant.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-221">If you are implementing a multi-tenant application using Cosmos DB, there are two popular patterns – one partition key per tenant, and one container per tenant.</span></span> <span data-ttu-id="6fdf2-222">Di seguito sono hello vantaggi e svantaggi per ognuno:</span><span class="sxs-lookup"><span data-stu-id="6fdf2-222">Here are hello pros and cons for each:</span></span>

* <span data-ttu-id="6fdf2-223">Una chiave di partizione per ogni tenant: in questo modello, i tenant vengono collocati all'interno di un singolo contenitore.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-223">One Partition Key per tenant: In this model, tenants are collocated within a single container.</span></span> <span data-ttu-id="6fdf2-224">Le query e gli inserimenti di elementi all'interno di un tenant possono essere tuttavia eseguiti a fronte di una partizione singola.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-224">But queries and inserts for items within a single tenant can be performed against a single partition.</span></span> <span data-ttu-id="6fdf2-225">È anche possibile implementare la logica transazionale su tutti gli elementi all'interno di un tenant.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-225">You can also implement transactional logic across all items within a tenant.</span></span> <span data-ttu-id="6fdf2-226">Poiché più tenant condividono un contenitore, è possibile risparmiare i costi di archiviazione e velocità effettiva raggruppando le risorse per i tenant all'interno di un singolo contenitore invece di eseguire il provisioning di capacità aggiuntiva per ogni tenant.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-226">Since multiple tenants share a container, you can save storage and throughput costs by pooling resources for tenants within a single container rather than provisioning extra headroom for each tenant.</span></span> <span data-ttu-id="6fdf2-227">restituzione di Hello è che non si dispone isolamento delle prestazioni per ogni tenant.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-227">hello drawback is that you do not have performance isolation per tenant.</span></span> <span data-ttu-id="6fdf2-228">Aumento delle prestazioni e velocità applica toohello intero contenitore vs destinata aumenta per tenant.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-228">Performance/throughput increases apply toohello entire container vs targeted increases for tenants.</span></span>
* <span data-ttu-id="6fdf2-229">Un contenitore per ogni tenant: ogni tenant ha un contenitore proprio.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-229">One Container per tenant: Each tenant has its own container.</span></span> <span data-ttu-id="6fdf2-230">In questo modello è possibile riservare le prestazioni per ogni tenant.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-230">In this model, you can reserve performance per tenant.</span></span> <span data-ttu-id="6fdf2-231">Con il nuovo schema tariffario per il provisioning di Cosmos DB, questo modello è più conveniente per applicazioni multi-tenant con un numero ridotto di tenant.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-231">With Cosmos DB's new provisioning pricing model, this model is more cost-effective for multi-tenant applications with a few tenants.</span></span>

<span data-ttu-id="6fdf2-232">È inoltre possibile utilizzare un approccio a livelli combinazione/collocates titolari di piccole dimensioni e viene eseguita la migrazione di dimensioni maggiori proprio contenitore tootheir a tenant.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-232">You can also use a combination/tiered approach that collocates small tenants and migrates larger tenants tootheir own container.</span></span>

## <a name="next-steps"></a><span data-ttu-id="6fdf2-233">Passaggi successivi</span><span class="sxs-lookup"><span data-stu-id="6fdf2-233">Next steps</span></span>
<span data-ttu-id="6fdf2-234">In questo articolo è stata illustrata una panoramica di concetti e procedure consigliate per il partizionamento con qualsiasi API di Azure Cosmos DB.</span><span class="sxs-lookup"><span data-stu-id="6fdf2-234">In this article, we provided an overview for an overview of concepts and best practices for partitioning with any Azure Cosmos DB API.</span></span> 

* <span data-ttu-id="6fdf2-235">Informazioni sulla [velocità effettiva con provisioning in Azure Cosmos DB](request-units.md)</span><span class="sxs-lookup"><span data-stu-id="6fdf2-235">Learn about [provisioned throughput in Azure Cosmos DB](request-units.md)</span></span>
* <span data-ttu-id="6fdf2-236">Informazioni sulla [distribuzione globale in Azure Cosmos DB](distribute-data-globally.md)</span><span class="sxs-lookup"><span data-stu-id="6fdf2-236">Learn about [global distribution in Azure Cosmos DB](distribute-data-globally.md)</span></span>



