---
title: Architettura del motore di ricerca full-text (Lucene) in Ricerca di Azure | Documentazione Microsoft
description: Spiegazione dell'elaborazione delle query di Lucene e dei concetti del recupero del documento per una ricerca full-text in relazione a Ricerca di Azure.
services: search
manager: jhubbard
author: yahnoosh
documentationcenter: 
ms.service: search
ms.devlang: NA
ms.workload: search
ms.topic: article
ms.tgt_pltfrm: na
ms.date: 04/06/2017
ms.author: jlembicz
ms.openlocfilehash: 9b7adf78271407963ed1d4b34a7760d707b5fc3a
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/11/2017
---
# <a name="how-full-text-search-works-in-azure-search"></a><span data-ttu-id="be2da-103">Funzionamento della ricerca full-text in Ricerca di Azure</span><span class="sxs-lookup"><span data-stu-id="be2da-103">How full text search works in Azure Search</span></span>

<span data-ttu-id="be2da-104">Questo articolo si rivolge agli sviluppatori che hanno bisogno di una conoscenza più approfondita circa il funzionamento della ricerca full-text di Lucene in Ricerca di Azure.</span><span class="sxs-lookup"><span data-stu-id="be2da-104">This article is for developers who need a deeper understanding of how Lucene full text search works in Azure Search.</span></span> <span data-ttu-id="be2da-105">Per le query di testo, Ricerca di Azure fornirà i risultati previsti nella maggior parte degli scenari, ma in alcuni casi è possibile ottenere un risultato che sembrerà in qualche modo "strano".</span><span class="sxs-lookup"><span data-stu-id="be2da-105">For text queries, Azure Search will seamlessly deliver expected results in most scenarios, but occasionally you might get a result that seems "off" somehow.</span></span> <span data-ttu-id="be2da-106">In questi casi, la presenza di uno sfondo nelle quattro fasi dell'esecuzione di query di Lucene (analisi delle query, analisi lessicale, abbinamento dei documenti, assegnazione dei punteggi) consente di identificare le modifiche specifiche per i parametri di query o per la configurazione di indice che garantirà il risultato desiderato.</span><span class="sxs-lookup"><span data-stu-id="be2da-106">In these situations, having a background in the four stages of Lucene query execution (query parsing, lexical analysis, document matching, scoring) can help you identify specific changes to query parameters or index configuration that will deliver the desired outcome.</span></span> 

> [!Note] 
> <span data-ttu-id="be2da-107">Ricerca di Azure usa Lucene per la ricerca full-text, ma l'integrazione con Lucene non è completa.</span><span class="sxs-lookup"><span data-stu-id="be2da-107">Azure Search uses Lucene for full text search, but Lucene integration is not exhaustive.</span></span> <span data-ttu-id="be2da-108">Si espone in modo selettivo e si estende la funzionalità di Lucene per abilitare gli scenari importanti per Ricerca di Azure.</span><span class="sxs-lookup"><span data-stu-id="be2da-108">We selectively expose and extend Lucene functionality to enable the scenarios important to Azure Search.</span></span> 

## <a name="architecture-overview-and-diagram"></a><span data-ttu-id="be2da-109">Panoramica e diagramma dell'architettura</span><span class="sxs-lookup"><span data-stu-id="be2da-109">Architecture overview and diagram</span></span>

<span data-ttu-id="be2da-110">L'elaborazione di una query di ricerca full-text inizia con l'analisi del testo della query per estrarre i termini di ricerca.</span><span class="sxs-lookup"><span data-stu-id="be2da-110">Processing a full text search query starts with parsing the query text to extract search terms.</span></span> <span data-ttu-id="be2da-111">Il motore di ricerca usa un indice per recuperare i documenti con termini corrispondenti.</span><span class="sxs-lookup"><span data-stu-id="be2da-111">The search engine uses an index to retrieve documents with matching terms.</span></span> <span data-ttu-id="be2da-112">I termini delle singole query vengono a volte suddivisi e ricostituiti in nuove forme per eseguire il cast di una rete più ampia su ciò che può essere considerato come corrispondenza potenziale.</span><span class="sxs-lookup"><span data-stu-id="be2da-112">Individual query terms are sometimes broken down and reconstituted into new forms to cast a broader net over what could be considered as a potential match.</span></span> <span data-ttu-id="be2da-113">Un set di risultati viene quindi ordinato sulla base di un punteggio di pertinenza assegnato a ogni singolo documento corrispondente.</span><span class="sxs-lookup"><span data-stu-id="be2da-113">A result set is then sorted by a relevance score assigned to each individual matching document.</span></span> <span data-ttu-id="be2da-114">Quelli nella parte superiore dell'elenco di pertinenza vengono restituiti all'applicazione chiamante.</span><span class="sxs-lookup"><span data-stu-id="be2da-114">Those at the top of the ranked list are returned to the calling application.</span></span>

<span data-ttu-id="be2da-115">L'esecuzione di query riproposte presenta quattro fasi:</span><span class="sxs-lookup"><span data-stu-id="be2da-115">Restated, query execution has four stages:</span></span> 

1. <span data-ttu-id="be2da-116">Analisi della query</span><span class="sxs-lookup"><span data-stu-id="be2da-116">Query parsing</span></span> 
2. <span data-ttu-id="be2da-117">Analisi lessicale</span><span class="sxs-lookup"><span data-stu-id="be2da-117">Lexical analysis</span></span> 
3. <span data-ttu-id="be2da-118">Recupero dei documenti</span><span class="sxs-lookup"><span data-stu-id="be2da-118">Document retrieval</span></span> 
4. <span data-ttu-id="be2da-119">Assegnazione dei punteggi</span><span class="sxs-lookup"><span data-stu-id="be2da-119">Scoring</span></span> 

<span data-ttu-id="be2da-120">Il diagramma seguente illustra i componenti usati per elaborare una richiesta di ricerca.</span><span class="sxs-lookup"><span data-stu-id="be2da-120">The diagram below illustrates the components used to process a search request.</span></span> 

 ![Diagramma dell'architettura della query di Lucene in Ricerca di Azure][1]


| <span data-ttu-id="be2da-122">Componenti chiave</span><span class="sxs-lookup"><span data-stu-id="be2da-122">Key components</span></span> | <span data-ttu-id="be2da-123">Descrizione funzionale</span><span class="sxs-lookup"><span data-stu-id="be2da-123">Functional description</span></span> | 
|----------------|------------------------|
|<span data-ttu-id="be2da-124">**Parser della query**</span><span class="sxs-lookup"><span data-stu-id="be2da-124">**Query parsers**</span></span> | <span data-ttu-id="be2da-125">Separare i termini della query dagli operatori della query e creare la struttura della query (un albero di query) da inviare al motore di ricerca.</span><span class="sxs-lookup"><span data-stu-id="be2da-125">Separate query terms from query operators and create the query structure (a query tree) to be sent to the search engine.</span></span> |
|<span data-ttu-id="be2da-126">**Analizzatori**</span><span class="sxs-lookup"><span data-stu-id="be2da-126">**Analyzers**</span></span> | <span data-ttu-id="be2da-127">Eseguire l'analisi lessicale sui termini della query.</span><span class="sxs-lookup"><span data-stu-id="be2da-127">Perform lexical analysis on query terms.</span></span> <span data-ttu-id="be2da-128">Questo processo può implicare la trasformazione, la rimozione o l'espansione dei termini della query.</span><span class="sxs-lookup"><span data-stu-id="be2da-128">This process can involve transforming, removing, or expanding of query terms.</span></span> |
|<span data-ttu-id="be2da-129">**Index**</span><span class="sxs-lookup"><span data-stu-id="be2da-129">**Index**</span></span> | <span data-ttu-id="be2da-130">Una struttura efficiente dei dati usata per archiviare e organizzare i termini ricercabili estratti da documenti indicizzati.</span><span class="sxs-lookup"><span data-stu-id="be2da-130">An efficient data structure used to store and organize searchable terms extracted from indexed documents.</span></span> |
|<span data-ttu-id="be2da-131">**Motore di ricerca**</span><span class="sxs-lookup"><span data-stu-id="be2da-131">**Search engine**</span></span> | <span data-ttu-id="be2da-132">Recupera e assegna i punteggi di documenti corrispondenti in base al contenuto dell'indice invertito.</span><span class="sxs-lookup"><span data-stu-id="be2da-132">Retrieves and scores matching documents based on the contents of the inverted index.</span></span> |

## <a name="anatomy-of-a-search-request"></a><span data-ttu-id="be2da-133">Anatomia di una richiesta di ricerca</span><span class="sxs-lookup"><span data-stu-id="be2da-133">Anatomy of a search request</span></span>

<span data-ttu-id="be2da-134">Una richiesta di ricerca è una specifica completa di ciò che deve essere restituito in un set di risultati.</span><span class="sxs-lookup"><span data-stu-id="be2da-134">A search request is a complete specification of what should be returned in a result set.</span></span> <span data-ttu-id="be2da-135">Nella forma più semplice, è una query vuota senza alcun tipo di criterio.</span><span class="sxs-lookup"><span data-stu-id="be2da-135">In simplest form, it is an empty query with no criteria of any kind.</span></span> <span data-ttu-id="be2da-136">Un esempio più realistico include parametri, termini di query diversi, forse con ambito in determinati campi, con eventualmente un'espressione filtro e regole di ordinamento.</span><span class="sxs-lookup"><span data-stu-id="be2da-136">A more realistic example includes parameters, several query terms, perhaps scoped to certain fields, with possibly a filter expression and ordering rules.</span></span>  

<span data-ttu-id="be2da-137">L'esempio seguente è una richiesta di ricerca che è possibile inviare a Ricerca di Azure tramite l'[API REST](https://docs.microsoft.com/rest/api/searchservice/search-documents).</span><span class="sxs-lookup"><span data-stu-id="be2da-137">The following example is a search request you might send to Azure Search using the [REST API](https://docs.microsoft.com/rest/api/searchservice/search-documents).</span></span>  

~~~~
POST /indexes/hotels/docs/search?api-version=2016-09-01 
{  
    "search": "Spacious, air-condition* +\"Ocean view\"",  
    "searchFields": "description, title",  
    "searchMode": "any",
    "filter": "price ge 60 and price lt 300",  
    "orderby": "geo.distance(location, geography'POINT(-159.476235 22.227659)')", 
    "queryType": "full" 
 } 
~~~~

<span data-ttu-id="be2da-138">Per questa richiesta, il motore di ricerca esegue le operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="be2da-138">For this request, the search engine does the following:</span></span>

1. <span data-ttu-id="be2da-139">Filtra i documenti in cui il prezzo è almeno $ 60 e meno di $ 300.</span><span class="sxs-lookup"><span data-stu-id="be2da-139">Filters out documents where the price is at least $60 and less than $300.</span></span>
2. <span data-ttu-id="be2da-140">Esegue la query.</span><span class="sxs-lookup"><span data-stu-id="be2da-140">Executes the query.</span></span> <span data-ttu-id="be2da-141">In questo esempio la query di ricerca è costituita da frasi e termini: `"Spacious, air-condition* +\"Ocean view\""` (gli utenti in genere non immettono segni di punteggiatura, ma includerli nell'esempio consente di spiegare come la gestiscono gli analizzatori).</span><span class="sxs-lookup"><span data-stu-id="be2da-141">In this example, the search query consists of phrases and terms: `"Spacious, air-condition* +\"Ocean view\""` (users typically don't enter punctuation, but including it in the example allows us to explain how analyzers handle it).</span></span> <span data-ttu-id="be2da-142">Per questa query, il motore di ricerca esegue la scansione della descrizione e dei campi del titolo specificati in `searchFields` per i documenti che contengono "Vista sull'Oceano" e anche il termine "spazioso" o i termini che iniziano con il prefisso "aria condizionata".</span><span class="sxs-lookup"><span data-stu-id="be2da-142">For this query, the search engine scans the description and title fields specified in `searchFields` for documents that contain "Ocean view", and additionally on the term "spacious", or on terms that start with the prefix "air-condition".</span></span> <span data-ttu-id="be2da-143">Il parametro `searchMode` viene usato per l'abbinamento con qualsiasi termine (impostazione predefinita) o con tutti i termini, per i casi in cui un termine non è esplicitamente richiesto (`+`).</span><span class="sxs-lookup"><span data-stu-id="be2da-143">The `searchMode` parameter is used to match on any term (default) or all of them, for cases where a term is not explicitly required (`+`).</span></span>
3. <span data-ttu-id="be2da-144">Ordina il set risultante degli hotel in prossimità di una posizione geografica specificata e quindi restituita all'applicazione chiamante.</span><span class="sxs-lookup"><span data-stu-id="be2da-144">Orders the resulting set of hotels by proximity to a given geography location, and then returned to the calling application.</span></span> 

<span data-ttu-id="be2da-145">La maggior parte di questo articolo riguarda l'elaborazione di *query di ricerca*: `"Spacious, air-condition* +\"Ocean view\""`.</span><span class="sxs-lookup"><span data-stu-id="be2da-145">The majority of this article is about processing of the *search query*: `"Spacious, air-condition* +\"Ocean view\""`.</span></span> <span data-ttu-id="be2da-146">Il filtro e l'ordinamento non appartengono all'ambito.</span><span class="sxs-lookup"><span data-stu-id="be2da-146">Filtering and ordering are out of scope.</span></span> <span data-ttu-id="be2da-147">Per altre informazioni, vedere la [Documentazione di riferimento dell'API di Ricerca](https://docs.microsoft.com/rest/api/searchservice/search-documents).</span><span class="sxs-lookup"><span data-stu-id="be2da-147">For more information, see the [Search API reference documentation](https://docs.microsoft.com/rest/api/searchservice/search-documents).</span></span>

<a name="stage1"></a>
## <a name="stage-1-query-parsing"></a><span data-ttu-id="be2da-148">Fase 1: Analisi della query</span><span class="sxs-lookup"><span data-stu-id="be2da-148">Stage 1: Query parsing</span></span> 

<span data-ttu-id="be2da-149">Come accennato, la stringa della query è la prima riga della richiesta:</span><span class="sxs-lookup"><span data-stu-id="be2da-149">As noted, the query string is the first line of the request:</span></span> 

~~~~
 "search": "Spacious, air-condition* +\"Ocean view\"", 
~~~~

<span data-ttu-id="be2da-150">Il parser della query separa gli operatori (ad esempio `*` e `+` nell'esempio) dalla ricerca di termini e annulla la costruzione della query di ricerca in *sottoquery* di un tipo supportato:</span><span class="sxs-lookup"><span data-stu-id="be2da-150">The query parser separates operators (such as `*` and `+` in the example) from search terms, and deconstructs the search query into *subqueries* of a supported type:</span></span> 

+ <span data-ttu-id="be2da-151">*query del termine* per i termini singoli (ad esempio spazioso)</span><span class="sxs-lookup"><span data-stu-id="be2da-151">*term query* for standalone terms (like spacious)</span></span>
+ <span data-ttu-id="be2da-152">*query della frase* per i termini tra virgolette (ad esempio vista oceano)</span><span class="sxs-lookup"><span data-stu-id="be2da-152">*phrase query* for quoted terms (like ocean view)</span></span>
+ <span data-ttu-id="be2da-153">*query del prefisso* per i termini seguiti da un operatore prefisso `*` (ad esempio, aria condizionata)</span><span class="sxs-lookup"><span data-stu-id="be2da-153">*prefix query* for terms followed by a prefix operator `*` (like air-condition)</span></span>

<span data-ttu-id="be2da-154">Per un elenco completo dei tipi di query supportati vedere [Sintassi di query Lucene](https://docs.microsoft.com/rest/api/searchservice/lucene-query-syntax-in-azure-search)</span><span class="sxs-lookup"><span data-stu-id="be2da-154">For a full list of supported query types see [Lucene query sytnax](https://docs.microsoft.com/rest/api/searchservice/lucene-query-syntax-in-azure-search)</span></span>

<span data-ttu-id="be2da-155">Gli operatori associati a una sottoquery determinano se la query "deve essere" o "dovrebbe essere" soddisfatta al fine di considerare un documento come corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="be2da-155">Operators associated with a subquery determine whether the query "must be" or "should be" satisfied in order for a document to be considered a match.</span></span> <span data-ttu-id="be2da-156">Ad esempio, `+"Ocean view"` è "deve" in virtù dell'operatore `+`.</span><span class="sxs-lookup"><span data-stu-id="be2da-156">For example, `+"Ocean view"` is "must" due to the `+` operator.</span></span> 

<span data-ttu-id="be2da-157">Il parser della query ristruttura le sottoquery in un *albero della query* (una struttura interna che rappresenta la query) e la trasmette al motore di ricerca.</span><span class="sxs-lookup"><span data-stu-id="be2da-157">The query parser restructures the subqueries into a *query tree* (an internal structure representing the query) it passes on to the search engine.</span></span> <span data-ttu-id="be2da-158">Nella prima fase di analisi della query, l'albero della query appare come segue.</span><span class="sxs-lookup"><span data-stu-id="be2da-158">In the first stage of query parsing, the query tree looks like this.</span></span>  

 ![Boolean query searchmode any][2]

### <a name="supported-parsers-simple-and-full-lucene"></a><span data-ttu-id="be2da-160">Parser supportati: Lucene semplice e completa</span><span class="sxs-lookup"><span data-stu-id="be2da-160">Supported parsers: Simple and Full Lucene</span></span> 

 <span data-ttu-id="be2da-161">La Ricerca di Azure espone due diversi linguaggi di query, `simple` (impostazione predefinita) e `full`.</span><span class="sxs-lookup"><span data-stu-id="be2da-161">Azure Search exposes two different query languages, `simple` (default) and `full`.</span></span> <span data-ttu-id="be2da-162">Impostando il parametro `queryType` con la richiesta di ricerca, si indica al parser della query quale linguaggio di query si sceglie in modo che sappia come interpretare gli operatori e la sintassi.</span><span class="sxs-lookup"><span data-stu-id="be2da-162">By setting the `queryType` parameter with your search request, you tell the query parser which query language you choose so that it knows how to interpret the operators and syntax.</span></span> <span data-ttu-id="be2da-163">Il [linguaggio semplice della query](https://docs.microsoft.com/rest/api/searchservice/simple-query-syntax-in-azure-search) è intuitivo e potente, spesso adatto ad interpretare l'input dell'utente così come si presenta, senza elaborazione dal lato client.</span><span class="sxs-lookup"><span data-stu-id="be2da-163">The [Simple query langauge](https://docs.microsoft.com/rest/api/searchservice/simple-query-syntax-in-azure-search) is intuitive and robust, often suitable to interpret user input as-is without client-side processing.</span></span> <span data-ttu-id="be2da-164">Supporta operatori di query familiari dai motori di ricerca Web.</span><span class="sxs-lookup"><span data-stu-id="be2da-164">It supports query operators familiar from web search engines.</span></span> <span data-ttu-id="be2da-165">Il [Linguaggio di query Lucene Full](https://docs.microsoft.com/rest/api/searchservice/lucene-query-syntax-in-azure-search), che si ottiene impostando `queryType=full`, estende il linguaggio di query semplice di impostazione predefinita aggiungendo il supporto per più operatori e tipi di query quali carattere jolly, fuzzy, regex e query con ambito campo.</span><span class="sxs-lookup"><span data-stu-id="be2da-165">The [Full Lucene query language](https://docs.microsoft.com/rest/api/searchservice/lucene-query-syntax-in-azure-search), which you get by setting `queryType=full`, extends the default Simple query language by adding support for more operators and query types like wildcard, fuzzy, regex, and field-scoped queries.</span></span> <span data-ttu-id="be2da-166">Ad esempio, un'espressione regolare inviata nella sintassi di query semplice verrebbe interpretata come una stringa di query e non come un'espressione.</span><span class="sxs-lookup"><span data-stu-id="be2da-166">For example, a regular expression sent in Simple query syntax would be interpreted as a query string and not an expression.</span></span> <span data-ttu-id="be2da-167">La richiesta di esempio in questo articolo usa il linguaggio di query Lucene Full.</span><span class="sxs-lookup"><span data-stu-id="be2da-167">The example request in this article uses the Full Lucene query language.</span></span>

### <a name="impact-of-searchmode-on-the-parser"></a><span data-ttu-id="be2da-168">Impatto di searchMode sul parser</span><span class="sxs-lookup"><span data-stu-id="be2da-168">Impact of searchMode on the parser</span></span> 

<span data-ttu-id="be2da-169">Un altro parametro di richiesta di ricerca che interessa l'analisi è il parametro `searchMode`.</span><span class="sxs-lookup"><span data-stu-id="be2da-169">Another search request parameter that affects parsing is the `searchMode` parameter.</span></span> <span data-ttu-id="be2da-170">Questo parametro controlla l'operatore predefinito per le query booleane: qualsiasi (predefinita) o tutte.</span><span class="sxs-lookup"><span data-stu-id="be2da-170">It controls the default operator for Boolean queries: any (default) or all.</span></span>  

<span data-ttu-id="be2da-171">Quando `searchMode=any`, valore predefinito, il delimitatore tra spazioso e aria condizionata è OR (`||`), rendendo il testo di query di esempio equivalente a:</span><span class="sxs-lookup"><span data-stu-id="be2da-171">When `searchMode=any`, which is the default, the space delimiter between spacious and air-condition is OR (`||`), making the sample query text equivalent to:</span></span> 

~~~~
Spacious,||air-condition*+"Ocean view" 
~~~~

<span data-ttu-id="be2da-172">Gli operatori espliciti, ad esempio `+` in `+"Ocean view"`, non sono ambigui nella costruzione di query booleana (il termine *deve* corrispondere).</span><span class="sxs-lookup"><span data-stu-id="be2da-172">Explicit operators, such as `+` in `+"Ocean view"`, are unambiguous in boolean query construction (the term *must* match).</span></span> <span data-ttu-id="be2da-173">Come interpretare i termini rimanenti è meno ovvio: spazioso e aria condizionata.</span><span class="sxs-lookup"><span data-stu-id="be2da-173">Less obvious is how to interpret the remaining terms: spacious and air-condition.</span></span> <span data-ttu-id="be2da-174">Il motore di ricerca dovrebbe trovare corrispondenze su vista sull'oceano *and* spazioso *and* aria condizionata?</span><span class="sxs-lookup"><span data-stu-id="be2da-174">Should the search engine find matches on ocean view *and* spacious *and* air-condition?</span></span> <span data-ttu-id="be2da-175">O dovrebbe trovare vista sull'oceano più *uno* dei termini rimanenti?</span><span class="sxs-lookup"><span data-stu-id="be2da-175">Or should it find ocean view plus *either one* of the remaining terms?</span></span> 

<span data-ttu-id="be2da-176">Per impostazione predefinita (`searchMode=any`), il motore di ricerca assume l'interpretazione più ampia.</span><span class="sxs-lookup"><span data-stu-id="be2da-176">By default (`searchMode=any`), the search engine assumes the broader interpretation.</span></span> <span data-ttu-id="be2da-177">Uno dei campi *dovrebbe* essere associato, riflettendo la semantica di "or".</span><span class="sxs-lookup"><span data-stu-id="be2da-177">Either field *should* be matched, reflecting "or" semantics.</span></span> <span data-ttu-id="be2da-178">L'albero della query iniziale illustrato in precedenza, con due operazioni "should", mostra il valore predefinito.</span><span class="sxs-lookup"><span data-stu-id="be2da-178">The initial query tree illustrated previously, with the two "should" operations, shows the default.</span></span>  

<span data-ttu-id="be2da-179">Si supponga che abbiamo ora impostato `searchMode=all`.</span><span class="sxs-lookup"><span data-stu-id="be2da-179">Suppose that we now set `searchMode=all`.</span></span> <span data-ttu-id="be2da-180">In questo caso, lo spazio viene interpretato come un'operazione "and".</span><span class="sxs-lookup"><span data-stu-id="be2da-180">In this case, the space is interpreted as an "and" operation.</span></span> <span data-ttu-id="be2da-181">Ciascuno dei termini rimanenti deve essere presente nel documento per essere considerato come corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="be2da-181">Each of the remaining terms must both be present in the document to qualify as a match.</span></span> <span data-ttu-id="be2da-182">La query di esempio risultante verrebbe interpretata nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="be2da-182">The resulting sample query would be interpreted as follows:</span></span> 

~~~~
+Spacious,+air-condition*+"Ocean view"  
~~~~

<span data-ttu-id="be2da-183">Un albero di query modificato per questa query sarà come segue, se un documento corrispondente è l'intersezione di tutte e tre le sottoquery:</span><span class="sxs-lookup"><span data-stu-id="be2da-183">A modified query tree for this query would be as follows, where a matching document is the intersection of all three subqueries:</span></span> 

 ![Boolean query searchmode all][3]

> [!Note] 
> <span data-ttu-id="be2da-185">La scelta `searchMode=any` rispetto a `searchMode=all` è una scelta migliore a cui si arriva eseguendo le query rappresentative.</span><span class="sxs-lookup"><span data-stu-id="be2da-185">Choosing `searchMode=any` over `searchMode=all` is a decision best arrived at by running representative queries.</span></span> <span data-ttu-id="be2da-186">Gli utenti che molto probabilmente includono operatori (comune quando si eseguono ricerche nell'archivio dei documenti) potrebbero trovare risultati più intuitivi se `searchMode=all` informa i costrutti della query booleana.</span><span class="sxs-lookup"><span data-stu-id="be2da-186">Users who are likely to include operators (common when searching document stores) might find results more intuitive if `searchMode=all` informs boolean query constructs.</span></span> <span data-ttu-id="be2da-187">Per altre informazioni sull'interazione tra `searchMode` e gli operatori, vedere [Simple query syntax](https://docs.microsoft.com/rest/api/searchservice/simple-query-syntax-in-azure-search) (Sintassi di query semplice).</span><span class="sxs-lookup"><span data-stu-id="be2da-187">For more about the interplay between `searchMode` and operators, see [Simple query syntax](https://docs.microsoft.com/rest/api/searchservice/simple-query-syntax-in-azure-search).</span></span>

<a name="stage2"></a>
## <a name="stage-2-lexical-analysis"></a><span data-ttu-id="be2da-188">Fase 2: Analisi lessicale</span><span class="sxs-lookup"><span data-stu-id="be2da-188">Stage 2: Lexical analysis</span></span> 

<span data-ttu-id="be2da-189">Gli analizzatori lessicali elaborano le *query del termine* e le *query della frase* dopo aver strutturato l'albero della query.</span><span class="sxs-lookup"><span data-stu-id="be2da-189">Lexical analyzers process *term queries* and *phrase queries* after the query tree is structured.</span></span> <span data-ttu-id="be2da-190">Un analizzatore accetta gli input di testo assegnati dal parser, elabora il testo e quindi invia nuovamente in formato token i termini da incorporare nell'albero della query.</span><span class="sxs-lookup"><span data-stu-id="be2da-190">An analyzer accepts the text inputs given to it by the parser, processes the text, and then sends back tokenized terms to be incorporated into the query tree.</span></span> 

<span data-ttu-id="be2da-191">La forma più comune di analisi lessicale è l'*analisi linguistica* che trasforma i termini della query in base a regole specifiche per un determinato linguaggio:</span><span class="sxs-lookup"><span data-stu-id="be2da-191">The most common form of lexical analysis is *linguistic analysis* which transforms query terms based on rules specific to a given language:</span></span> 

* <span data-ttu-id="be2da-192">Riduzione di un termine della query nella forma radice di una parola</span><span class="sxs-lookup"><span data-stu-id="be2da-192">Reducing a query term to the root form of a word</span></span> 
* <span data-ttu-id="be2da-193">Rimozione di parole non essenziali (parole non significative, ad esempio "the" o "and" in inglese)</span><span class="sxs-lookup"><span data-stu-id="be2da-193">Removing non-essential words (stopwords, such as "the" or "and" in English)</span></span> 
* <span data-ttu-id="be2da-194">Suddivisione di una parola composta nelle parti che la compongono</span><span class="sxs-lookup"><span data-stu-id="be2da-194">Breaking a composite word into component parts</span></span> 
* <span data-ttu-id="be2da-195">Trasformazione in lettere minuscole di una parola in lettere maiuscole</span><span class="sxs-lookup"><span data-stu-id="be2da-195">Lower casing an upper case word</span></span> 

<span data-ttu-id="be2da-196">Tutte queste operazioni tendono a cancellare le differenze tra l'input del testo fornito dall'utente e i termini archiviati nell'indice.</span><span class="sxs-lookup"><span data-stu-id="be2da-196">All of these operations tend to erase differences between the text input provided by the user and the terms stored in the index.</span></span> <span data-ttu-id="be2da-197">Tali operazioni vanno oltre l'elaborazione del testo e richiedono una conoscenza approfondita del linguaggio.</span><span class="sxs-lookup"><span data-stu-id="be2da-197">Such operations go beyond text processing and require in-depth knowledge of the language itself.</span></span> <span data-ttu-id="be2da-198">Per aggiungere questo livello di consapevolezza linguistica, Ricerca di Azure supporta un lungo elenco di [analizzatori della lingua](https://docs.microsoft.com/rest/api/searchservice/language-support) di Microsoft e Lucene.</span><span class="sxs-lookup"><span data-stu-id="be2da-198">To add this layer of linguistic awareness, Azure Search supports a long list of [language analyzers](https://docs.microsoft.com/rest/api/searchservice/language-support) from both Lucene and Microsoft.</span></span>

> [!Note]
> <span data-ttu-id="be2da-199">I requisiti per l'analisi possono variare da minimi a elaborati a seconda dello scenario.</span><span class="sxs-lookup"><span data-stu-id="be2da-199">Analysis requirements can range from minimal to elaborate depending on your scenario.</span></span> <span data-ttu-id="be2da-200">È possibile controllare la complessità dell'analisi lessicale quando si seleziona uno degli analizzatori predefiniti o creando il proprio [analizzatore personalizzato](https://docs.microsoft.com/rest/api/searchservice/Custom-analyzers-in-Azure-Search).</span><span class="sxs-lookup"><span data-stu-id="be2da-200">You can control complexity of lexical analysis by the selecting one of the predefined analyzers or by creating your own [custom analyzer](https://docs.microsoft.com/rest/api/searchservice/Custom-analyzers-in-Azure-Search).</span></span> <span data-ttu-id="be2da-201">Gli analizzatori sono limitati a campi ricercabili e vengono specificati come parte di una definizione di campo.</span><span class="sxs-lookup"><span data-stu-id="be2da-201">Analyzers are scoped to searchable fields and are specified as part of a field definition.</span></span> <span data-ttu-id="be2da-202">Ciò consente di variare l'analisi lessicale in base al campo.</span><span class="sxs-lookup"><span data-stu-id="be2da-202">This allows you to vary lexical analysis on a per-field basis.</span></span> <span data-ttu-id="be2da-203">Se non è specificato, viene usato l'analizzatore Lucene *standard*.</span><span class="sxs-lookup"><span data-stu-id="be2da-203">Unspecified, the *standard* Lucene analyzer is used.</span></span>

<span data-ttu-id="be2da-204">Nel nostro esempio, prima dell'analisi, l'albero della query iniziale contiene il termine "Spazioso,", con una "S" maiuscola e una virgola, che il parser della query interpreta come parte del termine della query (la virgola non viene considerata come operatore di linguaggio della query).</span><span class="sxs-lookup"><span data-stu-id="be2da-204">In our example, prior to analysis, the initial query tree has the term "Spacious," with an uppercase "S" and a comma that the query parser interprets as a part of the query term (a comma is not considered a query language operator).</span></span>  

<span data-ttu-id="be2da-205">Quando l'analizzatore predefinito elabora il termine, renderà con lettere minuscole "vista sull'oceano" e "spazioso" e rimuoverà il carattere di virgola.</span><span class="sxs-lookup"><span data-stu-id="be2da-205">When the default analyzer processes the term, it will lowercase "ocean view" and "spacious", and remove the comma character.</span></span> <span data-ttu-id="be2da-206">L'albero della query modificato avrà l'aspetto seguente:</span><span class="sxs-lookup"><span data-stu-id="be2da-206">The modified query tree will look as follows:</span></span> 

 ![Query booleana con termini analizzati][4]

### <a name="testing-analyzer-behaviors"></a><span data-ttu-id="be2da-208">Comportamenti dell'analizzatore del test</span><span class="sxs-lookup"><span data-stu-id="be2da-208">Testing analyzer behaviors</span></span> 

<span data-ttu-id="be2da-209">Il comportamento di un analizzatore può essere testato usando l'[API Analyze](https://docs.microsoft.com/rest/api/searchservice/test-analyzer).</span><span class="sxs-lookup"><span data-stu-id="be2da-209">The behavior of an analyzer can be tested using the [Analyze API](https://docs.microsoft.com/rest/api/searchservice/test-analyzer).</span></span> <span data-ttu-id="be2da-210">Fornire il testo da analizzare per vedere quali termini specificati saranno generati dall'analizzatore.</span><span class="sxs-lookup"><span data-stu-id="be2da-210">Provide the text you want to analyze to see what terms given analyzer will generate.</span></span> <span data-ttu-id="be2da-211">Ad esempio, per visualizzare il modo in cui l'analizzatore standard elabora il testo "aria condizionata", è possibile eseguire la richiesta seguente:</span><span class="sxs-lookup"><span data-stu-id="be2da-211">For example, to see how the standard analyzer would process the text "air-condition", you can issue the following request:</span></span>

~~~~
{ 
    "text": "air-condition",
    "analyzer": "standard"
}
~~~~

<span data-ttu-id="be2da-212">L'analizzatore standard suddivide il testo di input nei due token seguenti, annotandoli con attributi quali offset iniziale e finale (usati per l'evidenziazione dei risultati), nonché con la loro posizione (usata per la corrispondenza di una frase):</span><span class="sxs-lookup"><span data-stu-id="be2da-212">The standard analyzer breaks the input text into the following two tokens, annotating them with attributes like start and end offsets (used for hit highlighting) as well as their position (used for phrase matching):</span></span>

~~~~
{  
  "tokens": [
    {
      "token": "air",
      "startOffset": 0,
      "endOffset": 3,
      "position": 0
    },
    {
      "token": "condition",
      "startOffset": 4,
      "endOffset": 13,
      "position": 1
    }
  ]
}
~~~~

### <a name="exceptions-to-lexical-analysis"></a><span data-ttu-id="be2da-213">Eccezioni all'analisi lessicale</span><span class="sxs-lookup"><span data-stu-id="be2da-213">Exceptions to lexical analysis</span></span> 

<span data-ttu-id="be2da-214">L'analisi lessicale si applica solo ai tipi di query che richiedono termini completi, una query di termine o una query di frase.</span><span class="sxs-lookup"><span data-stu-id="be2da-214">Lexical analysis applies only to query types that require complete terms – either a term query or a phrase query.</span></span> <span data-ttu-id="be2da-215">Non si applica ai tipi di query con termini incompleti: query di prefisso, query con caratteri jolly, query regex o query fuzzy.</span><span class="sxs-lookup"><span data-stu-id="be2da-215">It doesn’t apply to query types with incomplete terms – prefix query, wildcard query, regex query – or to a fuzzy query.</span></span> <span data-ttu-id="be2da-216">Questi tipi di query, tra cui la query di prefisso con il termine *aria condizionata\** nel nostro esempio, vengono aggiunti direttamente all'albero della query, ignorando la fase di analisi.</span><span class="sxs-lookup"><span data-stu-id="be2da-216">Those query types, including the prefix query with term *air-condition\** in our example, are added directly to the query tree, bypassing the analysis stage.</span></span> <span data-ttu-id="be2da-217">L'unica trasformazione eseguita per i termini della query di queste tipologie è la conversione in lettere minuscole.</span><span class="sxs-lookup"><span data-stu-id="be2da-217">The only transformation performed on query terms of those types is lowercasing.</span></span>

<a name="stage3"></a>
## <a name="stage-3-document-retrieval"></a><span data-ttu-id="be2da-218">Fase 3: Recupero dei documenti</span><span class="sxs-lookup"><span data-stu-id="be2da-218">Stage 3: Document retrieval</span></span> 

<span data-ttu-id="be2da-219">Il recupero dei documenti fa riferimento alla ricerca di documenti con termini corrispondenti all'indice.</span><span class="sxs-lookup"><span data-stu-id="be2da-219">Document retrieval refers to finding documents with matching terms in the index.</span></span> <span data-ttu-id="be2da-220">Questa fase viene spiegata meglio attraverso un esempio.</span><span class="sxs-lookup"><span data-stu-id="be2da-220">This stage is understood best through an example.</span></span> <span data-ttu-id="be2da-221">Iniziamo con un indice degli hotel che presenta il seguente schema semplice:</span><span class="sxs-lookup"><span data-stu-id="be2da-221">Let's start with a hotels index having the following simple schema:</span></span> 

~~~~
{   
    "name": "hotels",     
    "fields": [     
        { "name": "id", "type": "Edm.String", "key": true, "searchable": false },     
        { "name": "title", "type": "Edm.String", "searchable": true },     
        { "name": "description", "type": "Edm.String", "searchable": true }
    ] 
} 
~~~~

<span data-ttu-id="be2da-222">Si supponga anche che l'indice contenga i seguenti quattro documenti:</span><span class="sxs-lookup"><span data-stu-id="be2da-222">Further assume that this index contains the following four documents:</span></span> 

~~~~
{ 
    "value": [
        {         
            "id": "1",         
            "title": "Hotel Atman",         
            "description": "Spacious rooms, ocean view, walking distance to the beach."   
        },       
        {         
            "id": "2",         
            "title": "Beach Resort",        
            "description": "Located on the north shore of the island of Kauaʻi. Ocean view."     
        },       
        {         
            "id": "3",         
            "title": "Playa Hotel",         
            "description": "Comfortable, air-conditioned rooms with ocean view."
        },       
        {         
            "id": "4",         
            "title": "Ocean Retreat",         
            "description": "Quiet and secluded"
        }    
    ]
}
~~~~

<span data-ttu-id="be2da-223">**Come vengono indicizzati termini**</span><span class="sxs-lookup"><span data-stu-id="be2da-223">**How terms are indexed**</span></span>

<span data-ttu-id="be2da-224">Comprendere il recupero è utile per conoscere alcune nozioni di base sull'indicizzazione.</span><span class="sxs-lookup"><span data-stu-id="be2da-224">To understand retrieval, it helps to know a few basics about indexing.</span></span> <span data-ttu-id="be2da-225">L'unità di archiviazione è un indice invertito, uno per ogni campo ricercabile.</span><span class="sxs-lookup"><span data-stu-id="be2da-225">The unit of storage is an inverted index, one for each searchable field.</span></span> <span data-ttu-id="be2da-226">In un indice invertito è presente un elenco ordinato di tutti i termini derivanti da tutti i documenti.</span><span class="sxs-lookup"><span data-stu-id="be2da-226">Within an inverted index is a sorted list of all terms from all documents.</span></span> <span data-ttu-id="be2da-227">Ogni termine esegue il mapping nell'elenco di termini in cui si verifica, come si evince nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="be2da-227">Each term maps to the list of documents in which it occurs, as evident in the example below.</span></span>

<span data-ttu-id="be2da-228">Per produrre i termini in un indice inverso, il motore di ricerca esegue l'analisi lessicale sul contenuto dei documenti, analogamente a quanto accade durante l'elaborazione delle query.</span><span class="sxs-lookup"><span data-stu-id="be2da-228">To produce the terms in an inverted index, the search engine performs lexical analysis over the content of documents, similar to what happens during query processing.</span></span> <span data-ttu-id="be2da-229">Gli input del testo vengono passati a un analizzatore, in lettere minuscole, prive di punteggiatura e così via, a seconda della configurazione dell'analizzatore.</span><span class="sxs-lookup"><span data-stu-id="be2da-229">Text inputs are passed to an analyzer, lower-cased, stripped of punctuation, and so forth, depending on the analyzer configuration.</span></span> <span data-ttu-id="be2da-230">È comune, ma non obbligatorio, usare gli stessi analizzatori per la ricerca e le operazioni di indicizzazione in modo che i termini di query assomiglino di più ai termini contenuti nell'indice.</span><span class="sxs-lookup"><span data-stu-id="be2da-230">It's common, but not required, to use the same analyzers for search and indexing operations so that query terms look more like terms inside the index.</span></span>

> [!Note]
> <span data-ttu-id="be2da-231">Ricerca di Azure consente di specificare diversi analizzatori per l'indicizzazione e la ricerca tramite parametri di campo aggiuntivi `indexAnalyzer` e `searchAnalyzer`.</span><span class="sxs-lookup"><span data-stu-id="be2da-231">Azure Search lets you specify different analyzers for indexing and search via additional `indexAnalyzer` and `searchAnalyzer` field parameters.</span></span> <span data-ttu-id="be2da-232">Se non è specificato, l'analizzatore impostato con la proprietà `analyzer` viene usato per l'indicizzazione e la ricerca.</span><span class="sxs-lookup"><span data-stu-id="be2da-232">If unspecified, the analyzer set with the `analyzer` property is used for both indexing and searching.</span></span>  

<span data-ttu-id="be2da-233">**Indice invertito per i documenti di esempio**</span><span class="sxs-lookup"><span data-stu-id="be2da-233">**Inverted index for example documents**</span></span>

<span data-ttu-id="be2da-234">Ritornando all'esempio precedente, per il campo **titolo**, l'indice invertito è simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="be2da-234">Returning to our example, for the **title** field, the inverted index looks like this:</span></span>

| <span data-ttu-id="be2da-235">Termine</span><span class="sxs-lookup"><span data-stu-id="be2da-235">Term</span></span> | <span data-ttu-id="be2da-236">Elenco di documenti</span><span class="sxs-lookup"><span data-stu-id="be2da-236">Document list</span></span> |
|------|---------------|
| <span data-ttu-id="be2da-237">atman</span><span class="sxs-lookup"><span data-stu-id="be2da-237">atman</span></span> | <span data-ttu-id="be2da-238">1</span><span class="sxs-lookup"><span data-stu-id="be2da-238">1</span></span> |
| <span data-ttu-id="be2da-239">spiaggia</span><span class="sxs-lookup"><span data-stu-id="be2da-239">beach</span></span> | <span data-ttu-id="be2da-240">2</span><span class="sxs-lookup"><span data-stu-id="be2da-240">2</span></span> |
| <span data-ttu-id="be2da-241">hotel</span><span class="sxs-lookup"><span data-stu-id="be2da-241">hotel</span></span> | <span data-ttu-id="be2da-242">1, 3</span><span class="sxs-lookup"><span data-stu-id="be2da-242">1, 3</span></span> |
| <span data-ttu-id="be2da-243">oceano</span><span class="sxs-lookup"><span data-stu-id="be2da-243">ocean</span></span> | <span data-ttu-id="be2da-244">4</span><span class="sxs-lookup"><span data-stu-id="be2da-244">4</span></span>  |
| <span data-ttu-id="be2da-245">playa</span><span class="sxs-lookup"><span data-stu-id="be2da-245">playa</span></span> | <span data-ttu-id="be2da-246">3</span><span class="sxs-lookup"><span data-stu-id="be2da-246">3</span></span> |
| <span data-ttu-id="be2da-247">resort</span><span class="sxs-lookup"><span data-stu-id="be2da-247">resort</span></span> | <span data-ttu-id="be2da-248">3</span><span class="sxs-lookup"><span data-stu-id="be2da-248">3</span></span> |
| <span data-ttu-id="be2da-249">rifugio</span><span class="sxs-lookup"><span data-stu-id="be2da-249">retreat</span></span> | <span data-ttu-id="be2da-250">4</span><span class="sxs-lookup"><span data-stu-id="be2da-250">4</span></span> |

<span data-ttu-id="be2da-251">Nel campo del titolo, solo *hotel* viene visualizzato in due documenti: 1, 3.</span><span class="sxs-lookup"><span data-stu-id="be2da-251">In the title field, only *hotel* shows up in two documents: 1, 3.</span></span>

<span data-ttu-id="be2da-252">Per il campo **descrizione**, l'indice è il seguente:</span><span class="sxs-lookup"><span data-stu-id="be2da-252">For the **description** field, the index is as follows:</span></span>

| <span data-ttu-id="be2da-253">Termine</span><span class="sxs-lookup"><span data-stu-id="be2da-253">Term</span></span> | <span data-ttu-id="be2da-254">Elenco di documenti</span><span class="sxs-lookup"><span data-stu-id="be2da-254">Document list</span></span> |
|------|---------------|
| <span data-ttu-id="be2da-255">aria</span><span class="sxs-lookup"><span data-stu-id="be2da-255">air</span></span> | <span data-ttu-id="be2da-256">3</span><span class="sxs-lookup"><span data-stu-id="be2da-256">3</span></span>
| <span data-ttu-id="be2da-257">e</span><span class="sxs-lookup"><span data-stu-id="be2da-257">and</span></span> | <span data-ttu-id="be2da-258">4</span><span class="sxs-lookup"><span data-stu-id="be2da-258">4</span></span>
| <span data-ttu-id="be2da-259">spiaggia</span><span class="sxs-lookup"><span data-stu-id="be2da-259">beach</span></span> | <span data-ttu-id="be2da-260">1</span><span class="sxs-lookup"><span data-stu-id="be2da-260">1</span></span>
| <span data-ttu-id="be2da-261">condizionata</span><span class="sxs-lookup"><span data-stu-id="be2da-261">conditioned</span></span> | <span data-ttu-id="be2da-262">3</span><span class="sxs-lookup"><span data-stu-id="be2da-262">3</span></span>
| <span data-ttu-id="be2da-263">comodo</span><span class="sxs-lookup"><span data-stu-id="be2da-263">comfortable</span></span> | <span data-ttu-id="be2da-264">3</span><span class="sxs-lookup"><span data-stu-id="be2da-264">3</span></span>
| <span data-ttu-id="be2da-265">distance</span><span class="sxs-lookup"><span data-stu-id="be2da-265">distance</span></span> | <span data-ttu-id="be2da-266">1</span><span class="sxs-lookup"><span data-stu-id="be2da-266">1</span></span>
| <span data-ttu-id="be2da-267">isola</span><span class="sxs-lookup"><span data-stu-id="be2da-267">island</span></span> | <span data-ttu-id="be2da-268">2</span><span class="sxs-lookup"><span data-stu-id="be2da-268">2</span></span>
| <span data-ttu-id="be2da-269">kauaʻi</span><span class="sxs-lookup"><span data-stu-id="be2da-269">kauaʻi</span></span> | <span data-ttu-id="be2da-270">2</span><span class="sxs-lookup"><span data-stu-id="be2da-270">2</span></span>
| <span data-ttu-id="be2da-271">posizionato</span><span class="sxs-lookup"><span data-stu-id="be2da-271">located</span></span> | <span data-ttu-id="be2da-272">2</span><span class="sxs-lookup"><span data-stu-id="be2da-272">2</span></span>
| <span data-ttu-id="be2da-273">nord</span><span class="sxs-lookup"><span data-stu-id="be2da-273">north</span></span> | <span data-ttu-id="be2da-274">2</span><span class="sxs-lookup"><span data-stu-id="be2da-274">2</span></span>
| <span data-ttu-id="be2da-275">oceano</span><span class="sxs-lookup"><span data-stu-id="be2da-275">ocean</span></span> | <span data-ttu-id="be2da-276">1, 2, 3</span><span class="sxs-lookup"><span data-stu-id="be2da-276">1, 2, 3</span></span>
| <span data-ttu-id="be2da-277">di</span><span class="sxs-lookup"><span data-stu-id="be2da-277">of</span></span> | <span data-ttu-id="be2da-278">2</span><span class="sxs-lookup"><span data-stu-id="be2da-278">2</span></span>
| <span data-ttu-id="be2da-279">in</span><span class="sxs-lookup"><span data-stu-id="be2da-279">on</span></span> |<span data-ttu-id="be2da-280">2</span><span class="sxs-lookup"><span data-stu-id="be2da-280">2</span></span>
| <span data-ttu-id="be2da-281">tranquillo</span><span class="sxs-lookup"><span data-stu-id="be2da-281">quiet</span></span> | <span data-ttu-id="be2da-282">4</span><span class="sxs-lookup"><span data-stu-id="be2da-282">4</span></span>
| <span data-ttu-id="be2da-283">camere</span><span class="sxs-lookup"><span data-stu-id="be2da-283">rooms</span></span>  | <span data-ttu-id="be2da-284">1, 3</span><span class="sxs-lookup"><span data-stu-id="be2da-284">1, 3</span></span>
| <span data-ttu-id="be2da-285">appartato</span><span class="sxs-lookup"><span data-stu-id="be2da-285">secluded</span></span> | <span data-ttu-id="be2da-286">4</span><span class="sxs-lookup"><span data-stu-id="be2da-286">4</span></span>
| <span data-ttu-id="be2da-287">costa</span><span class="sxs-lookup"><span data-stu-id="be2da-287">shore</span></span> | <span data-ttu-id="be2da-288">2</span><span class="sxs-lookup"><span data-stu-id="be2da-288">2</span></span>
| <span data-ttu-id="be2da-289">spazioso</span><span class="sxs-lookup"><span data-stu-id="be2da-289">spacious</span></span> | <span data-ttu-id="be2da-290">1</span><span class="sxs-lookup"><span data-stu-id="be2da-290">1</span></span>
| <span data-ttu-id="be2da-291">il</span><span class="sxs-lookup"><span data-stu-id="be2da-291">the</span></span> | <span data-ttu-id="be2da-292">1, 2</span><span class="sxs-lookup"><span data-stu-id="be2da-292">1, 2</span></span>
| <span data-ttu-id="be2da-293">to</span><span class="sxs-lookup"><span data-stu-id="be2da-293">to</span></span> | <span data-ttu-id="be2da-294">1</span><span class="sxs-lookup"><span data-stu-id="be2da-294">1</span></span>
| <span data-ttu-id="be2da-295">view</span><span class="sxs-lookup"><span data-stu-id="be2da-295">view</span></span> | <span data-ttu-id="be2da-296">1, 2, 3</span><span class="sxs-lookup"><span data-stu-id="be2da-296">1, 2, 3</span></span>
| <span data-ttu-id="be2da-297">passeggiata</span><span class="sxs-lookup"><span data-stu-id="be2da-297">walking</span></span> | <span data-ttu-id="be2da-298">1</span><span class="sxs-lookup"><span data-stu-id="be2da-298">1</span></span>
| <span data-ttu-id="be2da-299">con</span><span class="sxs-lookup"><span data-stu-id="be2da-299">with</span></span> | <span data-ttu-id="be2da-300">3</span><span class="sxs-lookup"><span data-stu-id="be2da-300">3</span></span>


<span data-ttu-id="be2da-301">**Corrispondenza dei termini di query con i termini indicizzati**</span><span class="sxs-lookup"><span data-stu-id="be2da-301">**Matching query terms against indexed terms**</span></span>

<span data-ttu-id="be2da-302">Dati gli indici invertiti precedenti, tornare alla query di esempio e vedere come si trovano i documenti corrispondenti per la query di esempio.</span><span class="sxs-lookup"><span data-stu-id="be2da-302">Given the inverted indices above, let’s return to the sample query and see how matching documents are found for our example query.</span></span> <span data-ttu-id="be2da-303">Tenere presente che l'albero della query finale ha il seguente aspetto:</span><span class="sxs-lookup"><span data-stu-id="be2da-303">Recall that the final query tree looks like this:</span></span> 

 ![Query booleana con termini analizzati][4]

<span data-ttu-id="be2da-305">Durante l'esecuzione delle query, le singole query vengono eseguite sulla base dei campi ricercabili in modo indipendente.</span><span class="sxs-lookup"><span data-stu-id="be2da-305">During query execution, individual queries are executed against the searchable fields independently.</span></span> 

+ <span data-ttu-id="be2da-306">Il TermQuery "spazioso" corrisponde al documento 1 (Hotel Atman).</span><span class="sxs-lookup"><span data-stu-id="be2da-306">The TermQuery, "spacious", matches document 1 (Hotel Atman).</span></span> 

+ <span data-ttu-id="be2da-307">Il PrefixQuery "aria-condizionata*" non corrisponde a nessun documento.</span><span class="sxs-lookup"><span data-stu-id="be2da-307">The PrefixQuery, "air-condition*", doesn't match any documents.</span></span> 

  <span data-ttu-id="be2da-308">Si tratta di un comportamento che a volte confonde gli sviluppatori.</span><span class="sxs-lookup"><span data-stu-id="be2da-308">This is a behavior that sometimes confuses developers.</span></span> <span data-ttu-id="be2da-309">Sebbene il termine aria condizionata esista nel documento, è suddiviso in due termini dall'analizzatore predefinito.</span><span class="sxs-lookup"><span data-stu-id="be2da-309">Although the term air-conditioned exists in the document, it is split into two terms by the default analyzer.</span></span> <span data-ttu-id="be2da-310">È importante ricordare che le query di prefisso, che contengono termini parziali, non vengono analizzate.</span><span class="sxs-lookup"><span data-stu-id="be2da-310">Recall that prefix queries, which contain partial terms, are not analyzed.</span></span> <span data-ttu-id="be2da-311">Di conseguenza termini con prefisso "aria condizionata" vengono cercati nell'indice invertito e non trovati.</span><span class="sxs-lookup"><span data-stu-id="be2da-311">Therefore terms with prefix "air-condition" are looked up in the inverted index and not found.</span></span>

+ <span data-ttu-id="be2da-312">La PhraseQuery "vista sull'oceano" cerca i termini "oceano" e "vista" e controlla la prossimità dei termini nel documento originale.</span><span class="sxs-lookup"><span data-stu-id="be2da-312">The PhraseQuery, "ocean view", looks up the terms "ocean" and "view" and checks the proximity of terms in the original document.</span></span> <span data-ttu-id="be2da-313">I documenti 1, 2 e 3 abbinano questa query nel campo della descrizione.</span><span class="sxs-lookup"><span data-stu-id="be2da-313">Documents 1, 2 and 3 match this query in the description field.</span></span> <span data-ttu-id="be2da-314">Si noti che il documento 4 contiene il termine oceano, ma non è considerata una corrispondenza poiché stiamo cercando la frase "vista sull'oceano" e non le singole parole.</span><span class="sxs-lookup"><span data-stu-id="be2da-314">Notice document 4 has the term ocean in the title but isn’t considered a match, as we're looking for the "ocean view" phrase rather than individual words.</span></span> 

> [!Note]
> <span data-ttu-id="be2da-315">Viene eseguita una query di ricerca in modo indipendente in tutti i campi disponibili per la ricerca nell'indice di Ricerca di Azure a meno che non si superino i campi impostati con il parametro `searchFields`, come illustrato nella richiesta di ricerca di esempio.</span><span class="sxs-lookup"><span data-stu-id="be2da-315">A search query is executed independently against all searchable fields in the Azure Search index unless you limit the fields set with the `searchFields` parameter, as illustrated in the example search request.</span></span> <span data-ttu-id="be2da-316">Vengono restituiti i documenti corrispondenti in uno dei campi selezionati.</span><span class="sxs-lookup"><span data-stu-id="be2da-316">Documents that match in any of the selected fields are returned.</span></span> 

<span data-ttu-id="be2da-317">Nel complesso, per la query in questione, i documenti corrispondenti sono 1, 2, 3.</span><span class="sxs-lookup"><span data-stu-id="be2da-317">On the whole, for the query in question, the documents that match are 1, 2, 3.</span></span> 

## <a name="stage-4-scoring"></a><span data-ttu-id="be2da-318">Fase 4: Assegnazione dei punteggi</span><span class="sxs-lookup"><span data-stu-id="be2da-318">Stage 4: Scoring</span></span>  

<span data-ttu-id="be2da-319">Ad ogni documento in un set di risultati di ricerca viene assegnato un punteggio di pertinenza.</span><span class="sxs-lookup"><span data-stu-id="be2da-319">Every document in a search result set is assigned a relevance score.</span></span> <span data-ttu-id="be2da-320">La funzione del punteggio di pertinenza è di posizionare in alto in classifica quei documenti che meglio rispondono a una domanda utente espressa dalla query di ricerca.</span><span class="sxs-lookup"><span data-stu-id="be2da-320">The function of the relevance score is to rank higher those documents that best answer a user question as expressed by the search query.</span></span> <span data-ttu-id="be2da-321">Il punteggio viene calcolato in base alle proprietà statistiche dei termini che corrispondono.</span><span class="sxs-lookup"><span data-stu-id="be2da-321">The score is computed based on statistical properties of terms that matched.</span></span> <span data-ttu-id="be2da-322">Alla base della formula del punteggio è presente la ponderazione [TF/IDF (frequenza del termine - frequenza inversa del documento)](https://en.wikipedia.org/wiki/Tf%E2%80%93idf).</span><span class="sxs-lookup"><span data-stu-id="be2da-322">At the core of the scoring formula is [TF/IDF (term frequency-inverse document frequency)](https://en.wikipedia.org/wiki/Tf%E2%80%93idf).</span></span> <span data-ttu-id="be2da-323">Nelle query che contengono termini rari e comuni, il TF/IDF promuove i risultati contenenti il termine raro.</span><span class="sxs-lookup"><span data-stu-id="be2da-323">In queries containing rare and common terms, TF/IDF promotes results containing the rare term.</span></span> <span data-ttu-id="be2da-324">Ad esempio, in un indice ipotetico con tutti gli articoli di Wikipedia, dai documenti che corrispondono alla query *il presidente*, i documenti che corrispondono a *presidente* sono considerati più pertinenti dei documenti corrispondenti con *il*.</span><span class="sxs-lookup"><span data-stu-id="be2da-324">For example, in a hypothetical index with all Wikipedia articles, from documents that matched the query *the president*, documents matching on *president* are considered more relevant than documents matching on *the*.</span></span>


### <a name="scoring-example"></a><span data-ttu-id="be2da-325">Esempio di assegnazione dei punteggi</span><span class="sxs-lookup"><span data-stu-id="be2da-325">Scoring example</span></span>

<span data-ttu-id="be2da-326">Richiamare i tre documenti che corrispondono alla query di esempio:</span><span class="sxs-lookup"><span data-stu-id="be2da-326">Recall the three documents that matched our example query:</span></span>
~~~~
search=Spacious, air-condition* +"Ocean view"  
~~~~
~~~~
{  
  "value": [
    {
      "@search.score": 0.25610128,
      "id": "1",
      "title": "Hotel Atman",
      "description": "Spacious rooms, ocean view, walking distance to the beach."
    },
    {
      "@search.score": 0.08951007,
      "id": "3",
      "title": "Playa Hotel",
      "description": "Comfortable, air-conditioned rooms with ocean view."
    },
    {
      "@search.score": 0.05967338,
      "id": "2",
      "title": "Ocean Resort",
      "description": "Located on a cliff on the north shore of the island of Kauai. Ocean view."
    }
  ]
}
~~~~

<span data-ttu-id="be2da-327">Il documento 1 corrisponde alla query migliore poiché sia il termine *spazioso* sia la frase richiesta *vista sull'oceano* si verificano nel campo descrizione.</span><span class="sxs-lookup"><span data-stu-id="be2da-327">Document 1 matched the query best because both the term *spacious* and the required phrase *ocean view* occur in the description field.</span></span> <span data-ttu-id="be2da-328">I due documenti successivi corrispondono solo per la frase *vista sull'oceano*.</span><span class="sxs-lookup"><span data-stu-id="be2da-328">The next two documents match only the phrase *ocean view*.</span></span> <span data-ttu-id="be2da-329">È sorprendente constatare che il punteggio di pertinenza per i documenti 2 e 3 è diverso, anche se essi corrispondono alla query nello stesso modo.</span><span class="sxs-lookup"><span data-stu-id="be2da-329">It might be surprising that the relevance score for document 2 and 3 is different even though they matched the query in the same way.</span></span> <span data-ttu-id="be2da-330">Ciò avviene perché la formula di assegnazione del punteggio include più componenti rispetto a TF/IDF.</span><span class="sxs-lookup"><span data-stu-id="be2da-330">It's because the scoring formula has more components than just TF/IDF.</span></span> <span data-ttu-id="be2da-331">In questo caso al documento 3 è stato assegnato un punteggio leggermente maggiore perché la sua descrizione è più breve.</span><span class="sxs-lookup"><span data-stu-id="be2da-331">In this case, document 3 was assigned a slightly higher score because its description is shorter.</span></span> <span data-ttu-id="be2da-332">Informazioni sulla [formula Lucene per il punteggio pratico](https://lucene.apache.org/core/4_0_0/core/org/apache/lucene/search/similarities/TFIDFSimilarity.html) per comprendere in che modo la lunghezza del campo e altri fattori possono influenzare il punteggio di pertinenza.</span><span class="sxs-lookup"><span data-stu-id="be2da-332">Learn about [Lucene's Practical Scoring Formula](https://lucene.apache.org/core/4_0_0/core/org/apache/lucene/search/similarities/TFIDFSimilarity.html) to understand how field length and other factors can influence the relevance score.</span></span>

<span data-ttu-id="be2da-333">Alcuni tipi di query (carattere jolly, prefisso, regex) contribuiscono sempre con un punteggio costante al punteggio complessivo del documento.</span><span class="sxs-lookup"><span data-stu-id="be2da-333">Some query types (wildcard, prefix, regex) always contribute a constant score to the overall document score.</span></span> <span data-ttu-id="be2da-334">Questo permette alle corrispondenze trovate tramite l'espansione della query di essere incluse nei risultati, ma senza modificare la classifica.</span><span class="sxs-lookup"><span data-stu-id="be2da-334">This allows matches found through query expansion to be included in the results, but without affecting the ranking.</span></span> 

<span data-ttu-id="be2da-335">Un esempio illustra il motivo per cui questo risulta importante.</span><span class="sxs-lookup"><span data-stu-id="be2da-335">An example illustrates why this matters.</span></span> <span data-ttu-id="be2da-336">Le ricerche con caratteri jolly, tra cui le ricerche con prefisso, sono ambigue per definizione poiché l'input è una stringa parziale con potenziali corrispondenze in un numero molto elevato di termini diversi (si consideri un input di "tour*", con corrispondenze trovate in "tour", "tourettes" e "tourmaline").</span><span class="sxs-lookup"><span data-stu-id="be2da-336">Wildcard searches, including prefix searches, are ambiguous by definition because the input is a partial string with potential matches on a very large number of disparate terms (consider an input of "tour*", with matches found on “tours”, “tourettes”, and “tourmaline”).</span></span> <span data-ttu-id="be2da-337">Data la natura di questi risultati, non è possibile dedurre ragionevolmente quali termini risultino più utili rispetto ad altri.</span><span class="sxs-lookup"><span data-stu-id="be2da-337">Given the nature of these results, there is no way to reasonably infer which terms are more valuable than others.</span></span> <span data-ttu-id="be2da-338">Per questo motivo, verranno ignorate le frequenze di termini durante l'assegnazione dei punteggi dei risultati nelle query di tipo con caratteri jolly, prefisso e regex.</span><span class="sxs-lookup"><span data-stu-id="be2da-338">For this reason, we ignore term frequencies when scoring results in queries of types wildcard, prefix and regex.</span></span> <span data-ttu-id="be2da-339">In una richiesta di ricerca a più parti che comprende termini parziali e completi, i risultati dall'input parziale sono incorporati con un punteggio costante per evitare la distorsione verso risultati potenzialmente imprevisti.</span><span class="sxs-lookup"><span data-stu-id="be2da-339">In a multi-part search request that includes partial and complete terms, results from the partial input are incorporated with a constant score to avoid bias towards potentially unexpected matches.</span></span>

### <a name="score-tuning"></a><span data-ttu-id="be2da-340">Ottimizzazione del punteggio</span><span class="sxs-lookup"><span data-stu-id="be2da-340">Score tuning</span></span>

<span data-ttu-id="be2da-341">Esistono due modi per ottimizzare i punteggi di pertinenza in Ricerca di Azure:</span><span class="sxs-lookup"><span data-stu-id="be2da-341">There are two ways to tune relevance scores in Azure Search:</span></span>

1. <span data-ttu-id="be2da-342">I **profili di punteggio** promuovono i documenti nell'elenco di pertinenza dei risultati in base a un set di regole.</span><span class="sxs-lookup"><span data-stu-id="be2da-342">**Scoring profiles** promote documents in the ranked list of results based on a set of rules.</span></span> <span data-ttu-id="be2da-343">Nel nostro esempio è possibile considerare i documenti che corrispondono al campo del titolo più rilevanti rispetto ai documenti corrispondenti al campo della descrizione.</span><span class="sxs-lookup"><span data-stu-id="be2da-343">In our example, we could consider documents that matched in the title field more relevant than documents that matched in the description field.</span></span> <span data-ttu-id="be2da-344">In aggiunta, se l'indice dispone di un campo prezzo per ogni albergo, è possibile promuovere i documenti con prezzo inferiore.</span><span class="sxs-lookup"><span data-stu-id="be2da-344">Additionally, if our index had a price field for each hotel, we could promote documents with lower price.</span></span> <span data-ttu-id="be2da-345">Informazioni su come [ aggiungere profili di punteggio a un indice di ricerca](https://docs.microsoft.com/rest/api/searchservice/add-scoring-profiles-to-a-search-index).</span><span class="sxs-lookup"><span data-stu-id="be2da-345">Learn more how to [add Scoring Profiles to a search index.](https://docs.microsoft.com/rest/api/searchservice/add-scoring-profiles-to-a-search-index)</span></span>
2. <span data-ttu-id="be2da-346">**Aumento priorità dei termini** (disponibile solo nella sintassi di query Lucene Full) offre un aumento della priorità dell'operatore `^` che può essere applicato a qualsiasi parte dell'albero della query.</span><span class="sxs-lookup"><span data-stu-id="be2da-346">**Term boosting** (available only in the Full Lucene query syntax) provides a boosting operator `^` that can be applied to any part of the query tree.</span></span> <span data-ttu-id="be2da-347">Nel nostro esempio invece di cercare il prefisso *aria condizionata*\*, è possibile cercare il termine esatto *aria condizionata* o il prefisso, ma i documenti che corrispondono al termine esatto si trovano in una posizione più alta applicando l'aumento della priorità alla query del termine: *aria condizionata^2||aria condizionata**.</span><span class="sxs-lookup"><span data-stu-id="be2da-347">In our example, instead of searching on the prefix *air-condition*\*, one could search for either the exact term *air-condition* or the prefix, but documents that match on the exact term are ranked higher by applying boost to the term query: *air-condition^2||air-condition**.</span></span> <span data-ttu-id="be2da-348">Altre informazioni sull'[aumento della priorità dei termini](https://docs.microsoft.com/rest/api/searchservice/lucene-query-syntax-in-azure-search#bkmk_termboost).</span><span class="sxs-lookup"><span data-stu-id="be2da-348">Learn more about [term boosting](https://docs.microsoft.com/rest/api/searchservice/lucene-query-syntax-in-azure-search#bkmk_termboost).</span></span>


### <a name="scoring-in-a-distributed-index"></a><span data-ttu-id="be2da-349">Assegnazione dei punteggi in un indice distribuito</span><span class="sxs-lookup"><span data-stu-id="be2da-349">Scoring in a distributed index</span></span>

<span data-ttu-id="be2da-350">Tutti gli indici in Ricerca di Azure sono automaticamente suddivisi in più partizioni, consentendo di distribuire rapidamente l'indice tra più nodi durante la scalabilità verticale o orizzontale del servizio.</span><span class="sxs-lookup"><span data-stu-id="be2da-350">All indexes in Azure Search are automatically split into multiple shards, allowing us to quickly distribute the index among multiple nodes during service scale up or scale down.</span></span> <span data-ttu-id="be2da-351">Quando viene eseguita una richiesta di ricerca, viene generata in ogni partizione in modo indipendente.</span><span class="sxs-lookup"><span data-stu-id="be2da-351">When a search request is issued, it’s issued against each shard independently.</span></span> <span data-ttu-id="be2da-352">I risultati di ogni partizione vengono uniti e ordinati in base al punteggio (se non è definito nessun altro ordine).</span><span class="sxs-lookup"><span data-stu-id="be2da-352">The results from each shard are then merged and ordered by score (if no other ordering is defined).</span></span> <span data-ttu-id="be2da-353">È importante sapere che la funzione di assegnazione dei punteggi pesa la frequenza del termine della query rispetto alla frequenza inversa del documento in tutti i documenti all'interno della partizione, non in tutte le partizioni.</span><span class="sxs-lookup"><span data-stu-id="be2da-353">It is important to know that the scoring function weights query term frequency against its inverse document frequency in all documents within the shard, not across all shards!</span></span>

<span data-ttu-id="be2da-354">Ciò significa che un punteggio di pertinenza *potrebbe* essere diverso per documenti identici se si trovano in partizioni diverse.</span><span class="sxs-lookup"><span data-stu-id="be2da-354">This means a relevance score *could* be different for identical documents if they reside on different shards.</span></span> <span data-ttu-id="be2da-355">Fortunatamente, queste differenze tendono a scomparire man mano che aumenta il numero di documenti nell'indice a causa anche di altre distribuzioni del termine.</span><span class="sxs-lookup"><span data-stu-id="be2da-355">Fortunately, such differences tend to disappear as the number of documents in the index grows due to more even term distribution.</span></span> <span data-ttu-id="be2da-356">Non è possibile presumere in quale partizione verrà inserito un documento specifico.</span><span class="sxs-lookup"><span data-stu-id="be2da-356">It’s not possible to assume on which shard any given document will be placed.</span></span> <span data-ttu-id="be2da-357">Tuttavia, dando per assunto che una chiave del documento non cambia, verrà sempre assegnata alla stessa partizione.</span><span class="sxs-lookup"><span data-stu-id="be2da-357">However, assuming a document key doesn't change, it will always be assigned to the same shard.</span></span>

<span data-ttu-id="be2da-358">In genere, il punteggio del documento non è l'attributo migliore per l'ordinamento dei documenti se la stabilità dell'ordine è importante.</span><span class="sxs-lookup"><span data-stu-id="be2da-358">In general, document score is not the best attribute for ordering documents if order stability is important.</span></span> <span data-ttu-id="be2da-359">Ad esempio, dati due documenti con un punteggio identico, non vi sono garanzie circa quale sarà visualizzato per primo in esecuzioni successive della stessa query.</span><span class="sxs-lookup"><span data-stu-id="be2da-359">For example, given two document with an identical score, there is no guarantee which one appears first in subsequent runs of the same query.</span></span> <span data-ttu-id="be2da-360">Il punteggio del documento deve solo dare un'idea generale della pertinenza del documento relativo ad altri documenti nel set di risultati.</span><span class="sxs-lookup"><span data-stu-id="be2da-360">Document score should only give a general sense of document relevance relative to other documents in the results set.</span></span>

## <a name="conclusion"></a><span data-ttu-id="be2da-361">Conclusione</span><span class="sxs-lookup"><span data-stu-id="be2da-361">Conclusion</span></span>

<span data-ttu-id="be2da-362">Il successo dei motori di ricerca Internet ha generato aspettative per la ricerca full-text su dati privati.</span><span class="sxs-lookup"><span data-stu-id="be2da-362">The success of internet search engines has raised expectations for full text search over private data.</span></span> <span data-ttu-id="be2da-363">Per quasi tutti i tipi di esperienza di ricerca, è ora previsto che il motore comprenda il nostro obiettivo, anche quando i termini sono errati o incompleti.</span><span class="sxs-lookup"><span data-stu-id="be2da-363">For almost any kind of search experience, we now expect the engine to understand our intent, even when terms are misspelled or incomplete.</span></span> <span data-ttu-id="be2da-364">Si possono anche prevedere delle corrispondenze basate su termini quasi equivalenti o sinonimi che non abbiamo mai specificato.</span><span class="sxs-lookup"><span data-stu-id="be2da-364">We might even expect matches based on near equivalent terms or synonyms that we never actually specified.</span></span>

<span data-ttu-id="be2da-365">Dal punto di vista tecnico, la ricerca full-text è estremamente complessa, richiede un'analisi linguistica sofisticata e un approccio sistematico all'elaborazione in modo tale da filtrare, espandere e trasformare i termini della query per fornire un risultato pertinente.</span><span class="sxs-lookup"><span data-stu-id="be2da-365">From a technical standpoint, full text search is highly complex, requiring sophisticated linguistic analysis and a systematic approach to processing in ways that distill, expand, and transform query terms to deliver a relevant result.</span></span> <span data-ttu-id="be2da-366">Date le complessità intrinseche, esistono molti fattori che possono influire sul risultato di una query.</span><span class="sxs-lookup"><span data-stu-id="be2da-366">Given the inherent complexities, there are a lot of factors that can affect the outcome of a query.</span></span> <span data-ttu-id="be2da-367">Per questo motivo, investire del tempo per comprendere i meccanismi della ricerca full-text offre dei vantaggi tangibili quando si prova a lavorare con risultati imprevisti.</span><span class="sxs-lookup"><span data-stu-id="be2da-367">For this reason, investing the time to understand the mechanics of full text search offers tangible benefits when trying to work through unexpected results.</span></span>  

<span data-ttu-id="be2da-368">In questo articolo è stata illustrata la ricerca full-text nel contesto di Ricerca di Azure.</span><span class="sxs-lookup"><span data-stu-id="be2da-368">This article explored full text search in the context of Azure Search.</span></span> <span data-ttu-id="be2da-369">Ci auguriamo che questo argomento offra un background sufficiente per riconoscere possibili cause e soluzioni per affrontare i problemi comuni della query.</span><span class="sxs-lookup"><span data-stu-id="be2da-369">We hope it gives you sufficient background to recognize potential causes and resolutions for addressing common query problems.</span></span> 

## <a name="next-steps"></a><span data-ttu-id="be2da-370">Passaggi successivi</span><span class="sxs-lookup"><span data-stu-id="be2da-370">Next steps</span></span>

+ <span data-ttu-id="be2da-371">Compilare l'indice di esempio, provare diverse query ed esaminare i risultati.</span><span class="sxs-lookup"><span data-stu-id="be2da-371">Build the sample index, try out different queries and review results.</span></span> <span data-ttu-id="be2da-372">Per le istruzioni, vedere [Eseguire query sull'indice](search-get-started-portal.md#query-index).</span><span class="sxs-lookup"><span data-stu-id="be2da-372">For instructions, see [Build and query an index in the portal](search-get-started-portal.md#query-index).</span></span>

+ <span data-ttu-id="be2da-373">Provare la sintassi di query aggiuntiva dalla sezione di esempio [Search Documents](https://docs.microsoft.com/rest/api/searchservice/search-documents#examples) (Ricerca di documenti) o da [Sintassi di query semplice](https://docs.microsoft.com/rest/api/searchservice/simple-query-syntax-in-azure-search) in Esplora ricerche nel portale.</span><span class="sxs-lookup"><span data-stu-id="be2da-373">Try additional query syntax from the [Search Documents](https://docs.microsoft.com/rest/api/searchservice/search-documents#examples) example section or from [Simple query syntax](https://docs.microsoft.com/rest/api/searchservice/simple-query-syntax-in-azure-search) in Search explorer in the portal.</span></span>

+ <span data-ttu-id="be2da-374">Rivedere i [profili di punteggio](https://docs.microsoft.com/rest/api/searchservice/add-scoring-profiles-to-a-search-index) se si desidera ottimizzare la classificazione nell'applicazione di ricerca.</span><span class="sxs-lookup"><span data-stu-id="be2da-374">Review [scoring profiles](https://docs.microsoft.com/rest/api/searchservice/add-scoring-profiles-to-a-search-index) if you want to tune ranking in your search application.</span></span>

+ <span data-ttu-id="be2da-375">Informazioni su come applicare [analizzatori lessicali specifici della lingua](https://docs.microsoft.com/rest/api/searchservice/language-support).</span><span class="sxs-lookup"><span data-stu-id="be2da-375">Learn how to apply [language-specific lexical analyzers](https://docs.microsoft.com/rest/api/searchservice/language-support).</span></span>

+ <span data-ttu-id="be2da-376">[Configurare gli analizzatori personalizzati](https://docs.microsoft.com/rest/api/searchservice/custom-analyzers-in-azure-search) per un'elaborazione minima o specializzati per settori specifici.</span><span class="sxs-lookup"><span data-stu-id="be2da-376">[Configure custom analyzers](https://docs.microsoft.com/rest/api/searchservice/custom-analyzers-in-azure-search) for either minimal processing or specialized processing on specific fields.</span></span>

+ <span data-ttu-id="be2da-377">[Fare un confronto affiancato degli analizzatori standard e in lingua inglese](http://alice.unearth.ai/) in questo sito Web demo.</span><span class="sxs-lookup"><span data-stu-id="be2da-377">[Compare standard and English analyzers](http://alice.unearth.ai/)) side-by-side on this demo web site.</span></span> 

## <a name="see-also"></a><span data-ttu-id="be2da-378">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="be2da-378">See also</span></span>

<span data-ttu-id="be2da-379">[Search Documents REST API](https://docs.microsoft.com/rest/api/searchservice/search-documents) (API REST di Ricerca di documenti)</span><span class="sxs-lookup"><span data-stu-id="be2da-379">[Search Documents REST API](https://docs.microsoft.com/rest/api/searchservice/search-documents)</span></span>

[<span data-ttu-id="be2da-380">Sintassi di query semplice</span><span class="sxs-lookup"><span data-stu-id="be2da-380">Simple query syntax</span></span>](https://docs.microsoft.com/rest/api/searchservice/simple-query-syntax-in-azure-search)

<span data-ttu-id="be2da-381">[Full Lucene query syntax](https://docs.microsoft.com/rest/api/searchservice/lucene-query-syntax-in-azure-search) (Sintassi di query completa Lucene)</span><span class="sxs-lookup"><span data-stu-id="be2da-381">[Full Lucene query syntax](https://docs.microsoft.com/rest/api/searchservice/lucene-query-syntax-in-azure-search)</span></span>

[<span data-ttu-id="be2da-382">Gestire i risultati della ricerca</span><span class="sxs-lookup"><span data-stu-id="be2da-382">Handle search results</span></span>](https://docs.microsoft.com/azure/search/search-pagination-page-layout)

<!--Image references-->
[1]: ./media/search-lucene-query-architecture/architecture-diagram2.png
[2]: ./media/search-lucene-query-architecture/azSearch-queryparsing-should2.png
[3]: ./media/search-lucene-query-architecture/azSearch-queryparsing-must2.png
[4]: ./media/search-lucene-query-architecture/azSearch-queryparsing-spacious2.png
