---
title: Panoramica delle code di messaggi, argomenti e sottoscrizioni del bus di servizio di Azure | Documentazione Microsoft
description: "Panoramica delle entità di messaggistica del bus di servizio."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: a306ced4-74e9-47c6-990a-d9c47efa31d5
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 06/28/2017
ms.author: sethm
ms.openlocfilehash: 00f9f38fbae028486270053dedb4df580a3f1a44
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/18/2017
---
# <a name="service-bus-queues-topics-and-subscriptions"></a><span data-ttu-id="84f68-103">Code, argomenti e sottoscrizioni del bus di servizio</span><span class="sxs-lookup"><span data-stu-id="84f68-103">Service Bus queues, topics, and subscriptions</span></span>

<span data-ttu-id="84f68-104">Il bus di servizio di Microsoft Azure supporta un set di tecnologie middleware orientate ai messaggi e basate sul cloud, incluso l'accodamento dei messaggi affidabile e la messaggistica di pubblicazione e sottoscrizione permanente.</span><span class="sxs-lookup"><span data-stu-id="84f68-104">Microsoft Azure Service Bus supports a set of cloud-based, message-oriented middleware technologies including reliable message queuing and durable publish/subscribe messaging.</span></span> <span data-ttu-id="84f68-105">Queste funzionalità di messaggistica "negoziata" possono essere considerate come funzionalità di messaggistica asincrone o disaccoppiate che supportano scenari di pubblicazione e sottoscrizione, disaccoppiamento temporale e bilanciamento del carico tramite l'infrastruttura di messaggistica del bus di servizio.</span><span class="sxs-lookup"><span data-stu-id="84f68-105">These "brokered" messaging capabilities can be thought of as decoupled messaging features that support publish-subscribe, temporal decoupling, and load balancing scenarios using the Service Bus messaging fabric.</span></span> <span data-ttu-id="84f68-106">La comunicazione disaccoppiata presenta molti vantaggi, ad esempio client e server possono connettersi quando necessario ed eseguire le relative operazioni in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="84f68-106">Decoupled communication has many advantages; for example, clients and servers can connect as needed and perform their operations in an asynchronous fashion.</span></span>

<span data-ttu-id="84f68-107">Le entità di messaggistica che costituiscono le funzionalità di messaggistica di base nel bus di servizio sono code, argomenti e sottoscrizioni e regole/azioni.</span><span class="sxs-lookup"><span data-stu-id="84f68-107">The messaging entities that form the core of the messaging capabilities in Service Bus are queues, topics and subscriptions, and rules/actions.</span></span>

## <a name="queues"></a><span data-ttu-id="84f68-108">Code</span><span class="sxs-lookup"><span data-stu-id="84f68-108">Queues</span></span>

<span data-ttu-id="84f68-109">Le code consentono un recapito dei messaggi di tipo *FIFO (First In, First Out)* a uno o più consumer concorrenti.</span><span class="sxs-lookup"><span data-stu-id="84f68-109">Queues offer *First In, First Out* (FIFO) message delivery to one or more competing consumers.</span></span> <span data-ttu-id="84f68-110">In altri termini, i messaggi in genere vengono ricevuti ed elaborati dai ricevitori secondo l'ordine temporale in cui sono stati aggiunti alla coda e ogni messaggio viene ricevuto ed elaborato da un solo consumer.</span><span class="sxs-lookup"><span data-stu-id="84f68-110">That is, messages are typically expected to be received and processed by the receivers in the order in which they were added to the queue, and each message is received and processed by only one message consumer.</span></span> <span data-ttu-id="84f68-111">Il vantaggio principale derivante dall'uso delle code è quello di ottenere un "disaccoppiamento temporale" dei componenti applicativi,</span><span class="sxs-lookup"><span data-stu-id="84f68-111">A key benefit of using queues is to achieve "temporal decoupling" of application components.</span></span> <span data-ttu-id="84f68-112">ovvero non è necessario che i producer e i consumer inviino e ricevano i messaggi contemporaneamente perché i messaggi restano archiviati nella coda.</span><span class="sxs-lookup"><span data-stu-id="84f68-112">In other words, the producers (senders) and consumers (receivers) do not have to be sending and receiving messages at the same time, because messages are stored durably in the queue.</span></span> <span data-ttu-id="84f68-113">Il producer inoltre non deve attendere la risposta del consumer per continuare a elaborare e inviare messaggi.</span><span class="sxs-lookup"><span data-stu-id="84f68-113">Furthermore, the producer does not have to wait for a reply from the consumer in order to continue to process and send messages.</span></span>

<span data-ttu-id="84f68-114">Un vantaggio correlato è quello del "livellamento del carico", che permette ai producer e ai consumer di inviare e ricevere i messaggi con frequenze diverse.</span><span class="sxs-lookup"><span data-stu-id="84f68-114">A related benefit is "load leveling," which enables producers and consumers to send and receive messages at different rates.</span></span> <span data-ttu-id="84f68-115">In molte applicazioni, il carico del sistema varia nel tempo, tuttavia, il tempo di elaborazione necessario per ogni unità è in genere costante.</span><span class="sxs-lookup"><span data-stu-id="84f68-115">In many applications, the system load varies over time; however, the processing time required for each unit of work is typically constant.</span></span> <span data-ttu-id="84f68-116">L'interposizione di una coda tra producer e consumer di messaggi implica che è necessario solo eseguire il provisioning dell'applicazione consumer per gestire un carico medio invece di un carico massimo.</span><span class="sxs-lookup"><span data-stu-id="84f68-116">Intermediating message producers and consumers with a queue means that the consuming application only has to be provisioned to be able to handle average load instead of peak load.</span></span> <span data-ttu-id="84f68-117">In base alla variazione del carico in ingresso, si verificherà un incremento o una riduzione della profondità della coda,</span><span class="sxs-lookup"><span data-stu-id="84f68-117">The depth of the queue grows and contracts as the incoming load varies.</span></span> <span data-ttu-id="84f68-118">con un risparmio diretto in termini economici rispetto alle risorse infrastrutturali richieste per gestire il carico dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="84f68-118">This directly saves money with regard to the amount of infrastructure required to service the application load.</span></span> <span data-ttu-id="84f68-119">Con l'aumento del carico, è possibile aggiungere altri processi di lavoro per la lettura della coda.</span><span class="sxs-lookup"><span data-stu-id="84f68-119">As the load increases, more worker processes can be added to read from the queue.</span></span> <span data-ttu-id="84f68-120">Ciascun messaggio viene elaborato da un solo processo di lavoro.</span><span class="sxs-lookup"><span data-stu-id="84f68-120">Each message is processed by only one of the worker processes.</span></span> <span data-ttu-id="84f68-121">Inoltre, il bilanciamento del carico di tipo pull permette un uso ottimale dei computer di lavoro anche quando questi presentano una potenza di elaborazione diversa.Ogni computer effettuerà infatti il pull dei messaggi in base alla propria velocità massima.</span><span class="sxs-lookup"><span data-stu-id="84f68-121">Furthermore, this pull-based load balancing allows for optimum use of the worker computers even if the worker computers differ with regard to processing power, as they will pull messages at their own maximum rate.</span></span> <span data-ttu-id="84f68-122">Questo modello viene spesso definito modello del "consumer concorrente".</span><span class="sxs-lookup"><span data-stu-id="84f68-122">This pattern is often termed the "competing consumer" pattern.</span></span>

<span data-ttu-id="84f68-123">L'uso di code da interporre tra producer e consumer di messaggi fornisce un accoppiamento intrinseco di tipo regime di controllo libero tra i componenti.</span><span class="sxs-lookup"><span data-stu-id="84f68-123">Using queues to intermediate between message producers and consumers provides an inherent loose coupling between the components.</span></span> <span data-ttu-id="84f68-124">Poiché producer e consumer sono indipendenti gli uni dagli altri, è possibile aggiornare un consumer senza causare alcun effetto sul producer.</span><span class="sxs-lookup"><span data-stu-id="84f68-124">Because producers and consumers are not aware of each other, a consumer can be upgraded without having any effect on the producer.</span></span>

<span data-ttu-id="84f68-125">La creazione di una coda è un processo che prevede più passaggi. </span><span class="sxs-lookup"><span data-stu-id="84f68-125">Creating a queue is a multi-step process.</span></span> <span data-ttu-id="84f68-126">Le operazioni di gestione per le entità di messaggistica del bus di servizio (code e argomenti) vengono eseguite tramite la classe [Microsoft.ServiceBus.NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) che viene costruita specificando l'indirizzo di base dello spazio dei nomi e le credenziali utente del bus di servizio.</span><span class="sxs-lookup"><span data-stu-id="84f68-126">You perform management operations for Service Bus messaging entities (both queues and topics) via the [Microsoft.ServiceBus.NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) class, which is constructed by supplying the base address of the Service Bus namespace and the user credentials.</span></span> <span data-ttu-id="84f68-127">[NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) specifica i metodi per creare, enumerare ed eliminare le entità di messaggistica.</span><span class="sxs-lookup"><span data-stu-id="84f68-127">[NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) provides methods to create, enumerate and delete messaging entities.</span></span> <span data-ttu-id="84f68-128">Dopo aver creato un oggetto [Microsoft.ServiceBus.TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#microsoft_servicebus_tokenprovider) da un nome e una chiave di firma di accesso condiviso e un oggetto di gestione dello spazio dei nomi servizio, è possibile usare il metodo [Microsoft.ServiceBus.NamespaceManager.CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) per creare la coda.</span><span class="sxs-lookup"><span data-stu-id="84f68-128">After creating a [Microsoft.ServiceBus.TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#microsoft_servicebus_tokenprovider) object from the SAS name and key, and a service namespace management object, you can use the [Microsoft.ServiceBus.NamespaceManager.CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) method to create the queue.</span></span> <span data-ttu-id="84f68-129">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="84f68-129">For example:</span></span>

```csharp
// Create management credentials
TokenProvider credentials = TokenProvider.CreateSharedAccessSignatureTokenProvider(sasKeyName,sasKeyValue);
// Create namespace client
NamespaceManager namespaceClient = new NamespaceManager(ServiceBusEnvironment.CreateServiceUri("sb", ServiceNamespace, string.Empty), credentials);
```

<span data-ttu-id="84f68-130">È quindi possibile creare un oggetto coda e una factory di messaggistica usando l'URI del bus di servizio come argomento.</span><span class="sxs-lookup"><span data-stu-id="84f68-130">You can then create a queue object and a messaging factory with the Service Bus URI as an argument.</span></span> <span data-ttu-id="84f68-131">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="84f68-131">For example:</span></span>

```csharp
QueueDescription myQueue;
myQueue = namespaceClient.CreateQueue("TestQueue");
MessagingFactory factory = MessagingFactory.Create(ServiceBusEnvironment.CreateServiceUri("sb", ServiceNamespace, string.Empty), credentials); 
QueueClient myQueueClient = factory.CreateQueueClient("TestQueue");
```

<span data-ttu-id="84f68-132">È quindi possibile inviare messaggi alla coda.</span><span class="sxs-lookup"><span data-stu-id="84f68-132">You can then send messages to the queue.</span></span> <span data-ttu-id="84f68-133">Se ad esempio si ha un elenco di messaggi negoziati denominato `MessageList`, sarà possibile usare un codice simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="84f68-133">For example, if you have a list of brokered messages called `MessageList`, the code appears similar to the following:</span></span>

```csharp
for (int count = 0; count < 6; count++)
{
    var issue = MessageList[count];
    issue.Label = issue.Properties["IssueTitle"].ToString();
    myQueueClient.Send(issue);
}
```

<span data-ttu-id="84f68-134">È possibile quindi ricevere messaggi dalla coda, come indicato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="84f68-134">You then receive messages from the queue as follows:</span></span>

```csharp
while ((message = myQueueClient.Receive(new TimeSpan(hours: 0, minutes: 0, seconds: 5))) != null)
    {
        Console.WriteLine(string.Format("Message received: {0}, {1}, {2}", message.SequenceNumber, message.Label, message.MessageId));
        message.Complete();

        Console.WriteLine("Processing message (sleeping...)");
        Thread.Sleep(1000);
    }
```

<span data-ttu-id="84f68-135">Quando si usa la modalità [ReceiveAndDelete](/dotnet/api/microsoft.servicebus.messaging.receivemode), la ricezione è un'operazione a un'unica fase. Quando il bus di servizio riceve la richiesta, contrassegna il messaggio come usato e lo restituisce all'applicazione.</span><span class="sxs-lookup"><span data-stu-id="84f68-135">In the [ReceiveAndDelete](/dotnet/api/microsoft.servicebus.messaging.receivemode) mode, the receive operation is single-shot; that is, when Service Bus receives the request, it marks the message as being consumed and returns it to the application.</span></span> <span data-ttu-id="84f68-136">La modalità **ReceiveAndDelete** rappresenta il modello più semplice ed è adatta per scenari in cui un'applicazione può tollerare la mancata elaborazione di un messaggio in caso di errore.</span><span class="sxs-lookup"><span data-stu-id="84f68-136">**ReceiveAndDelete** mode is the simplest model and works best for scenarios in which the application can tolerate not processing a message in the event of a failure.</span></span> <span data-ttu-id="84f68-137">Per comprendere meglio questo meccanismo, si consideri uno scenario in cui il consumer invia la richiesta di ricezione e viene arrestato in modo anomalo prima dell'elaborazione.</span><span class="sxs-lookup"><span data-stu-id="84f68-137">To understand this, consider a scenario in which the consumer issues the receive request and then crashes before processing it.</span></span> <span data-ttu-id="84f68-138">Poiché il bus di servizio contrassegna il messaggio come consumato, quando l'applicazione viene riavviata e inizia a consumare nuovamente i messaggi, il messaggio consumato prima dell'arresto anomalo risulterà perso.</span><span class="sxs-lookup"><span data-stu-id="84f68-138">Because Service Bus marks the message as being consumed, when the application restarts and begins consuming messages again, it will have missed the message that was consumed prior to the crash.</span></span>

<span data-ttu-id="84f68-139">Con la modalità [PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode) il processo di ricezione diventa un'operazione in due fasi, che rende possibile il supporto di applicazioni che non riescono a tollerare messaggi mancanti.</span><span class="sxs-lookup"><span data-stu-id="84f68-139">In [PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode) mode, the receive operation becomes two-stage, which makes it possible to support applications that cannot tolerate missing messages.</span></span> <span data-ttu-id="84f68-140">Quando il bus di servizio riceve la richiesta, individua il messaggio successivo da consumare, lo blocca per impedirne la ricezione da parte di altri consumer e lo restituisce quindi all'applicazione.</span><span class="sxs-lookup"><span data-stu-id="84f68-140">When Service Bus receives the request, it finds the next message to be consumed, locks it to prevent other consumers from receiving it, and then returns it to the application.</span></span> <span data-ttu-id="84f68-141">Dopo aver elaborato il messaggio o averlo archiviato in modo affidabile per una successiva elaborazione, l'applicazione esegue la seconda fase del processo di ricezione chiamando [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) sul messaggio ricevuto.</span><span class="sxs-lookup"><span data-stu-id="84f68-141">After the application finishes processing the message (or stores it reliably for future processing), it completes the second stage of the receive process by calling [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) on the received message.</span></span> <span data-ttu-id="84f68-142">Quando il bus di servizio vede la chiamata **Complete**, contrassegna il messaggio come usato.</span><span class="sxs-lookup"><span data-stu-id="84f68-142">When Service Bus sees the **Complete** call, it marks the message as being consumed.</span></span>

<span data-ttu-id="84f68-143">Se per qualche motivo l’applicazione non è in grado di elaborare il messaggio, può chiamare il metodo [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon), invece di [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete), per il messaggio ricevuto.</span><span class="sxs-lookup"><span data-stu-id="84f68-143">If the application is unable to process the message for some reason, it can call the [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) method on the received message (instead of [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span></span> <span data-ttu-id="84f68-144">In questo modo, il bus di servizio sbloccherà il messaggio che sarà disponibile per essere nuovamente ricevuto dallo stesso consumer o da un altro consumer concorrente.</span><span class="sxs-lookup"><span data-stu-id="84f68-144">This enables Service Bus to unlock the message and make it available to be received again, either by the same consumer or by another competing consumer.</span></span> <span data-ttu-id="84f68-145">Al blocco è associato anche un timeout. Se l'applicazione non riesce a elaborare il messaggio prima della scadenza del timeout, ad esempio a causa di un arresto anomalo, il bus di servizio sblocca il messaggio rendendolo nuovamente disponibile per la ricezione (eseguendo essenzialmente un'operazione [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) per impostazione predefinita).</span><span class="sxs-lookup"><span data-stu-id="84f68-145">Secondly, there is a timeout associated with the lock and if the application fails to process the message before the lock timeout expires (for example, if the application crashes), then Service Bus unlocks the message and makes it available to be received again (essentially performing an [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) operation by default).</span></span>

<span data-ttu-id="84f68-146">Si noti che in caso di arresto anomalo dell'applicazione dopo l'elaborazione del messaggio ma prima dell'emissione della richiesta **Complete**, il messaggio verrà nuovamente recapitato all'applicazione al riavvio.</span><span class="sxs-lookup"><span data-stu-id="84f68-146">Note that in the event that the application crashes after processing the message, but before the **Complete** request is issued, the message is redelivered to the application when it restarts.</span></span> <span data-ttu-id="84f68-147">Questo processo di elaborazione viene spesso definito di tipo *At-Least-Once*, per indicare che ogni messaggio viene elaborato almeno una volta.</span><span class="sxs-lookup"><span data-stu-id="84f68-147">This is often called *At Least Once* processing; that is, each message is processed at least once.</span></span> <span data-ttu-id="84f68-148">ma che in determinate situazioni potrà essere recapitato una seconda volta.</span><span class="sxs-lookup"><span data-stu-id="84f68-148">However, in certain situations the same message may be redelivered.</span></span> <span data-ttu-id="84f68-149">Se lo scenario non tollera la doppia elaborazione, sarà necessaria una logica aggiuntiva nell'applicazione per il rilevamento dei duplicati in base alla proprietà **MessageId** del messaggio, che rimane costante per tutti i tentativi di recapito.</span><span class="sxs-lookup"><span data-stu-id="84f68-149">If the scenario cannot tolerate duplicate processing, then additional logic is required in the application to detect duplicates which can be achieved based upon the **MessageId** property of the message, which remains constant across delivery attempts.</span></span> <span data-ttu-id="84f68-150">Questo tipo di elaborazione viene definito di tipo *Exactly Once*.</span><span class="sxs-lookup"><span data-stu-id="84f68-150">This is known as *Exactly Once* processing.</span></span>

## <a name="topics-and-subscriptions"></a><span data-ttu-id="84f68-151">Argomenti e sottoscrizioni</span><span class="sxs-lookup"><span data-stu-id="84f68-151">Topics and subscriptions</span></span>
<span data-ttu-id="84f68-152">Diversamente dalle code, in cui ogni messaggio viene elaborato da un unico consumer, gli *argomenti* e le *sottoscrizioni* offrono una forma di comunicazione di tipo uno-a-molti, in un modello di *pubblicazione/sottoscrizione*.</span><span class="sxs-lookup"><span data-stu-id="84f68-152">In contrast to queues, in which each message is processed by a single consumer, *topics* and *subscriptions* provide a one-to-many form of communication, in a *publish/subscribe* pattern.</span></span> <span data-ttu-id="84f68-153">Particolarmente utile per la comunicazione con un numero molto elevato di destinatari, ogni messaggio pubblicato è reso disponibile per ogni sottoscrizione registrata con l'argomento.</span><span class="sxs-lookup"><span data-stu-id="84f68-153">Useful for scaling to very large numbers of recipients, each published message is made available to each subscription registered with the topic.</span></span> <span data-ttu-id="84f68-154">I messaggi vengono inviati a un argomento e recapitati a una o più sottoscrizioni associate, a seconda delle regole di filtro che possono essere impostate per ogni sottoscrizione.</span><span class="sxs-lookup"><span data-stu-id="84f68-154">Messages are sent to a topic and delivered to one or more associated subscriptions, depending on filter rules that can be set on a per-subscription basis.</span></span> <span data-ttu-id="84f68-155">Per limitare i messaggi da ricevere, le sottoscrizioni possono usare filtri aggiuntivi.</span><span class="sxs-lookup"><span data-stu-id="84f68-155">The subscriptions can use additional filters to restrict the messages that they want to receive.</span></span> <span data-ttu-id="84f68-156">I messaggi vengono inviati a un argomento nello stesso modo in cui vengono inviati a una coda, con la differenza che i messaggi non vengono ricevuti direttamente dall'argomento.</span><span class="sxs-lookup"><span data-stu-id="84f68-156">Messages are sent to a topic in the same way they are sent to a queue, but messages are not received from the topic directly.</span></span> <span data-ttu-id="84f68-157">Vengono ricevuti dalle sottoscrizioni.</span><span class="sxs-lookup"><span data-stu-id="84f68-157">Instead, they are received from subscriptions.</span></span> <span data-ttu-id="84f68-158">La sottoscrizione di un argomento è simile a una coda virtuale che riceve copie dei messaggi inviati all'argomento.</span><span class="sxs-lookup"><span data-stu-id="84f68-158">A topic subscription resembles a virtual queue that receives copies of the messages that are sent to the topic.</span></span> <span data-ttu-id="84f68-159">La procedura di ricezione dei messaggi da parte di una sottoscrizione è identica a quella usata per la ricezione da parte di una coda.</span><span class="sxs-lookup"><span data-stu-id="84f68-159">Messages are received from a subscription identically to the way they are received from a queue.</span></span>

<span data-ttu-id="84f68-160">Ai fini di un confronto, la funzionalità di invio dei messaggi di una coda esegue il mapping direttamente a un argomento e la funzionalità di ricezione dei messaggi esegue il mapping a una sottoscrizione.</span><span class="sxs-lookup"><span data-stu-id="84f68-160">By way of comparison, the message-sending functionality of a queue maps directly to a topic and its message-receiving functionality maps to a subscription.</span></span> <span data-ttu-id="84f68-161">Questo significa anche che le sottoscrizioni supportano gli stessi modelli descritti prima in questa sezione in merito alle code: consumer concorrente, disaccoppiamento temporale, livellamento del carico e bilanciamento del carico.</span><span class="sxs-lookup"><span data-stu-id="84f68-161">Among other things, this means that subscriptions support the same patterns described earlier in this section with regard to queues: competing consumer, temporal decoupling, load leveling, and load balancing.</span></span>

<span data-ttu-id="84f68-162">La procedura per la creazione di un argomento è simile a quella per la creazione di una coda, come illustrato nell'esempio della sezione precedente.</span><span class="sxs-lookup"><span data-stu-id="84f68-162">Creating a topic is similar to creating a queue, as shown in the example in the previous section.</span></span> <span data-ttu-id="84f68-163">Creare l'URI del servizio e usare la classe [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) per creare il client dello spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="84f68-163">Create the service URI, and then use the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class to create the namespace client.</span></span> <span data-ttu-id="84f68-164">È quindi possibile creare un argomento usando il metodo [CreateTopic](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateTopic_System_String_).</span><span class="sxs-lookup"><span data-stu-id="84f68-164">You can then create a topic using the [CreateTopic](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateTopic_System_String_) method.</span></span> <span data-ttu-id="84f68-165">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="84f68-165">For example:</span></span>

```csharp
TopicDescription dataCollectionTopic = namespaceClient.CreateTopic("DataCollectionTopic");
```

<span data-ttu-id="84f68-166">Aggiungere quindi le sottoscrizioni desiderate:</span><span class="sxs-lookup"><span data-stu-id="84f68-166">Next, add subscriptions as desired:</span></span>

```csharp
SubscriptionDescription myAgentSubscription = namespaceClient.CreateSubscription(myTopic.Path, "Inventory");
SubscriptionDescription myAuditSubscription = namespaceClient.CreateSubscription(myTopic.Path, "Dashboard");
```

<span data-ttu-id="84f68-167">Sarà quindi possibile creare un client dell'argomento.</span><span class="sxs-lookup"><span data-stu-id="84f68-167">You can then create a topic client.</span></span> <span data-ttu-id="84f68-168">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="84f68-168">For example:</span></span>

```csharp
MessagingFactory factory = MessagingFactory.Create(serviceUri, tokenProvider);
TopicClient myTopicClient = factory.CreateTopicClient(myTopic.Path)
```

<span data-ttu-id="84f68-169">Usando il mittente del messaggio, è possibile inviare messaggi all'argomento e riceverli, come illustrato nella sezione precedente.</span><span class="sxs-lookup"><span data-stu-id="84f68-169">Using the message sender, you can send and receive messages to and from the topic, as shown in the previous section.</span></span> <span data-ttu-id="84f68-170">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="84f68-170">For example:</span></span>

```csharp
foreach (BrokeredMessage message in messageList)
{
    myTopicClient.Send(message);
    Console.WriteLine(
    string.Format("Message sent: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
}
```

<span data-ttu-id="84f68-171">Come accade per le code, i messaggi vengono ricevuti da una sottoscrizione usando un oggetto [SubscriptionClient](/dotnet/api/microsoft.servicebus.messaging.subscriptionclient) invece di un oggetto [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient).</span><span class="sxs-lookup"><span data-stu-id="84f68-171">Similar to queues, messages are received from a subscription using a [SubscriptionClient](/dotnet/api/microsoft.servicebus.messaging.subscriptionclient) object instead of a [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) object.</span></span> <span data-ttu-id="84f68-172">Creare il client della sottoscrizione, passando il nome dell'argomento, il nome della sottoscrizione e (facoltativamente) la modalità di ricezione come parametri.</span><span class="sxs-lookup"><span data-stu-id="84f68-172">Create the subscription client, passing the name of the topic, the name of the subscription, and (optionally) the receive mode as parameters.</span></span> <span data-ttu-id="84f68-173">Ad esempio, con la sottoscrizione **Inventory**:</span><span class="sxs-lookup"><span data-stu-id="84f68-173">For example, with the **Inventory** subscription:</span></span>

```csharp
// Create the subscription client
MessagingFactory factory = MessagingFactory.Create(serviceUri, tokenProvider); 

SubscriptionClient agentSubscriptionClient = factory.CreateSubscriptionClient("IssueTrackingTopic", "Inventory", ReceiveMode.PeekLock);
SubscriptionClient auditSubscriptionClient = factory.CreateSubscriptionClient("IssueTrackingTopic", "Dashboard", ReceiveMode.ReceiveAndDelete); 

while ((message = agentSubscriptionClient.Receive(TimeSpan.FromSeconds(5))) != null)
{
    Console.WriteLine("\nReceiving message from Inventory...");
    Console.WriteLine(string.Format("Message received: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
    message.Complete();
}          

// Create a receiver using ReceiveAndDelete mode
while ((message = auditSubscriptionClient.Receive(TimeSpan.FromSeconds(5))) != null)
{
    Console.WriteLine("\nReceiving message from Dashboard...");
    Console.WriteLine(string.Format("Message received: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
}
```

### <a name="rules-and-actions"></a><span data-ttu-id="84f68-174">Regole e azioni</span><span class="sxs-lookup"><span data-stu-id="84f68-174">Rules and actions</span></span>
<span data-ttu-id="84f68-175">In molti scenari, i messaggi con caratteristiche specifiche devono essere elaborati in modi specifici.</span><span class="sxs-lookup"><span data-stu-id="84f68-175">In many scenarios, messages that have specific characteristics must be processed in different ways.</span></span> <span data-ttu-id="84f68-176">A questo scopo, è possibile configurare le sottoscrizioni in modo che trovino i messaggi che presentano le proprietà desiderate e apportare quindi alcune modifiche a tali proprietà.</span><span class="sxs-lookup"><span data-stu-id="84f68-176">To enable this, you can configure subscriptions to find messages that have desired properties and then perform certain modifications to those properties.</span></span> <span data-ttu-id="84f68-177">Mentre nelle sottoscrizioni del bus di servizio tutti i messaggi vengono inviati all'argomento, l'utente può copiare solo un subset di tali messaggi nella coda virtuale delle sottoscrizioni.</span><span class="sxs-lookup"><span data-stu-id="84f68-177">While Service Bus subscriptions see all messages sent to the topic, you can only copy a subset of those messages to the virtual subscription queue.</span></span> <span data-ttu-id="84f68-178">Questa operazione viene eseguita usando i filtri della sottoscrizione.</span><span class="sxs-lookup"><span data-stu-id="84f68-178">This is accomplished using subscription filters.</span></span> <span data-ttu-id="84f68-179">Queste modifiche sono chiamate *azioni di filtro*.</span><span class="sxs-lookup"><span data-stu-id="84f68-179">Such modifications are called *filter actions*.</span></span> <span data-ttu-id="84f68-180">Quando viene creata una sottoscrizione, è possibile specificare un'espressione di filtro che agisce sulle proprietà del messaggio, sulle proprietà del sistema, ad esempio **Label**, e sulle proprietà dell'applicazione personalizzata, ad esempio **StoreName**. In questo caso l'espressione di filtro SQL è facoltativa. Senza un'espressione di filtro SQL, qualsiasi azione di filtro definita in una sottoscrizione verrà eseguita in tutti i messaggi di tale sottoscrizione.</span><span class="sxs-lookup"><span data-stu-id="84f68-180">When a subscription is created, you can supply a filter expression that operates on the properties of the message, both the system properties (for example, **Label**) and custom application properties (for example, **StoreName**.) The SQL filter expression is optional in this case; without a SQL filter expression, any filter action defined on a subscription will be performed on all the messages for that subscription.</span></span>

<span data-ttu-id="84f68-181">Facendo riferimento all'esempio precedente, per filtrare solo i messaggi provenienti da **Store1**, è necessario creare la sottoscrizione Dashboard come indicato nella procedura seguente:</span><span class="sxs-lookup"><span data-stu-id="84f68-181">Using the previous example, to filter messages coming only from **Store1**, you would create the Dashboard subscription as follows:</span></span>

```csharp
namespaceManager.CreateSubscription("IssueTrackingTopic", "Dashboard", new SqlFilter("StoreName = 'Store1'"));
```

<span data-ttu-id="84f68-182">Dopo aver creato questo filtro della sottoscrizione, solo i messaggi con la proprietà `StoreName` impostata su `Store1` vengono copiati nella coda virtuale per la sottoscrizione `Dashboard`.</span><span class="sxs-lookup"><span data-stu-id="84f68-182">With this subscription filter in place, only messages that have the `StoreName` property set to `Store1` are copied to the virtual queue for the `Dashboard` subscription.</span></span>

<span data-ttu-id="84f68-183">Per altre informazioni sui valori di filtro possibili, vedere la documentazione relativa alle classi [SqlFilter](/dotnet/api/microsoft.servicebus.messaging.sqlfilter) e [SqlRuleAction](/dotnet/api/microsoft.servicebus.messaging.sqlruleaction).</span><span class="sxs-lookup"><span data-stu-id="84f68-183">For more information about possible filter values, see the documentation for the [SqlFilter](/dotnet/api/microsoft.servicebus.messaging.sqlfilter) and [SqlRuleAction](/dotnet/api/microsoft.servicebus.messaging.sqlruleaction) classes.</span></span> <span data-ttu-id="84f68-184">Vedere anche gli esempi [Brokered Messaging: Advanced Filters](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749) (Messaggistica negoziata: filtri avanzati) e [Topic Filters](https://github.com/Azure-Samples/azure-servicebus-messaging-samples/tree/master/TopicFilters) (Filtri di argomento).</span><span class="sxs-lookup"><span data-stu-id="84f68-184">Also, see the [Brokered Messaging: Advanced Filters](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749) and [Topic Filters](https://github.com/Azure-Samples/azure-servicebus-messaging-samples/tree/master/TopicFilters) samples.</span></span>

## <a name="next-steps"></a><span data-ttu-id="84f68-185">Passaggi successivi</span><span class="sxs-lookup"><span data-stu-id="84f68-185">Next steps</span></span>
<span data-ttu-id="84f68-186">Per altri esempi e informazioni sull'uso della messaggistica del bus di servizio, vedere gli argomenti avanzati seguenti.</span><span class="sxs-lookup"><span data-stu-id="84f68-186">See the following advanced topics for more information and examples of using Service Bus messaging.</span></span>

* [<span data-ttu-id="84f68-187">Panoramica della messaggistica del bus di servizio</span><span class="sxs-lookup"><span data-stu-id="84f68-187">Service Bus messaging overview</span></span>](service-bus-messaging-overview.md)
* [<span data-ttu-id="84f68-188">Esercitazione sulla messaggistica negoziata del bus di servizio - .NET</span><span class="sxs-lookup"><span data-stu-id="84f68-188">Service Bus brokered messaging .NET tutorial</span></span>](service-bus-brokered-tutorial-dotnet.md)
* [<span data-ttu-id="84f68-189">Esercitazione sulla messaggistica negoziata del bus di servizio - REST</span><span class="sxs-lookup"><span data-stu-id="84f68-189">Service Bus brokered messaging REST tutorial</span></span>](service-bus-brokered-tutorial-rest.md)
* <span data-ttu-id="84f68-190">[Topic filters sample](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/Microsoft.ServiceBus.Messaging/TopicFilters) (Esempio Filtri di argomento)</span><span class="sxs-lookup"><span data-stu-id="84f68-190">[Topic Filters sample ](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/Microsoft.ServiceBus.Messaging/TopicFilters)</span></span>
* <span data-ttu-id="84f68-191">[Brokered Messaging: Advanced Filters sample](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749) (Esempio Messaggistica negoziata: filtri avanzati)</span><span class="sxs-lookup"><span data-stu-id="84f68-191">[Brokered Messaging: Advanced Filters sample](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749)</span></span>

